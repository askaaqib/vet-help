{"ast":null,"code":"/*! skylinkjs - v0.6.37 - 2019-01-29 */\n!function (f) {\n  if (\"object\" == typeof exports && \"undefined\" != typeof module) module.exports = f();else if (\"function\" == typeof define && define.amd) define([], f);else {\n    var g;\n    g = \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : this, g.io = f();\n  }\n}(function () {\n  var define;\n  return function e(t, n, r) {\n    function s(o, u) {\n      if (!n[o]) {\n        if (!t[o]) {\n          var a = \"function\" == typeof require && require;\n          if (!u && a) return a(o, !0);\n          if (i) return i(o, !0);\n          var f = new Error(\"Cannot find module '\" + o + \"'\");\n          throw f.code = \"MODULE_NOT_FOUND\", f;\n        }\n\n        var l = n[o] = {\n          exports: {}\n        };\n        t[o][0].call(l.exports, function (e) {\n          var n = t[o][1][e];\n          return s(n || e);\n        }, l, l.exports, e, t, n, r);\n      }\n\n      return n[o].exports;\n    }\n\n    for (var i = \"function\" == typeof require && require, o = 0; o < r.length; o++) {\n      s(r[o]);\n    }\n\n    return s;\n  }({\n    1: [function (_dereq_, module, exports) {\n      function lookup(uri, opts) {\n        \"object\" == typeof uri && (opts = uri, uri = void 0), opts = opts || {};\n        var io,\n            parsed = url(uri),\n            source = parsed.source,\n            id = parsed.id,\n            path = parsed.path,\n            sameNamespace = cache[id] && path in cache[id].nsps,\n            newConnection = opts.forceNew || opts[\"force new connection\"] || !1 === opts.multiplex || sameNamespace;\n        return newConnection ? (debug(\"ignoring socket cache for %s\", source), io = Manager(source, opts)) : (cache[id] || (debug(\"new io instance for %s\", source), cache[id] = Manager(source, opts)), io = cache[id]), io.socket(parsed.path);\n      }\n\n      var url = _dereq_(\"./url\"),\n          parser = _dereq_(\"socket.io-parser\"),\n          Manager = _dereq_(\"./manager\"),\n          debug = _dereq_(\"debug\")(\"socket.io-client\");\n\n      module.exports = exports = lookup;\n      var cache = exports.managers = {};\n      exports.protocol = parser.protocol, exports.connect = lookup, exports.Manager = _dereq_(\"./manager\"), exports.Socket = _dereq_(\"./socket\");\n    }, {\n      \"./manager\": 2,\n      \"./socket\": 4,\n      \"./url\": 5,\n      debug: 14,\n      \"socket.io-parser\": 40\n    }],\n    2: [function (_dereq_, module, exports) {\n      function Manager(uri, opts) {\n        if (!(this instanceof Manager)) return new Manager(uri, opts);\n        uri && \"object\" == typeof uri && (opts = uri, uri = void 0), opts = opts || {}, opts.path = opts.path || \"/socket.io\", this.nsps = {}, this.subs = [], this.opts = opts, this.reconnection(!1 !== opts.reconnection), this.reconnectionAttempts(opts.reconnectionAttempts || 1 / 0), this.reconnectionDelay(opts.reconnectionDelay || 1e3), this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3), this.randomizationFactor(opts.randomizationFactor || .5), this.backoff = new Backoff({\n          min: this.reconnectionDelay(),\n          max: this.reconnectionDelayMax(),\n          jitter: this.randomizationFactor()\n        }), this.timeout(null == opts.timeout ? 2e4 : opts.timeout), this.readyState = \"closed\", this.uri = uri, this.connecting = [], this.lastPing = null, this.encoding = !1, this.packetBuffer = [], this.encoder = new parser.Encoder(), this.decoder = new parser.Decoder(), this.autoConnect = !1 !== opts.autoConnect, this.autoConnect && this.open();\n      }\n\n      var eio = _dereq_(\"engine.io-client\"),\n          Socket = _dereq_(\"./socket\"),\n          Emitter = _dereq_(\"component-emitter\"),\n          parser = _dereq_(\"socket.io-parser\"),\n          on = _dereq_(\"./on\"),\n          bind = _dereq_(\"component-bind\"),\n          debug = _dereq_(\"debug\")(\"socket.io-client:manager\"),\n          indexOf = _dereq_(\"indexof\"),\n          Backoff = _dereq_(\"backo2\"),\n          has = Object.prototype.hasOwnProperty;\n\n      module.exports = Manager, Manager.prototype.emitAll = function () {\n        this.emit.apply(this, arguments);\n\n        for (var nsp in this.nsps) {\n          has.call(this.nsps, nsp) && this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);\n        }\n      }, Manager.prototype.updateSocketIds = function () {\n        for (var nsp in this.nsps) {\n          has.call(this.nsps, nsp) && (this.nsps[nsp].id = this.engine.id);\n        }\n      }, Emitter(Manager.prototype), Manager.prototype.reconnection = function (v) {\n        return arguments.length ? (this._reconnection = !!v, this) : this._reconnection;\n      }, Manager.prototype.reconnectionAttempts = function (v) {\n        return arguments.length ? (this._reconnectionAttempts = v, this) : this._reconnectionAttempts;\n      }, Manager.prototype.reconnectionDelay = function (v) {\n        return arguments.length ? (this._reconnectionDelay = v, this.backoff && this.backoff.setMin(v), this) : this._reconnectionDelay;\n      }, Manager.prototype.randomizationFactor = function (v) {\n        return arguments.length ? (this._randomizationFactor = v, this.backoff && this.backoff.setJitter(v), this) : this._randomizationFactor;\n      }, Manager.prototype.reconnectionDelayMax = function (v) {\n        return arguments.length ? (this._reconnectionDelayMax = v, this.backoff && this.backoff.setMax(v), this) : this._reconnectionDelayMax;\n      }, Manager.prototype.timeout = function (v) {\n        return arguments.length ? (this._timeout = v, this) : this._timeout;\n      }, Manager.prototype.maybeReconnectOnOpen = function () {\n        !this.reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect();\n      }, Manager.prototype.open = Manager.prototype.connect = function (fn) {\n        if (debug(\"readyState %s\", this.readyState), ~this.readyState.indexOf(\"open\")) return this;\n        debug(\"opening %s\", this.uri), this.engine = eio(this.uri, this.opts);\n        var socket = this.engine,\n            self = this;\n        this.readyState = \"opening\", this.skipReconnect = !1;\n        var openSub = on(socket, \"open\", function () {\n          self.onopen(), fn && fn();\n        }),\n            errorSub = on(socket, \"error\", function (data) {\n          if (debug(\"connect_error\"), self.cleanup(), self.readyState = \"closed\", self.emitAll(\"connect_error\", data), fn) {\n            var err = new Error(\"Connection error\");\n            err.data = data, fn(err);\n          } else self.maybeReconnectOnOpen();\n        });\n\n        if (!1 !== this._timeout) {\n          var timeout = this._timeout;\n          debug(\"connect attempt will timeout after %d\", timeout);\n          var timer = setTimeout(function () {\n            debug(\"connect attempt timed out after %d\", timeout), openSub.destroy(), socket.close(), socket.emit(\"error\", \"timeout\"), self.emitAll(\"connect_timeout\", timeout);\n          }, timeout);\n          this.subs.push({\n            destroy: function destroy() {\n              clearTimeout(timer);\n            }\n          });\n        }\n\n        return this.subs.push(openSub), this.subs.push(errorSub), this;\n      }, Manager.prototype.onopen = function () {\n        debug(\"open\"), this.cleanup(), this.readyState = \"open\", this.emit(\"open\");\n        var socket = this.engine;\n        this.subs.push(on(socket, \"data\", bind(this, \"ondata\"))), this.subs.push(on(socket, \"ping\", bind(this, \"onping\"))), this.subs.push(on(socket, \"pong\", bind(this, \"onpong\"))), this.subs.push(on(socket, \"error\", bind(this, \"onerror\"))), this.subs.push(on(socket, \"close\", bind(this, \"onclose\"))), this.subs.push(on(this.decoder, \"decoded\", bind(this, \"ondecoded\")));\n      }, Manager.prototype.onping = function () {\n        this.lastPing = new Date(), this.emitAll(\"ping\");\n      }, Manager.prototype.onpong = function () {\n        this.emitAll(\"pong\", new Date() - this.lastPing);\n      }, Manager.prototype.ondata = function (data) {\n        this.decoder.add(data);\n      }, Manager.prototype.ondecoded = function (packet) {\n        this.emit(\"packet\", packet);\n      }, Manager.prototype.onerror = function (err) {\n        debug(\"error\", err), this.emitAll(\"error\", err);\n      }, Manager.prototype.socket = function (nsp) {\n        function onConnecting() {\n          ~indexOf(self.connecting, socket) || self.connecting.push(socket);\n        }\n\n        var socket = this.nsps[nsp];\n\n        if (!socket) {\n          socket = new Socket(this, nsp), this.nsps[nsp] = socket;\n          var self = this;\n          socket.on(\"connecting\", onConnecting), socket.on(\"connect\", function () {\n            socket.id = self.engine.id;\n          }), this.autoConnect && onConnecting();\n        }\n\n        return socket;\n      }, Manager.prototype.destroy = function (socket) {\n        var index = indexOf(this.connecting, socket);\n        ~index && this.connecting.splice(index, 1), this.connecting.length || this.close();\n      }, Manager.prototype.packet = function (packet) {\n        debug(\"writing packet %j\", packet);\n        var self = this;\n        self.encoding ? self.packetBuffer.push(packet) : (self.encoding = !0, this.encoder.encode(packet, function (encodedPackets) {\n          for (var i = 0; i < encodedPackets.length; i++) {\n            self.engine.write(encodedPackets[i], packet.options);\n          }\n\n          self.encoding = !1, self.processPacketQueue();\n        }));\n      }, Manager.prototype.processPacketQueue = function () {\n        if (this.packetBuffer.length > 0 && !this.encoding) {\n          var pack = this.packetBuffer.shift();\n          this.packet(pack);\n        }\n      }, Manager.prototype.cleanup = function () {\n        debug(\"cleanup\");\n\n        for (var sub; sub = this.subs.shift();) {\n          sub.destroy();\n        }\n\n        this.packetBuffer = [], this.encoding = !1, this.lastPing = null, this.decoder.destroy();\n      }, Manager.prototype.close = Manager.prototype.disconnect = function () {\n        debug(\"disconnect\"), this.skipReconnect = !0, this.reconnecting = !1, \"opening\" == this.readyState && this.cleanup(), this.backoff.reset(), this.readyState = \"closed\", this.engine && this.engine.close();\n      }, Manager.prototype.onclose = function (reason) {\n        debug(\"onclose\"), this.cleanup(), this.backoff.reset(), this.readyState = \"closed\", this.emit(\"close\", reason), this._reconnection && !this.skipReconnect && this.reconnect();\n      }, Manager.prototype.reconnect = function () {\n        if (this.reconnecting || this.skipReconnect) return this;\n        var self = this;\n        if (this.backoff.attempts >= this._reconnectionAttempts) debug(\"reconnect failed\"), this.backoff.reset(), this.emitAll(\"reconnect_failed\"), this.reconnecting = !1;else {\n          var delay = this.backoff.duration();\n          debug(\"will wait %dms before reconnect attempt\", delay), this.reconnecting = !0;\n          var timer = setTimeout(function () {\n            self.skipReconnect || (debug(\"attempting reconnect\"), self.emitAll(\"reconnect_attempt\", self.backoff.attempts), self.emitAll(\"reconnecting\", self.backoff.attempts), self.skipReconnect || self.open(function (err) {\n              err ? (debug(\"reconnect attempt error\"), self.reconnecting = !1, self.reconnect(), self.emitAll(\"reconnect_error\", err.data)) : (debug(\"reconnect success\"), self.onreconnect());\n            }));\n          }, delay);\n          this.subs.push({\n            destroy: function destroy() {\n              clearTimeout(timer);\n            }\n          });\n        }\n      }, Manager.prototype.onreconnect = function () {\n        var attempt = this.backoff.attempts;\n        this.reconnecting = !1, this.backoff.reset(), this.updateSocketIds(), this.emitAll(\"reconnect\", attempt);\n      };\n    }, {\n      \"./on\": 3,\n      \"./socket\": 4,\n      backo2: 8,\n      \"component-bind\": 11,\n      \"component-emitter\": 12,\n      debug: 14,\n      \"engine.io-client\": 16,\n      indexof: 32,\n      \"socket.io-parser\": 40\n    }],\n    3: [function (_dereq_, module, exports) {\n      function on(obj, ev, fn) {\n        return obj.on(ev, fn), {\n          destroy: function destroy() {\n            obj.removeListener(ev, fn);\n          }\n        };\n      }\n\n      module.exports = on;\n    }, {}],\n    4: [function (_dereq_, module, exports) {\n      function Socket(io, nsp) {\n        this.io = io, this.nsp = nsp, this.json = this, this.ids = 0, this.acks = {}, this.receiveBuffer = [], this.sendBuffer = [], this.connected = !1, this.disconnected = !0, this.io.autoConnect && this.open();\n      }\n\n      var parser = _dereq_(\"socket.io-parser\"),\n          Emitter = _dereq_(\"component-emitter\"),\n          toArray = _dereq_(\"to-array\"),\n          on = _dereq_(\"./on\"),\n          bind = _dereq_(\"component-bind\"),\n          debug = _dereq_(\"debug\")(\"socket.io-client:socket\"),\n          hasBin = _dereq_(\"has-binary\");\n\n      module.exports = Socket;\n      var events = {\n        connect: 1,\n        connect_error: 1,\n        connect_timeout: 1,\n        connecting: 1,\n        disconnect: 1,\n        error: 1,\n        reconnect: 1,\n        reconnect_attempt: 1,\n        reconnect_failed: 1,\n        reconnect_error: 1,\n        reconnecting: 1,\n        ping: 1,\n        pong: 1\n      },\n          emit = Emitter.prototype.emit;\n      Emitter(Socket.prototype), Socket.prototype.subEvents = function () {\n        if (!this.subs) {\n          var io = this.io;\n          this.subs = [on(io, \"open\", bind(this, \"onopen\")), on(io, \"packet\", bind(this, \"onpacket\")), on(io, \"close\", bind(this, \"onclose\"))];\n        }\n      }, Socket.prototype.open = Socket.prototype.connect = function () {\n        return this.connected ? this : (this.subEvents(), this.io.open(), \"open\" == this.io.readyState && this.onopen(), this.emit(\"connecting\"), this);\n      }, Socket.prototype.send = function () {\n        var args = toArray(arguments);\n        return args.unshift(\"message\"), this.emit.apply(this, args), this;\n      }, Socket.prototype.emit = function (ev) {\n        if (events.hasOwnProperty(ev)) return emit.apply(this, arguments), this;\n        var args = toArray(arguments),\n            parserType = parser.EVENT;\n        hasBin(args) && (parserType = parser.BINARY_EVENT);\n        var packet = {\n          type: parserType,\n          data: args\n        };\n        return packet.options = {}, packet.options.compress = !this.flags || !1 !== this.flags.compress, \"function\" == typeof args[args.length - 1] && (debug(\"emitting packet with ack id %d\", this.ids), this.acks[this.ids] = args.pop(), packet.id = this.ids++), this.connected ? this.packet(packet) : this.sendBuffer.push(packet), delete this.flags, this;\n      }, Socket.prototype.packet = function (packet) {\n        packet.nsp = this.nsp, this.io.packet(packet);\n      }, Socket.prototype.onopen = function () {\n        debug(\"transport is open - connecting\"), \"/\" != this.nsp && this.packet({\n          type: parser.CONNECT\n        });\n      }, Socket.prototype.onclose = function (reason) {\n        debug(\"close (%s)\", reason), this.connected = !1, this.disconnected = !0, delete this.id, this.emit(\"disconnect\", reason);\n      }, Socket.prototype.onpacket = function (packet) {\n        if (packet.nsp == this.nsp) switch (packet.type) {\n          case parser.CONNECT:\n            this.onconnect();\n            break;\n\n          case parser.EVENT:\n          case parser.BINARY_EVENT:\n            this.onevent(packet);\n            break;\n\n          case parser.ACK:\n          case parser.BINARY_ACK:\n            this.onack(packet);\n            break;\n\n          case parser.DISCONNECT:\n            this.ondisconnect();\n            break;\n\n          case parser.ERROR:\n            this.emit(\"error\", packet.data);\n        }\n      }, Socket.prototype.onevent = function (packet) {\n        var args = packet.data || [];\n        debug(\"emitting event %j\", args), null != packet.id && (debug(\"attaching ack callback to event\"), args.push(this.ack(packet.id))), this.connected ? emit.apply(this, args) : this.receiveBuffer.push(args);\n      }, Socket.prototype.ack = function (id) {\n        var self = this,\n            sent = !1;\n        return function () {\n          if (!sent) {\n            sent = !0;\n            var args = toArray(arguments);\n            debug(\"sending ack %j\", args);\n            var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;\n            self.packet({\n              type: type,\n              id: id,\n              data: args\n            });\n          }\n        };\n      }, Socket.prototype.onack = function (packet) {\n        var ack = this.acks[packet.id];\n        \"function\" == typeof ack ? (debug(\"calling ack %s with %j\", packet.id, packet.data), ack.apply(this, packet.data), delete this.acks[packet.id]) : debug(\"bad ack %s\", packet.id);\n      }, Socket.prototype.onconnect = function () {\n        this.connected = !0, this.disconnected = !1, this.emit(\"connect\"), this.emitBuffered();\n      }, Socket.prototype.emitBuffered = function () {\n        var i;\n\n        for (i = 0; i < this.receiveBuffer.length; i++) {\n          emit.apply(this, this.receiveBuffer[i]);\n        }\n\n        for (this.receiveBuffer = [], i = 0; i < this.sendBuffer.length; i++) {\n          this.packet(this.sendBuffer[i]);\n        }\n\n        this.sendBuffer = [];\n      }, Socket.prototype.ondisconnect = function () {\n        debug(\"server disconnect (%s)\", this.nsp), this.destroy(), this.onclose(\"io server disconnect\");\n      }, Socket.prototype.destroy = function () {\n        if (this.subs) {\n          for (var i = 0; i < this.subs.length; i++) {\n            this.subs[i].destroy();\n          }\n\n          this.subs = null;\n        }\n\n        this.io.destroy(this);\n      }, Socket.prototype.close = Socket.prototype.disconnect = function () {\n        return this.connected && (debug(\"performing disconnect (%s)\", this.nsp), this.packet({\n          type: parser.DISCONNECT\n        })), this.destroy(), this.connected && this.onclose(\"io client disconnect\"), this;\n      }, Socket.prototype.compress = function (compress) {\n        return this.flags = this.flags || {}, this.flags.compress = compress, this;\n      };\n    }, {\n      \"./on\": 3,\n      \"component-bind\": 11,\n      \"component-emitter\": 12,\n      debug: 14,\n      \"has-binary\": 30,\n      \"socket.io-parser\": 40,\n      \"to-array\": 43\n    }],\n    5: [function (_dereq_, module, exports) {\n      (function (global) {\n        function url(uri, loc) {\n          var obj = uri,\n              loc = loc || global.location;\n          null == uri && (uri = loc.protocol + \"//\" + loc.host), \"string\" == typeof uri && (\"/\" == uri.charAt(0) && (uri = \"/\" == uri.charAt(1) ? loc.protocol + uri : loc.host + uri), /^(https?|wss?):\\/\\//.test(uri) || (debug(\"protocol-less url %s\", uri), uri = void 0 !== loc ? loc.protocol + \"//\" + uri : \"https://\" + uri), debug(\"parse %s\", uri), obj = parseuri(uri)), obj.port || (/^(http|ws)$/.test(obj.protocol) ? obj.port = \"80\" : /^(http|ws)s$/.test(obj.protocol) && (obj.port = \"443\")), obj.path = obj.path || \"/\";\n          var ipv6 = -1 !== obj.host.indexOf(\":\"),\n              host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n          return obj.id = obj.protocol + \"://\" + host + \":\" + obj.port, obj.href = obj.protocol + \"://\" + host + (loc && loc.port == obj.port ? \"\" : \":\" + obj.port), obj;\n        }\n\n        var parseuri = _dereq_(\"parseuri\"),\n            debug = _dereq_(\"debug\")(\"socket.io-client:url\");\n\n        module.exports = url;\n      }).call(this, \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : {});\n    }, {\n      debug: 14,\n      parseuri: 38\n    }],\n    6: [function (_dereq_, module, exports) {\n      function after(count, callback, err_cb) {\n        function proxy(err, result) {\n          if (proxy.count <= 0) throw new Error(\"after called too many times\");\n          --proxy.count, err ? (bail = !0, callback(err), callback = err_cb) : 0 !== proxy.count || bail || callback(null, result);\n        }\n\n        var bail = !1;\n        return err_cb = err_cb || noop, proxy.count = count, 0 === count ? callback() : proxy;\n      }\n\n      function noop() {}\n\n      module.exports = after;\n    }, {}],\n    7: [function (_dereq_, module, exports) {\n      module.exports = function (arraybuffer, start, end) {\n        var bytes = arraybuffer.byteLength;\n        if (start = start || 0, end = end || bytes, arraybuffer.slice) return arraybuffer.slice(start, end);\n        if (start < 0 && (start += bytes), end < 0 && (end += bytes), end > bytes && (end = bytes), start >= bytes || start >= end || 0 === bytes) return new ArrayBuffer(0);\n\n        for (var abv = new Uint8Array(arraybuffer), result = new Uint8Array(end - start), i = start, ii = 0; i < end; i++, ii++) {\n          result[ii] = abv[i];\n        }\n\n        return result.buffer;\n      };\n    }, {}],\n    8: [function (_dereq_, module, exports) {\n      function Backoff(opts) {\n        opts = opts || {}, this.ms = opts.min || 100, this.max = opts.max || 1e4, this.factor = opts.factor || 2, this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0, this.attempts = 0;\n      }\n\n      module.exports = Backoff, Backoff.prototype.duration = function () {\n        var ms = this.ms * Math.pow(this.factor, this.attempts++);\n\n        if (this.jitter) {\n          var rand = Math.random(),\n              deviation = Math.floor(rand * this.jitter * ms);\n          ms = 0 == (1 & Math.floor(10 * rand)) ? ms - deviation : ms + deviation;\n        }\n\n        return 0 | Math.min(ms, this.max);\n      }, Backoff.prototype.reset = function () {\n        this.attempts = 0;\n      }, Backoff.prototype.setMin = function (min) {\n        this.ms = min;\n      }, Backoff.prototype.setMax = function (max) {\n        this.max = max;\n      }, Backoff.prototype.setJitter = function (jitter) {\n        this.jitter = jitter;\n      };\n    }, {}],\n    9: [function (_dereq_, module, exports) {\n      !function () {\n        \"use strict\";\n\n        for (var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", lookup = new Uint8Array(256), i = 0; i < chars.length; i++) {\n          lookup[chars.charCodeAt(i)] = i;\n        }\n\n        exports.encode = function (arraybuffer) {\n          var i,\n              bytes = new Uint8Array(arraybuffer),\n              len = bytes.length,\n              base64 = \"\";\n\n          for (i = 0; i < len; i += 3) {\n            base64 += chars[bytes[i] >> 2], base64 += chars[(3 & bytes[i]) << 4 | bytes[i + 1] >> 4], base64 += chars[(15 & bytes[i + 1]) << 2 | bytes[i + 2] >> 6], base64 += chars[63 & bytes[i + 2]];\n          }\n\n          return len % 3 == 2 ? base64 = base64.substring(0, base64.length - 1) + \"=\" : len % 3 == 1 && (base64 = base64.substring(0, base64.length - 2) + \"==\"), base64;\n        }, exports.decode = function (base64) {\n          var i,\n              encoded1,\n              encoded2,\n              encoded3,\n              encoded4,\n              bufferLength = .75 * base64.length,\n              len = base64.length,\n              p = 0;\n          \"=\" === base64[base64.length - 1] && (bufferLength--, \"=\" === base64[base64.length - 2] && bufferLength--);\n          var arraybuffer = new ArrayBuffer(bufferLength),\n              bytes = new Uint8Array(arraybuffer);\n\n          for (i = 0; i < len; i += 4) {\n            encoded1 = lookup[base64.charCodeAt(i)], encoded2 = lookup[base64.charCodeAt(i + 1)], encoded3 = lookup[base64.charCodeAt(i + 2)], encoded4 = lookup[base64.charCodeAt(i + 3)], bytes[p++] = encoded1 << 2 | encoded2 >> 4, bytes[p++] = (15 & encoded2) << 4 | encoded3 >> 2, bytes[p++] = (3 & encoded3) << 6 | 63 & encoded4;\n          }\n\n          return arraybuffer;\n        };\n      }();\n    }, {}],\n    10: [function (_dereq_, module, exports) {\n      (function (global) {\n        function mapArrayBufferViews(ary) {\n          for (var i = 0; i < ary.length; i++) {\n            var chunk = ary[i];\n\n            if (chunk.buffer instanceof ArrayBuffer) {\n              var buf = chunk.buffer;\n\n              if (chunk.byteLength !== buf.byteLength) {\n                var copy = new Uint8Array(chunk.byteLength);\n                copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength)), buf = copy.buffer;\n              }\n\n              ary[i] = buf;\n            }\n          }\n        }\n\n        function BlobBuilderConstructor(ary, options) {\n          options = options || {};\n          var bb = new BlobBuilder();\n          mapArrayBufferViews(ary);\n\n          for (var i = 0; i < ary.length; i++) {\n            bb.append(ary[i]);\n          }\n\n          return options.type ? bb.getBlob(options.type) : bb.getBlob();\n        }\n\n        function BlobConstructor(ary, options) {\n          return mapArrayBufferViews(ary), new Blob(ary, options || {});\n        }\n\n        var BlobBuilder = global.BlobBuilder || global.WebKitBlobBuilder || global.MSBlobBuilder || global.MozBlobBuilder,\n            blobSupported = function () {\n          try {\n            return 2 === new Blob([\"hi\"]).size;\n          } catch (e) {\n            return !1;\n          }\n        }(),\n            blobSupportsArrayBufferView = blobSupported && function () {\n          try {\n            return 2 === new Blob([new Uint8Array([1, 2])]).size;\n          } catch (e) {\n            return !1;\n          }\n        }(),\n            blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;\n\n        module.exports = function () {\n          return blobSupported ? blobSupportsArrayBufferView ? global.Blob : BlobConstructor : blobBuilderSupported ? BlobBuilderConstructor : void 0;\n        }();\n      }).call(this, \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : {});\n    }, {}],\n    11: [function (_dereq_, module, exports) {\n      var slice = [].slice;\n\n      module.exports = function (obj, fn) {\n        if (\"string\" == typeof fn && (fn = obj[fn]), \"function\" != typeof fn) throw new Error(\"bind() requires a function\");\n        var args = slice.call(arguments, 2);\n        return function () {\n          return fn.apply(obj, args.concat(slice.call(arguments)));\n        };\n      };\n    }, {}],\n    12: [function (_dereq_, module, exports) {\n      function Emitter(obj) {\n        if (obj) return mixin(obj);\n      }\n\n      function mixin(obj) {\n        for (var key in Emitter.prototype) {\n          obj[key] = Emitter.prototype[key];\n        }\n\n        return obj;\n      }\n\n      module.exports = Emitter, Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {\n        return this._callbacks = this._callbacks || {}, (this._callbacks[\"$\" + event] = this._callbacks[\"$\" + event] || []).push(fn), this;\n      }, Emitter.prototype.once = function (event, fn) {\n        function on() {\n          this.off(event, on), fn.apply(this, arguments);\n        }\n\n        return on.fn = fn, this.on(event, on), this;\n      }, Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {\n        if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;\n        var callbacks = this._callbacks[\"$\" + event];\n        if (!callbacks) return this;\n        if (1 == arguments.length) return delete this._callbacks[\"$\" + event], this;\n\n        for (var cb, i = 0; i < callbacks.length; i++) {\n          if ((cb = callbacks[i]) === fn || cb.fn === fn) {\n            callbacks.splice(i, 1);\n            break;\n          }\n        }\n\n        return this;\n      }, Emitter.prototype.emit = function (event) {\n        this._callbacks = this._callbacks || {};\n        var args = [].slice.call(arguments, 1),\n            callbacks = this._callbacks[\"$\" + event];\n\n        if (callbacks) {\n          callbacks = callbacks.slice(0);\n\n          for (var i = 0, len = callbacks.length; i < len; ++i) {\n            callbacks[i].apply(this, args);\n          }\n        }\n\n        return this;\n      }, Emitter.prototype.listeners = function (event) {\n        return this._callbacks = this._callbacks || {}, this._callbacks[\"$\" + event] || [];\n      }, Emitter.prototype.hasListeners = function (event) {\n        return !!this.listeners(event).length;\n      };\n    }, {}],\n    13: [function (_dereq_, module, exports) {\n      module.exports = function (a, b) {\n        var fn = function fn() {};\n\n        fn.prototype = b.prototype, a.prototype = new fn(), a.prototype.constructor = a;\n      };\n    }, {}],\n    14: [function (_dereq_, module, exports) {\n      function useColors() {\n        return \"WebkitAppearance\" in document.documentElement.style || window.console && (console.firebug || console.exception && console.table) || navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31;\n      }\n\n      function formatArgs() {\n        var args = arguments,\n            useColors = this.useColors;\n        if (args[0] = (useColors ? \"%c\" : \"\") + this.namespace + (useColors ? \" %c\" : \" \") + args[0] + (useColors ? \"%c \" : \" \") + \"+\" + exports.humanize(this.diff), !useColors) return args;\n        var c = \"color: \" + this.color;\n        args = [args[0], c, \"color: inherit\"].concat(Array.prototype.slice.call(args, 1));\n        var index = 0,\n            lastC = 0;\n        return args[0].replace(/%[a-z%]/g, function (match) {\n          \"%%\" !== match && (index++, \"%c\" === match && (lastC = index));\n        }), args.splice(lastC, 0, c), args;\n      }\n\n      function log() {\n        return \"object\" == typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);\n      }\n\n      function save(namespaces) {\n        try {\n          null == namespaces ? exports.storage.removeItem(\"debug\") : exports.storage.debug = namespaces;\n        } catch (e) {}\n      }\n\n      function load() {\n        var r;\n\n        try {\n          r = exports.storage.debug;\n        } catch (e) {}\n\n        return r;\n      }\n\n      function localstorage() {\n        try {\n          return window.localStorage;\n        } catch (e) {}\n      }\n\n      exports = module.exports = _dereq_(\"./debug\"), exports.log = log, exports.formatArgs = formatArgs, exports.save = save, exports.load = load, exports.useColors = useColors, exports.storage = \"undefined\" != typeof chrome && void 0 !== chrome.storage ? chrome.storage.local : localstorage(), exports.colors = [\"lightseagreen\", \"forestgreen\", \"goldenrod\", \"dodgerblue\", \"darkorchid\", \"crimson\"], exports.formatters.j = function (v) {\n        return JSON.stringify(v);\n      }, exports.enable(load());\n    }, {\n      \"./debug\": 15\n    }],\n    15: [function (_dereq_, module, exports) {\n      function selectColor() {\n        return exports.colors[prevColor++ % exports.colors.length];\n      }\n\n      function debug(namespace) {\n        function disabled() {}\n\n        function enabled() {\n          var self = enabled,\n              curr = +new Date(),\n              ms = curr - (prevTime || curr);\n          self.diff = ms, self.prev = prevTime, self.curr = curr, prevTime = curr, null == self.useColors && (self.useColors = exports.useColors()), null == self.color && self.useColors && (self.color = selectColor());\n          var args = Array.prototype.slice.call(arguments);\n          args[0] = exports.coerce(args[0]), \"string\" != typeof args[0] && (args = [\"%o\"].concat(args));\n          var index = 0;\n          args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {\n            if (\"%%\" === match) return match;\n            index++;\n            var formatter = exports.formatters[format];\n\n            if (\"function\" == typeof formatter) {\n              var val = args[index];\n              match = formatter.call(self, val), args.splice(index, 1), index--;\n            }\n\n            return match;\n          }), \"function\" == typeof exports.formatArgs && (args = exports.formatArgs.apply(self, args)), (enabled.log || exports.log || console.log.bind(console)).apply(self, args);\n        }\n\n        disabled.enabled = !1, enabled.enabled = !0;\n        var fn = exports.enabled(namespace) ? enabled : disabled;\n        return fn.namespace = namespace, fn;\n      }\n\n      function enable(namespaces) {\n        exports.save(namespaces);\n\n        for (var split = (namespaces || \"\").split(/[\\s,]+/), len = split.length, i = 0; i < len; i++) {\n          split[i] && (namespaces = split[i].replace(/\\*/g, \".*?\"), \"-\" === namespaces[0] ? exports.skips.push(new RegExp(\"^\" + namespaces.substr(1) + \"$\")) : exports.names.push(new RegExp(\"^\" + namespaces + \"$\")));\n        }\n      }\n\n      function disable() {\n        exports.enable(\"\");\n      }\n\n      function enabled(name) {\n        var i, len;\n\n        for (i = 0, len = exports.skips.length; i < len; i++) {\n          if (exports.skips[i].test(name)) return !1;\n        }\n\n        for (i = 0, len = exports.names.length; i < len; i++) {\n          if (exports.names[i].test(name)) return !0;\n        }\n\n        return !1;\n      }\n\n      function coerce(val) {\n        return val instanceof Error ? val.stack || val.message : val;\n      }\n\n      exports = module.exports = debug, exports.coerce = coerce, exports.disable = disable, exports.enable = enable, exports.enabled = enabled, exports.humanize = _dereq_(\"ms\"), exports.names = [], exports.skips = [], exports.formatters = {};\n      var prevTime,\n          prevColor = 0;\n    }, {\n      ms: 35\n    }],\n    16: [function (_dereq_, module, exports) {\n      module.exports = _dereq_(\"./lib/\");\n    }, {\n      \"./lib/\": 17\n    }],\n    17: [function (_dereq_, module, exports) {\n      module.exports = _dereq_(\"./socket\"), module.exports.parser = _dereq_(\"engine.io-parser\");\n    }, {\n      \"./socket\": 18,\n      \"engine.io-parser\": 27\n    }],\n    18: [function (_dereq_, module, exports) {\n      (function (global) {\n        function Socket(uri, opts) {\n          if (!(this instanceof Socket)) return new Socket(uri, opts);\n          opts = opts || {}, uri && \"object\" == typeof uri && (opts = uri, uri = null), uri ? (uri = parseuri(uri), opts.hostname = uri.host, opts.secure = \"https\" == uri.protocol || \"wss\" == uri.protocol, opts.port = uri.port, uri.query && (opts.query = uri.query)) : opts.host && (opts.hostname = parseuri(opts.host).host), this.secure = null != opts.secure ? opts.secure : global.location && \"https:\" == location.protocol, opts.hostname && !opts.port && (opts.port = this.secure ? \"443\" : \"80\"), this.agent = opts.agent || !1, this.hostname = opts.hostname || (global.location ? location.hostname : \"localhost\"), this.port = opts.port || (global.location && location.port ? location.port : this.secure ? 443 : 80), this.query = opts.query || {}, \"string\" == typeof this.query && (this.query = parseqs.decode(this.query)), this.upgrade = !1 !== opts.upgrade, this.path = (opts.path || \"/engine.io\").replace(/\\/$/, \"\") + \"/\", this.forceJSONP = !!opts.forceJSONP, this.jsonp = !1 !== opts.jsonp, this.forceBase64 = !!opts.forceBase64, this.enablesXDR = !!opts.enablesXDR, this.timestampParam = opts.timestampParam || \"t\", this.timestampRequests = opts.timestampRequests, this.transports = opts.transports || [\"polling\", \"websocket\"], this.readyState = \"\", this.writeBuffer = [], this.policyPort = opts.policyPort || 843, this.rememberUpgrade = opts.rememberUpgrade || !1, this.binaryType = null, this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades, this.perMessageDeflate = !1 !== opts.perMessageDeflate && (opts.perMessageDeflate || {}), !0 === this.perMessageDeflate && (this.perMessageDeflate = {}), this.perMessageDeflate && null == this.perMessageDeflate.threshold && (this.perMessageDeflate.threshold = 1024), this.pfx = opts.pfx || null, this.key = opts.key || null, this.passphrase = opts.passphrase || null, this.cert = opts.cert || null, this.ca = opts.ca || null, this.ciphers = opts.ciphers || null, this.rejectUnauthorized = void 0 === opts.rejectUnauthorized || opts.rejectUnauthorized;\n          var freeGlobal = \"object\" == typeof global && global;\n          freeGlobal.global === freeGlobal && opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0 && (this.extraHeaders = opts.extraHeaders), this.open();\n        }\n\n        function clone(obj) {\n          var o = {};\n\n          for (var i in obj) {\n            obj.hasOwnProperty(i) && (o[i] = obj[i]);\n          }\n\n          return o;\n        }\n\n        var transports = _dereq_(\"./transports\"),\n            Emitter = _dereq_(\"component-emitter\"),\n            debug = _dereq_(\"debug\")(\"engine.io-client:socket\"),\n            index = _dereq_(\"indexof\"),\n            parser = _dereq_(\"engine.io-parser\"),\n            parseuri = _dereq_(\"parseuri\"),\n            parsejson = _dereq_(\"parsejson\"),\n            parseqs = _dereq_(\"parseqs\");\n\n        module.exports = Socket, Socket.priorWebsocketSuccess = !1, Emitter(Socket.prototype), Socket.protocol = parser.protocol, Socket.Socket = Socket, Socket.Transport = _dereq_(\"./transport\"), Socket.transports = _dereq_(\"./transports\"), Socket.parser = _dereq_(\"engine.io-parser\"), Socket.prototype.createTransport = function (name) {\n          debug('creating transport \"%s\"', name);\n          var query = clone(this.query);\n          return query.EIO = parser.protocol, query.transport = name, this.id && (query.sid = this.id), new transports[name]({\n            agent: this.agent,\n            hostname: this.hostname,\n            port: this.port,\n            secure: this.secure,\n            path: this.path,\n            query: query,\n            forceJSONP: this.forceJSONP,\n            jsonp: this.jsonp,\n            forceBase64: this.forceBase64,\n            enablesXDR: this.enablesXDR,\n            timestampRequests: this.timestampRequests,\n            timestampParam: this.timestampParam,\n            policyPort: this.policyPort,\n            socket: this,\n            pfx: this.pfx,\n            key: this.key,\n            passphrase: this.passphrase,\n            cert: this.cert,\n            ca: this.ca,\n            ciphers: this.ciphers,\n            rejectUnauthorized: this.rejectUnauthorized,\n            perMessageDeflate: this.perMessageDeflate,\n            extraHeaders: this.extraHeaders\n          });\n        }, Socket.prototype.open = function () {\n          var transport;\n          if (this.rememberUpgrade && Socket.priorWebsocketSuccess && -1 != this.transports.indexOf(\"websocket\")) transport = \"websocket\";else {\n            if (0 === this.transports.length) {\n              var self = this;\n              return void setTimeout(function () {\n                self.emit(\"error\", \"No transports available\");\n              }, 0);\n            }\n\n            transport = this.transports[0];\n          }\n          this.readyState = \"opening\";\n\n          try {\n            transport = this.createTransport(transport);\n          } catch (e) {\n            return this.transports.shift(), void this.open();\n          }\n\n          transport.open(), this.setTransport(transport);\n        }, Socket.prototype.setTransport = function (transport) {\n          debug(\"setting transport %s\", transport.name);\n          var self = this;\n          this.transport && (debug(\"clearing existing transport %s\", this.transport.name), this.transport.removeAllListeners()), this.transport = transport, transport.on(\"drain\", function () {\n            self.onDrain();\n          }).on(\"packet\", function (packet) {\n            self.onPacket(packet);\n          }).on(\"error\", function (e) {\n            self.onError(e);\n          }).on(\"close\", function () {\n            self.onClose(\"transport close\");\n          });\n        }, Socket.prototype.probe = function (name) {\n          function onTransportOpen() {\n            if (self.onlyBinaryUpgrades) {\n              var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;\n              failed = failed || upgradeLosesBinary;\n            }\n\n            failed || (debug('probe transport \"%s\" opened', name), transport.send([{\n              type: \"ping\",\n              data: \"probe\"\n            }]), transport.once(\"packet\", function (msg) {\n              if (!failed) if (\"pong\" == msg.type && \"probe\" == msg.data) {\n                if (debug('probe transport \"%s\" pong', name), self.upgrading = !0, self.emit(\"upgrading\", transport), !transport) return;\n                Socket.priorWebsocketSuccess = \"websocket\" == transport.name, debug('pausing current transport \"%s\"', self.transport.name), self.transport.pause(function () {\n                  failed || \"closed\" != self.readyState && (debug(\"changing transport and sending upgrade packet\"), cleanup(), self.setTransport(transport), transport.send([{\n                    type: \"upgrade\"\n                  }]), self.emit(\"upgrade\", transport), transport = null, self.upgrading = !1, self.flush());\n                });\n              } else {\n                debug('probe transport \"%s\" failed', name);\n                var err = new Error(\"probe error\");\n                err.transport = transport.name, self.emit(\"upgradeError\", err);\n              }\n            }));\n          }\n\n          function freezeTransport() {\n            failed || (failed = !0, cleanup(), transport.close(), transport = null);\n          }\n\n          function onerror(err) {\n            var error = new Error(\"probe error: \" + err);\n            error.transport = transport.name, freezeTransport(), debug('probe transport \"%s\" failed because of error: %s', name, err), self.emit(\"upgradeError\", error);\n          }\n\n          function onTransportClose() {\n            onerror(\"transport closed\");\n          }\n\n          function onclose() {\n            onerror(\"socket closed\");\n          }\n\n          function onupgrade(to) {\n            transport && to.name != transport.name && (debug('\"%s\" works - aborting \"%s\"', to.name, transport.name), freezeTransport());\n          }\n\n          function cleanup() {\n            transport.removeListener(\"open\", onTransportOpen), transport.removeListener(\"error\", onerror), transport.removeListener(\"close\", onTransportClose), self.removeListener(\"close\", onclose), self.removeListener(\"upgrading\", onupgrade);\n          }\n\n          debug('probing transport \"%s\"', name);\n          var transport = this.createTransport(name, {\n            probe: 1\n          }),\n              failed = !1,\n              self = this;\n          Socket.priorWebsocketSuccess = !1, transport.once(\"open\", onTransportOpen), transport.once(\"error\", onerror), transport.once(\"close\", onTransportClose), this.once(\"close\", onclose), this.once(\"upgrading\", onupgrade), transport.open();\n        }, Socket.prototype.onOpen = function () {\n          if (debug(\"socket open\"), this.readyState = \"open\", Socket.priorWebsocketSuccess = \"websocket\" == this.transport.name, this.emit(\"open\"), this.flush(), \"open\" == this.readyState && this.upgrade && this.transport.pause) {\n            debug(\"starting upgrade probes\");\n\n            for (var i = 0, l = this.upgrades.length; i < l; i++) {\n              this.probe(this.upgrades[i]);\n            }\n          }\n        }, Socket.prototype.onPacket = function (packet) {\n          if (\"opening\" == this.readyState || \"open\" == this.readyState) switch (debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data), this.emit(\"packet\", packet), this.emit(\"heartbeat\"), packet.type) {\n            case \"open\":\n              this.onHandshake(parsejson(packet.data));\n              break;\n\n            case \"pong\":\n              this.setPing(), this.emit(\"pong\");\n              break;\n\n            case \"error\":\n              var err = new Error(\"server error\");\n              err.code = packet.data, this.onError(err);\n              break;\n\n            case \"message\":\n              this.emit(\"data\", packet.data), this.emit(\"message\", packet.data);\n          } else debug('packet received with socket readyState \"%s\"', this.readyState);\n        }, Socket.prototype.onHandshake = function (data) {\n          this.emit(\"handshake\", data), this.id = data.sid, this.transport.query.sid = data.sid, this.upgrades = this.filterUpgrades(data.upgrades), this.pingInterval = data.pingInterval, this.pingTimeout = data.pingTimeout, this.onOpen(), \"closed\" != this.readyState && (this.setPing(), this.removeListener(\"heartbeat\", this.onHeartbeat), this.on(\"heartbeat\", this.onHeartbeat));\n        }, Socket.prototype.onHeartbeat = function (timeout) {\n          clearTimeout(this.pingTimeoutTimer);\n          var self = this;\n          self.pingTimeoutTimer = setTimeout(function () {\n            \"closed\" != self.readyState && self.onClose(\"ping timeout\");\n          }, timeout || self.pingInterval + self.pingTimeout);\n        }, Socket.prototype.setPing = function () {\n          var self = this;\n          clearTimeout(self.pingIntervalTimer), self.pingIntervalTimer = setTimeout(function () {\n            debug(\"writing ping packet - expecting pong within %sms\", self.pingTimeout), self.ping(), self.onHeartbeat(self.pingTimeout);\n          }, self.pingInterval);\n        }, Socket.prototype.ping = function () {\n          var self = this;\n          this.sendPacket(\"ping\", function () {\n            self.emit(\"ping\");\n          });\n        }, Socket.prototype.onDrain = function () {\n          this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, 0 === this.writeBuffer.length ? this.emit(\"drain\") : this.flush();\n        }, Socket.prototype.flush = function () {\n          \"closed\" != this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length && (debug(\"flushing %d packets in socket\", this.writeBuffer.length), this.transport.send(this.writeBuffer), this.prevBufferLen = this.writeBuffer.length, this.emit(\"flush\"));\n        }, Socket.prototype.write = Socket.prototype.send = function (msg, options, fn) {\n          return this.sendPacket(\"message\", msg, options, fn), this;\n        }, Socket.prototype.sendPacket = function (type, data, options, fn) {\n          if (\"function\" == typeof data && (fn = data, data = void 0), \"function\" == typeof options && (fn = options, options = null), \"closing\" != this.readyState && \"closed\" != this.readyState) {\n            options = options || {}, options.compress = !1 !== options.compress;\n            var packet = {\n              type: type,\n              data: data,\n              options: options\n            };\n            this.emit(\"packetCreate\", packet), this.writeBuffer.push(packet), fn && this.once(\"flush\", fn), this.flush();\n          }\n        }, Socket.prototype.close = function () {\n          function close() {\n            self.onClose(\"forced close\"), debug(\"socket closing - telling transport to close\"), self.transport.close();\n          }\n\n          function cleanupAndClose() {\n            self.removeListener(\"upgrade\", cleanupAndClose), self.removeListener(\"upgradeError\", cleanupAndClose), close();\n          }\n\n          function waitForUpgrade() {\n            self.once(\"upgrade\", cleanupAndClose), self.once(\"upgradeError\", cleanupAndClose);\n          }\n\n          if (\"opening\" == this.readyState || \"open\" == this.readyState) {\n            this.readyState = \"closing\";\n            var self = this;\n            this.writeBuffer.length ? this.once(\"drain\", function () {\n              this.upgrading ? waitForUpgrade() : close();\n            }) : this.upgrading ? waitForUpgrade() : close();\n          }\n\n          return this;\n        }, Socket.prototype.onError = function (err) {\n          debug(\"socket error %j\", err), Socket.priorWebsocketSuccess = !1, this.emit(\"error\", err), this.onClose(\"transport error\", err);\n        }, Socket.prototype.onClose = function (reason, desc) {\n          if (\"opening\" == this.readyState || \"open\" == this.readyState || \"closing\" == this.readyState) {\n            debug('socket close with reason: \"%s\"', reason);\n            var self = this;\n            clearTimeout(this.pingIntervalTimer), clearTimeout(this.pingTimeoutTimer), this.transport.removeAllListeners(\"close\"), this.transport.close(), this.transport.removeAllListeners(), this.readyState = \"closed\", this.id = null, this.emit(\"close\", reason, desc), self.writeBuffer = [], self.prevBufferLen = 0;\n          }\n        }, Socket.prototype.filterUpgrades = function (upgrades) {\n          for (var filteredUpgrades = [], i = 0, j = upgrades.length; i < j; i++) {\n            ~index(this.transports, upgrades[i]) && filteredUpgrades.push(upgrades[i]);\n          }\n\n          return filteredUpgrades;\n        };\n      }).call(this, \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : {});\n    }, {\n      \"./transport\": 19,\n      \"./transports\": 20,\n      \"component-emitter\": 26,\n      debug: 14,\n      \"engine.io-parser\": 27,\n      indexof: 32,\n      parsejson: 36,\n      parseqs: 37,\n      parseuri: 38\n    }],\n    19: [function (_dereq_, module, exports) {\n      function Transport(opts) {\n        this.path = opts.path, this.hostname = opts.hostname, this.port = opts.port, this.secure = opts.secure, this.query = opts.query, this.timestampParam = opts.timestampParam, this.timestampRequests = opts.timestampRequests, this.readyState = \"\", this.agent = opts.agent || !1, this.socket = opts.socket, this.enablesXDR = opts.enablesXDR, this.pfx = opts.pfx, this.key = opts.key, this.passphrase = opts.passphrase, this.cert = opts.cert, this.ca = opts.ca, this.ciphers = opts.ciphers, this.rejectUnauthorized = opts.rejectUnauthorized, this.extraHeaders = opts.extraHeaders;\n      }\n\n      var parser = _dereq_(\"engine.io-parser\"),\n          Emitter = _dereq_(\"component-emitter\");\n\n      module.exports = Transport, Emitter(Transport.prototype), Transport.prototype.onError = function (msg, desc) {\n        var err = new Error(msg);\n        return err.type = \"TransportError\", err.description = desc, this.emit(\"error\", err), this;\n      }, Transport.prototype.open = function () {\n        return \"closed\" != this.readyState && \"\" != this.readyState || (this.readyState = \"opening\", this.doOpen()), this;\n      }, Transport.prototype.close = function () {\n        return \"opening\" != this.readyState && \"open\" != this.readyState || (this.doClose(), this.onClose()), this;\n      }, Transport.prototype.send = function (packets) {\n        if (\"open\" != this.readyState) throw new Error(\"Transport not open\");\n        this.write(packets);\n      }, Transport.prototype.onOpen = function () {\n        this.readyState = \"open\", this.writable = !0, this.emit(\"open\");\n      }, Transport.prototype.onData = function (data) {\n        var packet = parser.decodePacket(data, this.socket.binaryType);\n        this.onPacket(packet);\n      }, Transport.prototype.onPacket = function (packet) {\n        this.emit(\"packet\", packet);\n      }, Transport.prototype.onClose = function () {\n        this.readyState = \"closed\", this.emit(\"close\");\n      };\n    }, {\n      \"component-emitter\": 26,\n      \"engine.io-parser\": 27\n    }],\n    20: [function (_dereq_, module, exports) {\n      (function (global) {\n        function polling(opts) {\n          var xd = !1,\n              xs = !1,\n              jsonp = !1 !== opts.jsonp;\n\n          if (global.location) {\n            var isSSL = \"https:\" == location.protocol,\n                port = location.port;\n            port || (port = isSSL ? 443 : 80), xd = opts.hostname != location.hostname || port != opts.port, xs = opts.secure != isSSL;\n          }\n\n          if (opts.xdomain = xd, opts.xscheme = xs, \"open\" in new XMLHttpRequest(opts) && !opts.forceJSONP) return new XHR(opts);\n          if (!jsonp) throw new Error(\"JSONP disabled\");\n          return new JSONP(opts);\n        }\n\n        var XMLHttpRequest = _dereq_(\"xmlhttprequest-ssl\"),\n            XHR = _dereq_(\"./polling-xhr\"),\n            JSONP = _dereq_(\"./polling-jsonp\"),\n            websocket = _dereq_(\"./websocket\");\n\n        exports.polling = polling, exports.websocket = websocket;\n      }).call(this, \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : {});\n    }, {\n      \"./polling-jsonp\": 21,\n      \"./polling-xhr\": 22,\n      \"./websocket\": 24,\n      \"xmlhttprequest-ssl\": 25\n    }],\n    21: [function (_dereq_, module, exports) {\n      (function (global) {\n        function empty() {}\n\n        function JSONPPolling(opts) {\n          Polling.call(this, opts), this.query = this.query || {}, callbacks || (global.___eio || (global.___eio = []), callbacks = global.___eio), this.index = callbacks.length;\n          var self = this;\n          callbacks.push(function (msg) {\n            self.onData(msg);\n          }), this.query.j = this.index, global.document && global.addEventListener && global.addEventListener(\"beforeunload\", function () {\n            self.script && (self.script.onerror = empty);\n          }, !1);\n        }\n\n        var Polling = _dereq_(\"./polling\"),\n            inherit = _dereq_(\"component-inherit\");\n\n        module.exports = JSONPPolling;\n        var callbacks,\n            rNewline = /\\n/g,\n            rEscapedNewline = /\\\\n/g;\n        inherit(JSONPPolling, Polling), JSONPPolling.prototype.supportsBinary = !1, JSONPPolling.prototype.doClose = function () {\n          this.script && (this.script.parentNode.removeChild(this.script), this.script = null), this.form && (this.form.parentNode.removeChild(this.form), this.form = null, this.iframe = null), Polling.prototype.doClose.call(this);\n        }, JSONPPolling.prototype.doPoll = function () {\n          var self = this,\n              script = document.createElement(\"script\");\n          this.script && (this.script.parentNode.removeChild(this.script), this.script = null), script.async = !0, script.src = this.uri(), script.onerror = function (e) {\n            self.onError(\"jsonp poll error\", e);\n          };\n          var insertAt = document.getElementsByTagName(\"script\")[0];\n          insertAt ? insertAt.parentNode.insertBefore(script, insertAt) : (document.head || document.body).appendChild(script), this.script = script, \"undefined\" != typeof navigator && /gecko/i.test(navigator.userAgent) && setTimeout(function () {\n            var iframe = document.createElement(\"iframe\");\n            document.body.appendChild(iframe), document.body.removeChild(iframe);\n          }, 100);\n        }, JSONPPolling.prototype.doWrite = function (data, fn) {\n          function complete() {\n            initIframe(), fn();\n          }\n\n          function initIframe() {\n            if (self.iframe) try {\n              self.form.removeChild(self.iframe);\n            } catch (e) {\n              self.onError(\"jsonp polling iframe removal error\", e);\n            }\n\n            try {\n              var html = '<iframe src=\"javascript:0\" name=\"' + self.iframeId + '\">';\n              iframe = document.createElement(html);\n            } catch (e) {\n              iframe = document.createElement(\"iframe\"), iframe.name = self.iframeId, iframe.src = \"javascript:0\";\n            }\n\n            iframe.id = self.iframeId, self.form.appendChild(iframe), self.iframe = iframe;\n          }\n\n          var self = this;\n\n          if (!this.form) {\n            var iframe,\n                form = document.createElement(\"form\"),\n                area = document.createElement(\"textarea\"),\n                id = this.iframeId = \"eio_iframe_\" + this.index;\n            form.className = \"socketio\", form.style.position = \"absolute\", form.style.top = \"-1000px\", form.style.left = \"-1000px\", form.target = id, form.method = \"POST\", form.setAttribute(\"accept-charset\", \"utf-8\"), area.name = \"d\", form.appendChild(area), document.body.appendChild(form), this.form = form, this.area = area;\n          }\n\n          this.form.action = this.uri(), initIframe(), data = data.replace(rEscapedNewline, \"\\\\\\n\"), this.area.value = data.replace(rNewline, \"\\\\n\");\n\n          try {\n            this.form.submit();\n          } catch (e) {}\n\n          this.iframe.attachEvent ? this.iframe.onreadystatechange = function () {\n            \"complete\" == self.iframe.readyState && complete();\n          } : this.iframe.onload = complete;\n        };\n      }).call(this, \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : {});\n    }, {\n      \"./polling\": 23,\n      \"component-inherit\": 13\n    }],\n    22: [function (_dereq_, module, exports) {\n      (function (global) {\n        function empty() {}\n\n        function XHR(opts) {\n          if (Polling.call(this, opts), global.location) {\n            var isSSL = \"https:\" == location.protocol,\n                port = location.port;\n            port || (port = isSSL ? 443 : 80), this.xd = opts.hostname != global.location.hostname || port != opts.port, this.xs = opts.secure != isSSL;\n          } else this.extraHeaders = opts.extraHeaders;\n        }\n\n        function Request(opts) {\n          this.method = opts.method || \"GET\", this.uri = opts.uri, this.xd = !!opts.xd, this.xs = !!opts.xs, this.async = !1 !== opts.async, this.data = void 0 != opts.data ? opts.data : null, this.agent = opts.agent, this.isBinary = opts.isBinary, this.supportsBinary = opts.supportsBinary, this.enablesXDR = opts.enablesXDR, this.pfx = opts.pfx, this.key = opts.key, this.passphrase = opts.passphrase, this.cert = opts.cert, this.ca = opts.ca, this.ciphers = opts.ciphers, this.rejectUnauthorized = opts.rejectUnauthorized, this.extraHeaders = opts.extraHeaders, this.create();\n        }\n\n        function unloadHandler() {\n          for (var i in Request.requests) {\n            Request.requests.hasOwnProperty(i) && Request.requests[i].abort();\n          }\n        }\n\n        var XMLHttpRequest = _dereq_(\"xmlhttprequest-ssl\"),\n            Polling = _dereq_(\"./polling\"),\n            Emitter = _dereq_(\"component-emitter\"),\n            inherit = _dereq_(\"component-inherit\"),\n            debug = _dereq_(\"debug\")(\"engine.io-client:polling-xhr\");\n\n        module.exports = XHR, module.exports.Request = Request, inherit(XHR, Polling), XHR.prototype.supportsBinary = !0, XHR.prototype.request = function (opts) {\n          return opts = opts || {}, opts.uri = this.uri(), opts.xd = this.xd, opts.xs = this.xs, opts.agent = this.agent || !1, opts.supportsBinary = this.supportsBinary, opts.enablesXDR = this.enablesXDR, opts.pfx = this.pfx, opts.key = this.key, opts.passphrase = this.passphrase, opts.cert = this.cert, opts.ca = this.ca, opts.ciphers = this.ciphers, opts.rejectUnauthorized = this.rejectUnauthorized, opts.extraHeaders = this.extraHeaders, new Request(opts);\n        }, XHR.prototype.doWrite = function (data, fn) {\n          var isBinary = \"string\" != typeof data && void 0 !== data,\n              req = this.request({\n            method: \"POST\",\n            data: data,\n            isBinary: isBinary\n          }),\n              self = this;\n          req.on(\"success\", fn), req.on(\"error\", function (err) {\n            self.onError(\"xhr post error\", err);\n          }), this.sendXhr = req;\n        }, XHR.prototype.doPoll = function () {\n          debug(\"xhr poll\");\n          var req = this.request(),\n              self = this;\n          req.on(\"data\", function (data) {\n            self.onData(data);\n          }), req.on(\"error\", function (err) {\n            self.onError(\"xhr poll error\", err);\n          }), this.pollXhr = req;\n        }, Emitter(Request.prototype), Request.prototype.create = function () {\n          var opts = {\n            agent: this.agent,\n            xdomain: this.xd,\n            xscheme: this.xs,\n            enablesXDR: this.enablesXDR\n          };\n          opts.pfx = this.pfx, opts.key = this.key, opts.passphrase = this.passphrase, opts.cert = this.cert, opts.ca = this.ca, opts.ciphers = this.ciphers, opts.rejectUnauthorized = this.rejectUnauthorized;\n          var xhr = this.xhr = new XMLHttpRequest(opts),\n              self = this;\n\n          try {\n            debug(\"xhr open %s: %s\", this.method, this.uri), xhr.open(this.method, this.uri, this.async);\n\n            try {\n              if (this.extraHeaders) {\n                xhr.setDisableHeaderCheck(!0);\n\n                for (var i in this.extraHeaders) {\n                  this.extraHeaders.hasOwnProperty(i) && xhr.setRequestHeader(i, this.extraHeaders[i]);\n                }\n              }\n            } catch (e) {}\n\n            if (this.supportsBinary && (xhr.responseType = \"arraybuffer\"), \"POST\" == this.method) try {\n              this.isBinary ? xhr.setRequestHeader(\"Content-type\", \"application/octet-stream\") : xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n            } catch (e) {}\n            \"withCredentials\" in xhr && (xhr.withCredentials = !0), this.hasXDR() ? (xhr.onload = function () {\n              self.onLoad();\n            }, xhr.onerror = function () {\n              self.onError(xhr.responseText);\n            }) : xhr.onreadystatechange = function () {\n              4 == xhr.readyState && (200 == xhr.status || 1223 == xhr.status ? self.onLoad() : setTimeout(function () {\n                self.onError(xhr.status);\n              }, 0));\n            }, debug(\"xhr data %s\", this.data), xhr.send(this.data);\n          } catch (e) {\n            return void setTimeout(function () {\n              self.onError(e);\n            }, 0);\n          }\n\n          global.document && (this.index = Request.requestsCount++, Request.requests[this.index] = this);\n        }, Request.prototype.onSuccess = function () {\n          this.emit(\"success\"), this.cleanup();\n        }, Request.prototype.onData = function (data) {\n          this.emit(\"data\", data), this.onSuccess();\n        }, Request.prototype.onError = function (err) {\n          this.emit(\"error\", err), this.cleanup(!0);\n        }, Request.prototype.cleanup = function (fromError) {\n          if (void 0 !== this.xhr && null !== this.xhr) {\n            if (this.hasXDR() ? this.xhr.onload = this.xhr.onerror = empty : this.xhr.onreadystatechange = empty, fromError) try {\n              this.xhr.abort();\n            } catch (e) {}\n            global.document && delete Request.requests[this.index], this.xhr = null;\n          }\n        }, Request.prototype.onLoad = function () {\n          var data;\n\n          try {\n            var contentType;\n\n            try {\n              contentType = this.xhr.getResponseHeader(\"Content-Type\").split(\";\")[0];\n            } catch (e) {}\n\n            if (\"application/octet-stream\" === contentType) data = this.xhr.response;else if (this.supportsBinary) try {\n              data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));\n            } catch (e) {\n              for (var ui8Arr = new Uint8Array(this.xhr.response), dataArray = [], idx = 0, length = ui8Arr.length; idx < length; idx++) {\n                dataArray.push(ui8Arr[idx]);\n              }\n\n              data = String.fromCharCode.apply(null, dataArray);\n            } else data = this.xhr.responseText;\n          } catch (e) {\n            this.onError(e);\n          }\n\n          null != data && this.onData(data);\n        }, Request.prototype.hasXDR = function () {\n          return void 0 !== global.XDomainRequest && !this.xs && this.enablesXDR;\n        }, Request.prototype.abort = function () {\n          this.cleanup();\n        }, global.document && (Request.requestsCount = 0, Request.requests = {}, global.attachEvent ? global.attachEvent(\"onunload\", unloadHandler) : global.addEventListener && global.addEventListener(\"beforeunload\", unloadHandler, !1));\n      }).call(this, \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : {});\n    }, {\n      \"./polling\": 23,\n      \"component-emitter\": 26,\n      \"component-inherit\": 13,\n      debug: 14,\n      \"xmlhttprequest-ssl\": 25\n    }],\n    23: [function (_dereq_, module, exports) {\n      function Polling(opts) {\n        var forceBase64 = opts && opts.forceBase64;\n        hasXHR2 && !forceBase64 || (this.supportsBinary = !1), Transport.call(this, opts);\n      }\n\n      var Transport = _dereq_(\"../transport\"),\n          parseqs = _dereq_(\"parseqs\"),\n          parser = _dereq_(\"engine.io-parser\"),\n          inherit = _dereq_(\"component-inherit\"),\n          yeast = _dereq_(\"yeast\"),\n          debug = _dereq_(\"debug\")(\"engine.io-client:polling\");\n\n      module.exports = Polling;\n\n      var hasXHR2 = function () {\n        return null != new (_dereq_(\"xmlhttprequest-ssl\"))({\n          xdomain: !1\n        }).responseType;\n      }();\n\n      inherit(Polling, Transport), Polling.prototype.name = \"polling\", Polling.prototype.doOpen = function () {\n        this.poll();\n      }, Polling.prototype.pause = function (onPause) {\n        function pause() {\n          debug(\"paused\"), self.readyState = \"paused\", onPause();\n        }\n\n        var self = this;\n\n        if (this.readyState = \"pausing\", this.polling || !this.writable) {\n          var total = 0;\n          this.polling && (debug(\"we are currently polling - waiting to pause\"), total++, this.once(\"pollComplete\", function () {\n            debug(\"pre-pause polling complete\"), --total || pause();\n          })), this.writable || (debug(\"we are currently writing - waiting to pause\"), total++, this.once(\"drain\", function () {\n            debug(\"pre-pause writing complete\"), --total || pause();\n          }));\n        } else pause();\n      }, Polling.prototype.poll = function () {\n        debug(\"polling\"), this.polling = !0, this.doPoll(), this.emit(\"poll\");\n      }, Polling.prototype.onData = function (data) {\n        var self = this;\n        debug(\"polling got data %s\", data);\n\n        var callback = function callback(packet, index, total) {\n          if (\"opening\" == self.readyState && self.onOpen(), \"close\" == packet.type) return self.onClose(), !1;\n          self.onPacket(packet);\n        };\n\n        parser.decodePayload(data, this.socket.binaryType, callback), \"closed\" != this.readyState && (this.polling = !1, this.emit(\"pollComplete\"), \"open\" == this.readyState ? this.poll() : debug('ignoring poll - transport state \"%s\"', this.readyState));\n      }, Polling.prototype.doClose = function () {\n        function close() {\n          debug(\"writing close packet\"), self.write([{\n            type: \"close\"\n          }]);\n        }\n\n        var self = this;\n        \"open\" == this.readyState ? (debug(\"transport open - closing\"), close()) : (debug(\"transport not open - deferring close\"), this.once(\"open\", close));\n      }, Polling.prototype.write = function (packets) {\n        var self = this;\n        this.writable = !1;\n\n        var callbackfn = function callbackfn() {\n          self.writable = !0, self.emit(\"drain\");\n        },\n            self = this;\n\n        parser.encodePayload(packets, this.supportsBinary, function (data) {\n          self.doWrite(data, callbackfn);\n        });\n      }, Polling.prototype.uri = function () {\n        var query = this.query || {},\n            schema = this.secure ? \"https\" : \"http\",\n            port = \"\";\n        return !1 !== this.timestampRequests && (query[this.timestampParam] = yeast()), this.supportsBinary || query.sid || (query.b64 = 1), query = parseqs.encode(query), this.port && (\"https\" == schema && 443 != this.port || \"http\" == schema && 80 != this.port) && (port = \":\" + this.port), query.length && (query = \"?\" + query), schema + \"://\" + (-1 !== this.hostname.indexOf(\":\") ? \"[\" + this.hostname + \"]\" : this.hostname) + port + this.path + query;\n      };\n    }, {\n      \"../transport\": 19,\n      \"component-inherit\": 13,\n      debug: 14,\n      \"engine.io-parser\": 27,\n      parseqs: 37,\n      \"xmlhttprequest-ssl\": 25,\n      yeast: 45\n    }],\n    24: [function (_dereq_, module, exports) {\n      (function (global) {\n        function WS(opts) {\n          opts && opts.forceBase64 && (this.supportsBinary = !1), this.perMessageDeflate = opts.perMessageDeflate, Transport.call(this, opts);\n        }\n\n        var Transport = _dereq_(\"../transport\"),\n            parser = _dereq_(\"engine.io-parser\"),\n            parseqs = _dereq_(\"parseqs\"),\n            inherit = _dereq_(\"component-inherit\"),\n            yeast = _dereq_(\"yeast\"),\n            debug = _dereq_(\"debug\")(\"engine.io-client:websocket\"),\n            BrowserWebSocket = global.WebSocket || global.MozWebSocket,\n            WebSocket = BrowserWebSocket;\n\n        if (!WebSocket && \"undefined\" == typeof window) try {\n          WebSocket = _dereq_(\"ws\");\n        } catch (e) {}\n        module.exports = WS, inherit(WS, Transport), WS.prototype.name = \"websocket\", WS.prototype.supportsBinary = !0, WS.prototype.doOpen = function () {\n          if (this.check()) {\n            var uri = this.uri(),\n                opts = {\n              agent: this.agent,\n              perMessageDeflate: this.perMessageDeflate\n            };\n            opts.pfx = this.pfx, opts.key = this.key, opts.passphrase = this.passphrase, opts.cert = this.cert, opts.ca = this.ca, opts.ciphers = this.ciphers, opts.rejectUnauthorized = this.rejectUnauthorized, this.extraHeaders && (opts.headers = this.extraHeaders), this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, void 0, opts), void 0 === this.ws.binaryType && (this.supportsBinary = !1), this.ws.supports && this.ws.supports.binary ? (this.supportsBinary = !0, this.ws.binaryType = \"buffer\") : this.ws.binaryType = \"arraybuffer\", this.addEventListeners();\n          }\n        }, WS.prototype.addEventListeners = function () {\n          var self = this;\n          this.ws.onopen = function () {\n            self.onOpen();\n          }, this.ws.onclose = function () {\n            self.onClose();\n          }, this.ws.onmessage = function (ev) {\n            self.onData(ev.data);\n          }, this.ws.onerror = function (e) {\n            self.onError(\"websocket error\", e);\n          };\n        }, \"undefined\" != typeof navigator && /iPad|iPhone|iPod/i.test(navigator.userAgent) && (WS.prototype.onData = function (data) {\n          var self = this;\n          setTimeout(function () {\n            Transport.prototype.onData.call(self, data);\n          }, 0);\n        }), WS.prototype.write = function (packets) {\n          function done() {\n            self.emit(\"flush\"), setTimeout(function () {\n              self.writable = !0, self.emit(\"drain\");\n            }, 0);\n          }\n\n          var self = this;\n          this.writable = !1;\n\n          for (var total = packets.length, i = 0, l = total; i < l; i++) {\n            !function (packet) {\n              parser.encodePacket(packet, self.supportsBinary, function (data) {\n                if (!BrowserWebSocket) {\n                  var opts = {};\n\n                  if (packet.options && (opts.compress = packet.options.compress), self.perMessageDeflate) {\n                    (\"string\" == typeof data ? global.Buffer.byteLength(data) : data.length) < self.perMessageDeflate.threshold && (opts.compress = !1);\n                  }\n                }\n\n                try {\n                  BrowserWebSocket ? self.ws.send(data) : self.ws.send(data, opts);\n                } catch (e) {\n                  debug(\"websocket closed before onclose event\");\n                }\n\n                --total || done();\n              });\n            }(packets[i]);\n          }\n        }, WS.prototype.onClose = function () {\n          Transport.prototype.onClose.call(this);\n        }, WS.prototype.doClose = function () {\n          void 0 !== this.ws && this.ws.close();\n        }, WS.prototype.uri = function () {\n          var query = this.query || {},\n              schema = this.secure ? \"wss\" : \"ws\",\n              port = \"\";\n          return this.port && (\"wss\" == schema && 443 != this.port || \"ws\" == schema && 80 != this.port) && (port = \":\" + this.port), this.timestampRequests && (query[this.timestampParam] = yeast()), this.supportsBinary || (query.b64 = 1), query = parseqs.encode(query), query.length && (query = \"?\" + query), schema + \"://\" + (-1 !== this.hostname.indexOf(\":\") ? \"[\" + this.hostname + \"]\" : this.hostname) + port + this.path + query;\n        }, WS.prototype.check = function () {\n          return !(!WebSocket || \"__initialize\" in WebSocket && this.name === WS.prototype.name);\n        };\n      }).call(this, \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : {});\n    }, {\n      \"../transport\": 19,\n      \"component-inherit\": 13,\n      debug: 14,\n      \"engine.io-parser\": 27,\n      parseqs: 37,\n      ws: void 0,\n      yeast: 45\n    }],\n    25: [function (_dereq_, module, exports) {\n      var hasCORS = _dereq_(\"has-cors\");\n\n      module.exports = function (opts) {\n        var xdomain = opts.xdomain,\n            xscheme = opts.xscheme,\n            enablesXDR = opts.enablesXDR;\n\n        try {\n          if (\"undefined\" != typeof XMLHttpRequest && (!xdomain || hasCORS)) return new XMLHttpRequest();\n        } catch (e) {}\n\n        try {\n          if (\"undefined\" != typeof XDomainRequest && !xscheme && enablesXDR) return new XDomainRequest();\n        } catch (e) {}\n\n        if (!xdomain) try {\n          return new ActiveXObject(\"Microsoft.XMLHTTP\");\n        } catch (e) {}\n      };\n    }, {\n      \"has-cors\": 31\n    }],\n    26: [function (_dereq_, module, exports) {\n      function Emitter(obj) {\n        if (obj) return mixin(obj);\n      }\n\n      function mixin(obj) {\n        for (var key in Emitter.prototype) {\n          obj[key] = Emitter.prototype[key];\n        }\n\n        return obj;\n      }\n\n      module.exports = Emitter, Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {\n        return this._callbacks = this._callbacks || {}, (this._callbacks[event] = this._callbacks[event] || []).push(fn), this;\n      }, Emitter.prototype.once = function (event, fn) {\n        function on() {\n          self.off(event, on), fn.apply(this, arguments);\n        }\n\n        var self = this;\n        return this._callbacks = this._callbacks || {}, on.fn = fn, this.on(event, on), this;\n      }, Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {\n        if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;\n        var callbacks = this._callbacks[event];\n        if (!callbacks) return this;\n        if (1 == arguments.length) return delete this._callbacks[event], this;\n\n        for (var cb, i = 0; i < callbacks.length; i++) {\n          if ((cb = callbacks[i]) === fn || cb.fn === fn) {\n            callbacks.splice(i, 1);\n            break;\n          }\n        }\n\n        return this;\n      }, Emitter.prototype.emit = function (event) {\n        this._callbacks = this._callbacks || {};\n        var args = [].slice.call(arguments, 1),\n            callbacks = this._callbacks[event];\n\n        if (callbacks) {\n          callbacks = callbacks.slice(0);\n\n          for (var i = 0, len = callbacks.length; i < len; ++i) {\n            callbacks[i].apply(this, args);\n          }\n        }\n\n        return this;\n      }, Emitter.prototype.listeners = function (event) {\n        return this._callbacks = this._callbacks || {}, this._callbacks[event] || [];\n      }, Emitter.prototype.hasListeners = function (event) {\n        return !!this.listeners(event).length;\n      };\n    }, {}],\n    27: [function (_dereq_, module, exports) {\n      (function (global) {\n        function encodeBase64Object(packet, callback) {\n          return callback(\"b\" + exports.packets[packet.type] + packet.data.data);\n        }\n\n        function encodeArrayBuffer(packet, supportsBinary, callback) {\n          if (!supportsBinary) return exports.encodeBase64Packet(packet, callback);\n          var data = packet.data,\n              contentArray = new Uint8Array(data),\n              resultBuffer = new Uint8Array(1 + data.byteLength);\n          resultBuffer[0] = packets[packet.type];\n\n          for (var i = 0; i < contentArray.length; i++) {\n            resultBuffer[i + 1] = contentArray[i];\n          }\n\n          return callback(resultBuffer.buffer);\n        }\n\n        function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {\n          if (!supportsBinary) return exports.encodeBase64Packet(packet, callback);\n          var fr = new FileReader();\n          return fr.onload = function () {\n            packet.data = fr.result, exports.encodePacket(packet, supportsBinary, !0, callback);\n          }, fr.readAsArrayBuffer(packet.data);\n        }\n\n        function encodeBlob(packet, supportsBinary, callback) {\n          if (!supportsBinary) return exports.encodeBase64Packet(packet, callback);\n          if (dontSendBlobs) return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);\n          var length = new Uint8Array(1);\n          return length[0] = packets[packet.type], callback(new Blob([length.buffer, packet.data]));\n        }\n\n        function map(ary, each, done) {\n          for (var result = new Array(ary.length), next = after(ary.length, done), eachWithIndex = function eachWithIndex(i, el, cb) {\n            each(el, function (error, msg) {\n              result[i] = msg, cb(error, result);\n            });\n          }, i = 0; i < ary.length; i++) {\n            eachWithIndex(i, ary[i], next);\n          }\n        }\n\n        var keys = _dereq_(\"./keys\"),\n            hasBinary = _dereq_(\"has-binary\"),\n            sliceBuffer = _dereq_(\"arraybuffer.slice\"),\n            base64encoder = _dereq_(\"base64-arraybuffer\"),\n            after = _dereq_(\"after\"),\n            utf8 = _dereq_(\"utf8\"),\n            isAndroid = navigator.userAgent.match(/Android/i),\n            isPhantomJS = /PhantomJS/i.test(navigator.userAgent),\n            dontSendBlobs = isAndroid || isPhantomJS;\n\n        exports.protocol = 3;\n\n        var packets = exports.packets = {\n          open: 0,\n          close: 1,\n          ping: 2,\n          pong: 3,\n          message: 4,\n          upgrade: 5,\n          noop: 6\n        },\n            packetslist = keys(packets),\n            err = {\n          type: \"error\",\n          data: \"parser error\"\n        },\n            Blob = _dereq_(\"blob\");\n\n        exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\n          \"function\" == typeof supportsBinary && (callback = supportsBinary, supportsBinary = !1), \"function\" == typeof utf8encode && (callback = utf8encode, utf8encode = null);\n          var data = void 0 === packet.data ? void 0 : packet.data.buffer || packet.data;\n          if (global.ArrayBuffer && data instanceof ArrayBuffer) return encodeArrayBuffer(packet, supportsBinary, callback);\n          if (Blob && data instanceof global.Blob) return encodeBlob(packet, supportsBinary, callback);\n          if (data && data.base64) return encodeBase64Object(packet, callback);\n          var encoded = packets[packet.type];\n          return void 0 !== packet.data && (encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data)), callback(\"\" + encoded);\n        }, exports.encodeBase64Packet = function (packet, callback) {\n          var message = \"b\" + exports.packets[packet.type];\n\n          if (Blob && packet.data instanceof global.Blob) {\n            var fr = new FileReader();\n            return fr.onload = function () {\n              var b64 = fr.result.split(\",\")[1];\n              callback(message + b64);\n            }, fr.readAsDataURL(packet.data);\n          }\n\n          var b64data;\n\n          try {\n            b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));\n          } catch (e) {\n            for (var typed = new Uint8Array(packet.data), basic = new Array(typed.length), i = 0; i < typed.length; i++) {\n              basic[i] = typed[i];\n            }\n\n            b64data = String.fromCharCode.apply(null, basic);\n          }\n\n          return message += global.btoa(b64data), callback(message);\n        }, exports.decodePacket = function (data, binaryType, utf8decode) {\n          if (\"string\" == typeof data || void 0 === data) {\n            if (\"b\" == data.charAt(0)) return exports.decodeBase64Packet(data.substr(1), binaryType);\n            if (utf8decode) try {\n              data = utf8.decode(data);\n            } catch (e) {\n              return err;\n            }\n            var type = data.charAt(0);\n            return Number(type) == type && packetslist[type] ? data.length > 1 ? {\n              type: packetslist[type],\n              data: data.substring(1)\n            } : {\n              type: packetslist[type]\n            } : err;\n          }\n\n          var asArray = new Uint8Array(data),\n              type = asArray[0],\n              rest = sliceBuffer(data, 1);\n          return Blob && \"blob\" === binaryType && (rest = new Blob([rest])), {\n            type: packetslist[type],\n            data: rest\n          };\n        }, exports.decodeBase64Packet = function (msg, binaryType) {\n          var type = packetslist[msg.charAt(0)];\n          if (!global.ArrayBuffer) return {\n            type: type,\n            data: {\n              base64: !0,\n              data: msg.substr(1)\n            }\n          };\n          var data = base64encoder.decode(msg.substr(1));\n          return \"blob\" === binaryType && Blob && (data = new Blob([data])), {\n            type: type,\n            data: data\n          };\n        }, exports.encodePayload = function (packets, supportsBinary, callback) {\n          function setLengthHeader(message) {\n            return message.length + \":\" + message;\n          }\n\n          function encodeOne(packet, doneCallback) {\n            exports.encodePacket(packet, !!isBinary && supportsBinary, !0, function (message) {\n              doneCallback(null, setLengthHeader(message));\n            });\n          }\n\n          \"function\" == typeof supportsBinary && (callback = supportsBinary, supportsBinary = null);\n          var isBinary = hasBinary(packets);\n          return supportsBinary && isBinary ? Blob && !dontSendBlobs ? exports.encodePayloadAsBlob(packets, callback) : exports.encodePayloadAsArrayBuffer(packets, callback) : packets.length ? void map(packets, encodeOne, function (err, results) {\n            return callback(results.join(\"\"));\n          }) : callback(\"0:\");\n        }, exports.decodePayload = function (data, binaryType, callback) {\n          if (\"string\" != typeof data) return exports.decodePayloadAsBinary(data, binaryType, callback);\n          \"function\" == typeof binaryType && (callback = binaryType, binaryType = null);\n          var packet;\n          if (\"\" == data) return callback(err, 0, 1);\n\n          for (var n, msg, length = \"\", i = 0, l = data.length; i < l; i++) {\n            var chr = data.charAt(i);\n            if (\":\" != chr) length += chr;else {\n              if (\"\" == length || length != (n = Number(length))) return callback(err, 0, 1);\n              if (msg = data.substr(i + 1, n), length != msg.length) return callback(err, 0, 1);\n\n              if (msg.length) {\n                if (packet = exports.decodePacket(msg, binaryType, !0), err.type == packet.type && err.data == packet.data) return callback(err, 0, 1);\n                if (!1 === callback(packet, i + n, l)) return;\n              }\n\n              i += n, length = \"\";\n            }\n          }\n\n          return \"\" != length ? callback(err, 0, 1) : void 0;\n        }, exports.encodePayloadAsArrayBuffer = function (packets, callback) {\n          function encodeOne(packet, doneCallback) {\n            exports.encodePacket(packet, !0, !0, function (data) {\n              return doneCallback(null, data);\n            });\n          }\n\n          if (!packets.length) return callback(new ArrayBuffer(0));\n          map(packets, encodeOne, function (err, encodedPackets) {\n            var totalLength = encodedPackets.reduce(function (acc, p) {\n              var len;\n              return len = \"string\" == typeof p ? p.length : p.byteLength, acc + len.toString().length + len + 2;\n            }, 0),\n                resultArray = new Uint8Array(totalLength),\n                bufferIndex = 0;\n            return encodedPackets.forEach(function (p) {\n              var isString = \"string\" == typeof p,\n                  ab = p;\n\n              if (isString) {\n                for (var view = new Uint8Array(p.length), i = 0; i < p.length; i++) {\n                  view[i] = p.charCodeAt(i);\n                }\n\n                ab = view.buffer;\n              }\n\n              resultArray[bufferIndex++] = isString ? 0 : 1;\n\n              for (var lenStr = ab.byteLength.toString(), i = 0; i < lenStr.length; i++) {\n                resultArray[bufferIndex++] = parseInt(lenStr[i]);\n              }\n\n              resultArray[bufferIndex++] = 255;\n\n              for (var view = new Uint8Array(ab), i = 0; i < view.length; i++) {\n                resultArray[bufferIndex++] = view[i];\n              }\n            }), callback(resultArray.buffer);\n          });\n        }, exports.encodePayloadAsBlob = function (packets, callback) {\n          function encodeOne(packet, doneCallback) {\n            exports.encodePacket(packet, !0, !0, function (encoded) {\n              var binaryIdentifier = new Uint8Array(1);\n\n              if (binaryIdentifier[0] = 1, \"string\" == typeof encoded) {\n                for (var view = new Uint8Array(encoded.length), i = 0; i < encoded.length; i++) {\n                  view[i] = encoded.charCodeAt(i);\n                }\n\n                encoded = view.buffer, binaryIdentifier[0] = 0;\n              }\n\n              for (var len = encoded instanceof ArrayBuffer ? encoded.byteLength : encoded.size, lenStr = len.toString(), lengthAry = new Uint8Array(lenStr.length + 1), i = 0; i < lenStr.length; i++) {\n                lengthAry[i] = parseInt(lenStr[i]);\n              }\n\n              if (lengthAry[lenStr.length] = 255, Blob) {\n                var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);\n                doneCallback(null, blob);\n              }\n            });\n          }\n\n          map(packets, encodeOne, function (err, results) {\n            return callback(new Blob(results));\n          });\n        }, exports.decodePayloadAsBinary = function (data, binaryType, callback) {\n          \"function\" == typeof binaryType && (callback = binaryType, binaryType = null);\n\n          for (var bufferTail = data, buffers = [], numberTooLong = !1; bufferTail.byteLength > 0;) {\n            for (var tailArray = new Uint8Array(bufferTail), isString = 0 === tailArray[0], msgLength = \"\", i = 1; 255 != tailArray[i]; i++) {\n              if (msgLength.length > 310) {\n                numberTooLong = !0;\n                break;\n              }\n\n              msgLength += tailArray[i];\n            }\n\n            if (numberTooLong) return callback(err, 0, 1);\n            bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length), msgLength = parseInt(msgLength);\n            var msg = sliceBuffer(bufferTail, 0, msgLength);\n            if (isString) try {\n              msg = String.fromCharCode.apply(null, new Uint8Array(msg));\n            } catch (e) {\n              var typed = new Uint8Array(msg);\n              msg = \"\";\n\n              for (var i = 0; i < typed.length; i++) {\n                msg += String.fromCharCode(typed[i]);\n              }\n            }\n            buffers.push(msg), bufferTail = sliceBuffer(bufferTail, msgLength);\n          }\n\n          var total = buffers.length;\n          buffers.forEach(function (buffer, i) {\n            callback(exports.decodePacket(buffer, binaryType, !0), i, total);\n          });\n        };\n      }).call(this, \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : {});\n    }, {\n      \"./keys\": 28,\n      after: 6,\n      \"arraybuffer.slice\": 7,\n      \"base64-arraybuffer\": 9,\n      blob: 10,\n      \"has-binary\": 29,\n      utf8: 44\n    }],\n    28: [function (_dereq_, module, exports) {\n      module.exports = Object.keys || function (obj) {\n        var arr = [],\n            has = Object.prototype.hasOwnProperty;\n\n        for (var i in obj) {\n          has.call(obj, i) && arr.push(i);\n        }\n\n        return arr;\n      };\n    }, {}],\n    29: [function (_dereq_, module, exports) {\n      (function (global) {\n        function hasBinary(data) {\n          function _hasBinary(obj) {\n            if (!obj) return !1;\n            if (global.Buffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer || global.Blob && obj instanceof Blob || global.File && obj instanceof File) return !0;\n\n            if (isArray(obj)) {\n              for (var i = 0; i < obj.length; i++) {\n                if (_hasBinary(obj[i])) return !0;\n              }\n            } else if (obj && \"object\" == typeof obj) {\n              obj.toJSON && (obj = obj.toJSON());\n\n              for (var key in obj) {\n                if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) return !0;\n              }\n            }\n\n            return !1;\n          }\n\n          return _hasBinary(data);\n        }\n\n        var isArray = _dereq_(\"isarray\");\n\n        module.exports = hasBinary;\n      }).call(this, \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : {});\n    }, {\n      isarray: 33\n    }],\n    30: [function (_dereq_, module, exports) {\n      (function (global) {\n        function hasBinary(data) {\n          function _hasBinary(obj) {\n            if (!obj) return !1;\n            if (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer || global.Blob && obj instanceof Blob || global.File && obj instanceof File) return !0;\n\n            if (isArray(obj)) {\n              for (var i = 0; i < obj.length; i++) {\n                if (_hasBinary(obj[i])) return !0;\n              }\n            } else if (obj && \"object\" == typeof obj) {\n              obj.toJSON && \"function\" == typeof obj.toJSON && (obj = obj.toJSON());\n\n              for (var key in obj) {\n                if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) return !0;\n              }\n            }\n\n            return !1;\n          }\n\n          return _hasBinary(data);\n        }\n\n        var isArray = _dereq_(\"isarray\");\n\n        module.exports = hasBinary;\n      }).call(this, \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : {});\n    }, {\n      isarray: 33\n    }],\n    31: [function (_dereq_, module, exports) {\n      try {\n        module.exports = \"undefined\" != typeof XMLHttpRequest && \"withCredentials\" in new XMLHttpRequest();\n      } catch (err) {\n        module.exports = !1;\n      }\n    }, {}],\n    32: [function (_dereq_, module, exports) {\n      var indexOf = [].indexOf;\n\n      module.exports = function (arr, obj) {\n        if (indexOf) return arr.indexOf(obj);\n\n        for (var i = 0; i < arr.length; ++i) {\n          if (arr[i] === obj) return i;\n        }\n\n        return -1;\n      };\n    }, {}],\n    33: [function (_dereq_, module, exports) {\n      module.exports = Array.isArray || function (arr) {\n        return \"[object Array]\" == Object.prototype.toString.call(arr);\n      };\n    }, {}],\n    34: [function (_dereq_, module, exports) {\n      (function (global) {\n        (function () {\n          function runInContext(context, exports) {\n            function has(name) {\n              if (has[name] !== undef) return has[name];\n              var isSupported;\n              if (\"bug-string-char-index\" == name) isSupported = \"a\" != \"a\"[0];else if (\"json\" == name) isSupported = has(\"json-stringify\") && has(\"json-parse\");else {\n                var value,\n                    serialized = \"{\\\"a\\\":[1,true,false,null,\\\"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t\\\"]}\";\n\n                if (\"json-stringify\" == name) {\n                  var stringify = exports.stringify,\n                      stringifySupported = \"function\" == typeof stringify && isExtended;\n\n                  if (stringifySupported) {\n                    (value = function value() {\n                      return 1;\n                    }).toJSON = value;\n\n                    try {\n                      stringifySupported = \"0\" === stringify(0) && \"0\" === stringify(new Number()) && '\"\"' == stringify(new String()) && stringify(getClass) === undef && stringify(undef) === undef && stringify() === undef && \"1\" === stringify(value) && \"[1]\" == stringify([value]) && \"[null]\" == stringify([undef]) && \"null\" == stringify(null) && \"[null,null,null]\" == stringify([undef, getClass, null]) && stringify({\n                        a: [value, !0, !1, null, \"\\0\\b\\n\\f\\r\\t\"]\n                      }) == serialized && \"1\" === stringify(null, value) && \"[\\n 1,\\n 2\\n]\" == stringify([1, 2], null, 1) && '\"-271821-04-20T00:00:00.000Z\"' == stringify(new Date(-864e13)) && '\"+275760-09-13T00:00:00.000Z\"' == stringify(new Date(864e13)) && '\"-000001-01-01T00:00:00.000Z\"' == stringify(new Date(-621987552e5)) && '\"1969-12-31T23:59:59.999Z\"' == stringify(new Date(-1));\n                    } catch (exception) {\n                      stringifySupported = !1;\n                    }\n                  }\n\n                  isSupported = stringifySupported;\n                }\n\n                if (\"json-parse\" == name) {\n                  var parse = exports.parse;\n                  if (\"function\" == typeof parse) try {\n                    if (0 === parse(\"0\") && !parse(!1)) {\n                      value = parse(serialized);\n                      var parseSupported = 5 == value.a.length && 1 === value.a[0];\n\n                      if (parseSupported) {\n                        try {\n                          parseSupported = !parse('\"\\t\"');\n                        } catch (exception) {}\n\n                        if (parseSupported) try {\n                          parseSupported = 1 !== parse(\"01\");\n                        } catch (exception) {}\n                        if (parseSupported) try {\n                          parseSupported = 1 !== parse(\"1.\");\n                        } catch (exception) {}\n                      }\n                    }\n                  } catch (exception) {\n                    parseSupported = !1;\n                  }\n                  isSupported = parseSupported;\n                }\n              }\n              return has[name] = !!isSupported;\n            }\n\n            context || (context = root.Object()), exports || (exports = root.Object());\n            var Number = context.Number || root.Number,\n                String = context.String || root.String,\n                Object = context.Object || root.Object,\n                Date = context.Date || root.Date,\n                SyntaxError = context.SyntaxError || root.SyntaxError,\n                TypeError = context.TypeError || root.TypeError,\n                Math = context.Math || root.Math,\n                nativeJSON = context.JSON || root.JSON;\n            \"object\" == typeof nativeJSON && nativeJSON && (exports.stringify = nativeJSON.stringify, exports.parse = nativeJSON.parse);\n\n            var _isProperty,\n                _forEach,\n                undef,\n                objectProto = Object.prototype,\n                getClass = objectProto.toString,\n                isExtended = new Date(-0xc782b5b800cec);\n\n            try {\n              isExtended = -109252 == isExtended.getUTCFullYear() && 0 === isExtended.getUTCMonth() && 1 === isExtended.getUTCDate() && 10 == isExtended.getUTCHours() && 37 == isExtended.getUTCMinutes() && 6 == isExtended.getUTCSeconds() && 708 == isExtended.getUTCMilliseconds();\n            } catch (exception) {}\n\n            if (!has(\"json\")) {\n              var functionClass = \"[object Function]\",\n                  dateClass = \"[object Date]\",\n                  numberClass = \"[object Number]\",\n                  stringClass = \"[object String]\",\n                  arrayClass = \"[object Array]\",\n                  booleanClass = \"[object Boolean]\",\n                  charIndexBuggy = has(\"bug-string-char-index\");\n              if (!isExtended) var floor = Math.floor,\n                  Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],\n                  getDay = function getDay(year, month) {\n                return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\n              };\n\n              if ((_isProperty = objectProto.hasOwnProperty) || (_isProperty = function isProperty(property) {\n                var constructor,\n                    members = {};\n                return (members.__proto__ = null, members.__proto__ = {\n                  toString: 1\n                }, members).toString != getClass ? _isProperty = function isProperty(property) {\n                  var original = this.__proto__,\n                      result = property in (this.__proto__ = null, this);\n                  return this.__proto__ = original, result;\n                } : (constructor = members.constructor, _isProperty = function isProperty(property) {\n                  var parent = (this.constructor || constructor).prototype;\n                  return property in this && !(property in parent && this[property] === parent[property]);\n                }), members = null, _isProperty.call(this, property);\n              }), _forEach = function forEach(object, callback) {\n                var Properties,\n                    members,\n                    property,\n                    size = 0;\n                (Properties = function Properties() {\n                  this.valueOf = 0;\n                }).prototype.valueOf = 0, members = new Properties();\n\n                for (property in members) {\n                  _isProperty.call(members, property) && size++;\n                }\n\n                return Properties = members = null, size ? _forEach = 2 == size ? function (object, callback) {\n                  var property,\n                      members = {},\n                      isFunction = getClass.call(object) == functionClass;\n\n                  for (property in object) {\n                    isFunction && \"prototype\" == property || _isProperty.call(members, property) || !(members[property] = 1) || !_isProperty.call(object, property) || callback(property);\n                  }\n                } : function (object, callback) {\n                  var property,\n                      isConstructor,\n                      isFunction = getClass.call(object) == functionClass;\n\n                  for (property in object) {\n                    isFunction && \"prototype\" == property || !_isProperty.call(object, property) || (isConstructor = \"constructor\" === property) || callback(property);\n                  }\n\n                  (isConstructor || _isProperty.call(object, property = \"constructor\")) && callback(property);\n                } : (members = [\"valueOf\", \"toString\", \"toLocaleString\", \"propertyIsEnumerable\", \"isPrototypeOf\", \"hasOwnProperty\", \"constructor\"], _forEach = function forEach(object, callback) {\n                  var property,\n                      length,\n                      isFunction = getClass.call(object) == functionClass,\n                      hasProperty = !isFunction && \"function\" != typeof object.constructor && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || _isProperty;\n\n                  for (property in object) {\n                    isFunction && \"prototype\" == property || !hasProperty.call(object, property) || callback(property);\n                  }\n\n                  for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property)) {\n                    ;\n                  }\n                }), _forEach(object, callback);\n              }, !has(\"json-stringify\")) {\n                var Escapes = {\n                  92: \"\\\\\\\\\",\n                  34: '\\\\\"',\n                  8: \"\\\\b\",\n                  12: \"\\\\f\",\n                  10: \"\\\\n\",\n                  13: \"\\\\r\",\n                  9: \"\\\\t\"\n                },\n                    leadingZeroes = \"000000\",\n                    toPaddedString = function toPaddedString(width, value) {\n                  return (leadingZeroes + (value || 0)).slice(-width);\n                },\n                    unicodePrefix = \"\\\\u00\",\n                    quote = function quote(value) {\n                  for (var result = '\"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10, symbols = useCharIndex && (charIndexBuggy ? value.split(\"\") : value); index < length; index++) {\n                    var charCode = value.charCodeAt(index);\n\n                    switch (charCode) {\n                      case 8:\n                      case 9:\n                      case 10:\n                      case 12:\n                      case 13:\n                      case 34:\n                      case 92:\n                        result += Escapes[charCode];\n                        break;\n\n                      default:\n                        if (charCode < 32) {\n                          result += unicodePrefix + toPaddedString(2, charCode.toString(16));\n                          break;\n                        }\n\n                        result += useCharIndex ? symbols[index] : value.charAt(index);\n                    }\n                  }\n\n                  return result + '\"';\n                },\n                    serialize = function serialize(property, object, callback, properties, whitespace, indentation, stack) {\n                  var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\n\n                  try {\n                    value = object[property];\n                  } catch (exception) {}\n\n                  if (\"object\" == typeof value && value) if ((className = getClass.call(value)) != dateClass || _isProperty.call(value, \"toJSON\")) \"function\" == typeof value.toJSON && (className != numberClass && className != stringClass && className != arrayClass || _isProperty.call(value, \"toJSON\")) && (value = value.toJSON(property));else if (value > -1 / 0 && value < 1 / 0) {\n                    if (getDay) {\n                      for (date = floor(value / 864e5), year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++) {\n                        ;\n                      }\n\n                      for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++) {\n                        ;\n                      }\n\n                      date = 1 + date - getDay(year, month), time = (value % 864e5 + 864e5) % 864e5, hours = floor(time / 36e5) % 24, minutes = floor(time / 6e4) % 60, seconds = floor(time / 1e3) % 60, milliseconds = time % 1e3;\n                    } else year = value.getUTCFullYear(), month = value.getUTCMonth(), date = value.getUTCDate(), hours = value.getUTCHours(), minutes = value.getUTCMinutes(), seconds = value.getUTCSeconds(), milliseconds = value.getUTCMilliseconds();\n\n                    value = (year <= 0 || year >= 1e4 ? (year < 0 ? \"-\" : \"+\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + \"-\" + toPaddedString(2, month + 1) + \"-\" + toPaddedString(2, date) + \"T\" + toPaddedString(2, hours) + \":\" + toPaddedString(2, minutes) + \":\" + toPaddedString(2, seconds) + \".\" + toPaddedString(3, milliseconds) + \"Z\";\n                  } else value = null;\n                  if (callback && (value = callback.call(object, property, value)), null === value) return \"null\";\n                  if ((className = getClass.call(value)) == booleanClass) return \"\" + value;\n                  if (className == numberClass) return value > -1 / 0 && value < 1 / 0 ? \"\" + value : \"null\";\n                  if (className == stringClass) return quote(\"\" + value);\n\n                  if (\"object\" == typeof value) {\n                    for (length = stack.length; length--;) {\n                      if (stack[length] === value) throw TypeError();\n                    }\n\n                    if (stack.push(value), results = [], prefix = indentation, indentation += whitespace, className == arrayClass) {\n                      for (index = 0, length = value.length; index < length; index++) {\n                        element = serialize(index, value, callback, properties, whitespace, indentation, stack), results.push(element === undef ? \"null\" : element);\n                      }\n\n                      result = results.length ? whitespace ? \"[\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"]\" : \"[\" + results.join(\",\") + \"]\" : \"[]\";\n                    } else _forEach(properties || value, function (property) {\n                      var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\n                      element !== undef && results.push(quote(property) + \":\" + (whitespace ? \" \" : \"\") + element);\n                    }), result = results.length ? whitespace ? \"{\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"}\" : \"{\" + results.join(\",\") + \"}\" : \"{}\";\n\n                    return stack.pop(), result;\n                  }\n                };\n\n                exports.stringify = function (source, filter, width) {\n                  var whitespace, callback, properties, className;\n                  if (objectTypes[typeof filter] && filter) if ((className = getClass.call(filter)) == functionClass) callback = filter;else if (className == arrayClass) {\n                    properties = {};\n\n                    for (var value, index = 0, length = filter.length; index < length; value = filter[index++], ((className = getClass.call(value)) == stringClass || className == numberClass) && (properties[value] = 1)) {\n                      ;\n                    }\n                  }\n                  if (width) if ((className = getClass.call(width)) == numberClass) {\n                    if ((width -= width % 1) > 0) for (whitespace = \"\", width > 10 && (width = 10); whitespace.length < width; whitespace += \" \") {\n                      ;\n                    }\n                  } else className == stringClass && (whitespace = width.length <= 10 ? width : width.slice(0, 10));\n                  return serialize(\"\", (value = {}, value[\"\"] = source, value), callback, properties, whitespace, \"\", []);\n                };\n              }\n\n              if (!has(\"json-parse\")) {\n                var Index,\n                    Source,\n                    fromCharCode = String.fromCharCode,\n                    Unescapes = {\n                  92: \"\\\\\",\n                  34: '\"',\n                  47: \"/\",\n                  98: \"\\b\",\n                  116: \"\\t\",\n                  110: \"\\n\",\n                  102: \"\\f\",\n                  114: \"\\r\"\n                },\n                    abort = function abort() {\n                  throw Index = Source = null, SyntaxError();\n                },\n                    lex = function lex() {\n                  for (var value, begin, position, isSigned, charCode, source = Source, length = source.length; Index < length;) {\n                    switch (charCode = source.charCodeAt(Index)) {\n                      case 9:\n                      case 10:\n                      case 13:\n                      case 32:\n                        Index++;\n                        break;\n\n                      case 123:\n                      case 125:\n                      case 91:\n                      case 93:\n                      case 58:\n                      case 44:\n                        return value = charIndexBuggy ? source.charAt(Index) : source[Index], Index++, value;\n\n                      case 34:\n                        for (value = \"@\", Index++; Index < length;) {\n                          if ((charCode = source.charCodeAt(Index)) < 32) abort();else if (92 == charCode) switch (charCode = source.charCodeAt(++Index)) {\n                            case 92:\n                            case 34:\n                            case 47:\n                            case 98:\n                            case 116:\n                            case 110:\n                            case 102:\n                            case 114:\n                              value += Unescapes[charCode], Index++;\n                              break;\n\n                            case 117:\n                              for (begin = ++Index, position = Index + 4; Index < position; Index++) {\n                                (charCode = source.charCodeAt(Index)) >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70 || abort();\n                              }\n\n                              value += fromCharCode(\"0x\" + source.slice(begin, Index));\n                              break;\n\n                            default:\n                              abort();\n                          } else {\n                            if (34 == charCode) break;\n\n                            for (charCode = source.charCodeAt(Index), begin = Index; charCode >= 32 && 92 != charCode && 34 != charCode;) {\n                              charCode = source.charCodeAt(++Index);\n                            }\n\n                            value += source.slice(begin, Index);\n                          }\n                        }\n\n                        if (34 == source.charCodeAt(Index)) return Index++, value;\n                        abort();\n\n                      default:\n                        if (begin = Index, 45 == charCode && (isSigned = !0, charCode = source.charCodeAt(++Index)), charCode >= 48 && charCode <= 57) {\n                          for (48 == charCode && (charCode = source.charCodeAt(Index + 1)) >= 48 && charCode <= 57 && abort(), isSigned = !1; Index < length && (charCode = source.charCodeAt(Index)) >= 48 && charCode <= 57; Index++) {\n                            ;\n                          }\n\n                          if (46 == source.charCodeAt(Index)) {\n                            for (position = ++Index; position < length && (charCode = source.charCodeAt(position)) >= 48 && charCode <= 57; position++) {\n                              ;\n                            }\n\n                            position == Index && abort(), Index = position;\n                          }\n\n                          if (101 == (charCode = source.charCodeAt(Index)) || 69 == charCode) {\n                            for (charCode = source.charCodeAt(++Index), 43 != charCode && 45 != charCode || Index++, position = Index; position < length && (charCode = source.charCodeAt(position)) >= 48 && charCode <= 57; position++) {\n                              ;\n                            }\n\n                            position == Index && abort(), Index = position;\n                          }\n\n                          return +source.slice(begin, Index);\n                        }\n\n                        if (isSigned && abort(), \"true\" == source.slice(Index, Index + 4)) return Index += 4, !0;\n                        if (\"false\" == source.slice(Index, Index + 5)) return Index += 5, !1;\n                        if (\"null\" == source.slice(Index, Index + 4)) return Index += 4, null;\n                        abort();\n                    }\n                  }\n\n                  return \"$\";\n                },\n                    get = function get(value) {\n                  var results, hasMembers;\n\n                  if (\"$\" == value && abort(), \"string\" == typeof value) {\n                    if (\"@\" == (charIndexBuggy ? value.charAt(0) : value[0])) return value.slice(1);\n\n                    if (\"[\" == value) {\n                      for (results = []; \"]\" != (value = lex()); hasMembers || (hasMembers = !0)) {\n                        hasMembers && (\",\" == value ? \"]\" == (value = lex()) && abort() : abort()), \",\" == value && abort(), results.push(get(value));\n                      }\n\n                      return results;\n                    }\n\n                    if (\"{\" == value) {\n                      for (results = {}; \"}\" != (value = lex()); hasMembers || (hasMembers = !0)) {\n                        hasMembers && (\",\" == value ? \"}\" == (value = lex()) && abort() : abort()), \",\" != value && \"string\" == typeof value && \"@\" == (charIndexBuggy ? value.charAt(0) : value[0]) && \":\" == lex() || abort(), results[value.slice(1)] = get(lex());\n                      }\n\n                      return results;\n                    }\n\n                    abort();\n                  }\n\n                  return value;\n                },\n                    update = function update(source, property, callback) {\n                  var element = walk(source, property, callback);\n                  element === undef ? delete source[property] : source[property] = element;\n                },\n                    walk = function walk(source, property, callback) {\n                  var length,\n                      value = source[property];\n                  if (\"object\" == typeof value && value) if (getClass.call(value) == arrayClass) for (length = value.length; length--;) {\n                    update(value, length, callback);\n                  } else _forEach(value, function (property) {\n                    update(value, property, callback);\n                  });\n                  return callback.call(source, property, value);\n                };\n\n                exports.parse = function (source, callback) {\n                  var result, value;\n                  return Index = 0, Source = \"\" + source, result = get(lex()), \"$\" != lex() && abort(), Index = Source = null, callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\"\"] = result, value), \"\", callback) : result;\n                };\n              }\n            }\n\n            return exports.runInContext = runInContext, exports;\n          }\n\n          var isLoader = \"function\" == typeof define && define.amd,\n              objectTypes = {\n            function: !0,\n            object: !0\n          },\n              freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,\n              root = objectTypes[typeof window] && window || this,\n              freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && \"object\" == typeof global && global;\n          if (!freeGlobal || freeGlobal.global !== freeGlobal && freeGlobal.window !== freeGlobal && freeGlobal.self !== freeGlobal || (root = freeGlobal), freeExports && !isLoader) runInContext(root, freeExports);else {\n            var nativeJSON = root.JSON,\n                previousJSON = root.JSON3,\n                isRestored = !1,\n                JSON3 = runInContext(root, root.JSON3 = {\n              noConflict: function noConflict() {\n                return isRestored || (isRestored = !0, root.JSON = nativeJSON, root.JSON3 = previousJSON, nativeJSON = previousJSON = null), JSON3;\n              }\n            });\n            root.JSON = {\n              parse: JSON3.parse,\n              stringify: JSON3.stringify\n            };\n          }\n          isLoader && define(function () {\n            return JSON3;\n          });\n        }).call(this);\n      }).call(this, \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : {});\n    }, {}],\n    35: [function (_dereq_, module, exports) {\n      function parse(str) {\n        if (str = \"\" + str, !(str.length > 1e4)) {\n          var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n\n          if (match) {\n            var n = parseFloat(match[1]);\n\n            switch ((match[2] || \"ms\").toLowerCase()) {\n              case \"years\":\n              case \"year\":\n              case \"yrs\":\n              case \"yr\":\n              case \"y\":\n                return n * y;\n\n              case \"days\":\n              case \"day\":\n              case \"d\":\n                return n * d;\n\n              case \"hours\":\n              case \"hour\":\n              case \"hrs\":\n              case \"hr\":\n              case \"h\":\n                return n * h;\n\n              case \"minutes\":\n              case \"minute\":\n              case \"mins\":\n              case \"min\":\n              case \"m\":\n                return n * m;\n\n              case \"seconds\":\n              case \"second\":\n              case \"secs\":\n              case \"sec\":\n              case \"s\":\n                return n * s;\n\n              case \"milliseconds\":\n              case \"millisecond\":\n              case \"msecs\":\n              case \"msec\":\n              case \"ms\":\n                return n;\n            }\n          }\n        }\n      }\n\n      function short(ms) {\n        return ms >= d ? Math.round(ms / d) + \"d\" : ms >= h ? Math.round(ms / h) + \"h\" : ms >= m ? Math.round(ms / m) + \"m\" : ms >= s ? Math.round(ms / s) + \"s\" : ms + \"ms\";\n      }\n\n      function long(ms) {\n        return plural(ms, d, \"day\") || plural(ms, h, \"hour\") || plural(ms, m, \"minute\") || plural(ms, s, \"second\") || ms + \" ms\";\n      }\n\n      function plural(ms, n, name) {\n        if (!(ms < n)) return ms < 1.5 * n ? Math.floor(ms / n) + \" \" + name : Math.ceil(ms / n) + \" \" + name + \"s\";\n      }\n\n      var s = 1e3,\n          m = 60 * s,\n          h = 60 * m,\n          d = 24 * h,\n          y = 365.25 * d;\n\n      module.exports = function (val, options) {\n        return options = options || {}, \"string\" == typeof val ? parse(val) : options.long ? long(val) : short(val);\n      };\n    }, {}],\n    36: [function (_dereq_, module, exports) {\n      (function (global) {\n        var rvalidchars = /^[\\],:{}\\s]*$/,\n            rvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,\n            rvalidtokens = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,\n            rvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g,\n            rtrimLeft = /^\\s+/,\n            rtrimRight = /\\s+$/;\n\n        module.exports = function (data) {\n          return \"string\" == typeof data && data ? (data = data.replace(rtrimLeft, \"\").replace(rtrimRight, \"\"), global.JSON && JSON.parse ? JSON.parse(data) : rvalidchars.test(data.replace(rvalidescape, \"@\").replace(rvalidtokens, \"]\").replace(rvalidbraces, \"\")) ? new Function(\"return \" + data)() : void 0) : null;\n        };\n      }).call(this, \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : {});\n    }, {}],\n    37: [function (_dereq_, module, exports) {\n      exports.encode = function (obj) {\n        var str = \"\";\n\n        for (var i in obj) {\n          obj.hasOwnProperty(i) && (str.length && (str += \"&\"), str += encodeURIComponent(i) + \"=\" + encodeURIComponent(obj[i]));\n        }\n\n        return str;\n      }, exports.decode = function (qs) {\n        for (var qry = {}, pairs = qs.split(\"&\"), i = 0, l = pairs.length; i < l; i++) {\n          var pair = pairs[i].split(\"=\");\n          qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n        }\n\n        return qry;\n      };\n    }, {}],\n    38: [function (_dereq_, module, exports) {\n      var re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n          parts = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\", \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\n\n      module.exports = function (str) {\n        var src = str,\n            b = str.indexOf(\"[\"),\n            e = str.indexOf(\"]\");\n        -1 != b && -1 != e && (str = str.substring(0, b) + str.substring(b, e).replace(/:/g, \";\") + str.substring(e, str.length));\n\n        for (var m = re.exec(str || \"\"), uri = {}, i = 14; i--;) {\n          uri[parts[i]] = m[i] || \"\";\n        }\n\n        return -1 != b && -1 != e && (uri.source = src, uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, \":\"), uri.authority = uri.authority.replace(\"[\", \"\").replace(\"]\", \"\").replace(/;/g, \":\"), uri.ipv6uri = !0), uri;\n      };\n    }, {}],\n    39: [function (_dereq_, module, exports) {\n      (function (global) {\n        var isArray = _dereq_(\"isarray\"),\n            isBuf = _dereq_(\"./is-buffer\");\n\n        exports.deconstructPacket = function (packet) {\n          function _deconstructPacket(data) {\n            if (!data) return data;\n\n            if (isBuf(data)) {\n              var placeholder = {\n                _placeholder: !0,\n                num: buffers.length\n              };\n              return buffers.push(data), placeholder;\n            }\n\n            if (isArray(data)) {\n              for (var newData = new Array(data.length), i = 0; i < data.length; i++) {\n                newData[i] = _deconstructPacket(data[i]);\n              }\n\n              return newData;\n            }\n\n            if (\"object\" == typeof data && !(data instanceof Date)) {\n              var newData = {};\n\n              for (var key in data) {\n                newData[key] = _deconstructPacket(data[key]);\n              }\n\n              return newData;\n            }\n\n            return data;\n          }\n\n          var buffers = [],\n              packetData = packet.data,\n              pack = packet;\n          return pack.data = _deconstructPacket(packetData), pack.attachments = buffers.length, {\n            packet: pack,\n            buffers: buffers\n          };\n        }, exports.reconstructPacket = function (packet, buffers) {\n          function _reconstructPacket(data) {\n            if (data && data._placeholder) {\n              return buffers[data.num];\n            }\n\n            if (isArray(data)) {\n              for (var i = 0; i < data.length; i++) {\n                data[i] = _reconstructPacket(data[i]);\n              }\n\n              return data;\n            }\n\n            if (data && \"object\" == typeof data) {\n              for (var key in data) {\n                data[key] = _reconstructPacket(data[key]);\n              }\n\n              return data;\n            }\n\n            return data;\n          }\n\n          return packet.data = _reconstructPacket(packet.data), packet.attachments = void 0, packet;\n        }, exports.removeBlobs = function (data, callback) {\n          function _removeBlobs(obj, curKey, containingObject) {\n            if (!obj) return obj;\n\n            if (global.Blob && obj instanceof Blob || global.File && obj instanceof File) {\n              pendingBlobs++;\n              var fileReader = new FileReader();\n              fileReader.onload = function () {\n                containingObject ? containingObject[curKey] = this.result : bloblessData = this.result, --pendingBlobs || callback(bloblessData);\n              }, fileReader.readAsArrayBuffer(obj);\n            } else if (isArray(obj)) for (var i = 0; i < obj.length; i++) {\n              _removeBlobs(obj[i], i, obj);\n            } else if (obj && \"object\" == typeof obj && !isBuf(obj)) for (var key in obj) {\n              _removeBlobs(obj[key], key, obj);\n            }\n          }\n\n          var pendingBlobs = 0,\n              bloblessData = data;\n          _removeBlobs(bloblessData), pendingBlobs || callback(bloblessData);\n        };\n      }).call(this, \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : {});\n    }, {\n      \"./is-buffer\": 41,\n      isarray: 33\n    }],\n    40: [function (_dereq_, module, exports) {\n      function Encoder() {}\n\n      function encodeAsString(obj) {\n        var str = \"\",\n            nsp = !1;\n        return str += obj.type, exports.BINARY_EVENT != obj.type && exports.BINARY_ACK != obj.type || (str += obj.attachments, str += \"-\"), obj.nsp && \"/\" != obj.nsp && (nsp = !0, str += obj.nsp), null != obj.id && (nsp && (str += \",\", nsp = !1), str += obj.id), null != obj.data && (nsp && (str += \",\"), str += json.stringify(obj.data)), debug(\"encoded %j as %s\", obj, str), str;\n      }\n\n      function encodeAsBinary(obj, callback) {\n        function writeEncoding(bloblessData) {\n          var deconstruction = binary.deconstructPacket(bloblessData),\n              pack = encodeAsString(deconstruction.packet),\n              buffers = deconstruction.buffers;\n          buffers.unshift(pack), callback(buffers);\n        }\n\n        binary.removeBlobs(obj, writeEncoding);\n      }\n\n      function Decoder() {\n        this.reconstructor = null;\n      }\n\n      function decodeString(str) {\n        var p = {},\n            i = 0;\n        if (p.type = Number(str.charAt(0)), null == exports.types[p.type]) return error();\n\n        if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {\n          for (var buf = \"\"; \"-\" != str.charAt(++i) && (buf += str.charAt(i), i != str.length);) {\n            ;\n          }\n\n          if (buf != Number(buf) || \"-\" != str.charAt(i)) throw new Error(\"Illegal attachments\");\n          p.attachments = Number(buf);\n        }\n\n        if (\"/\" == str.charAt(i + 1)) for (p.nsp = \"\"; ++i;) {\n          var c = str.charAt(i);\n          if (\",\" == c) break;\n          if (p.nsp += c, i == str.length) break;\n        } else p.nsp = \"/\";\n        var next = str.charAt(i + 1);\n\n        if (\"\" !== next && Number(next) == next) {\n          for (p.id = \"\"; ++i;) {\n            var c = str.charAt(i);\n\n            if (null == c || Number(c) != c) {\n              --i;\n              break;\n            }\n\n            if (p.id += str.charAt(i), i == str.length) break;\n          }\n\n          p.id = Number(p.id);\n        }\n\n        if (str.charAt(++i)) try {\n          p.data = json.parse(str.substr(i));\n        } catch (e) {\n          return error();\n        }\n        return debug(\"decoded %s as %j\", str, p), p;\n      }\n\n      function BinaryReconstructor(packet) {\n        this.reconPack = packet, this.buffers = [];\n      }\n\n      function error(data) {\n        return {\n          type: exports.ERROR,\n          data: \"parser error\"\n        };\n      }\n\n      var debug = _dereq_(\"debug\")(\"socket.io-parser\"),\n          json = _dereq_(\"json3\"),\n          Emitter = (_dereq_(\"isarray\"), _dereq_(\"component-emitter\")),\n          binary = _dereq_(\"./binary\"),\n          isBuf = _dereq_(\"./is-buffer\");\n\n      exports.protocol = 4, exports.types = [\"CONNECT\", \"DISCONNECT\", \"EVENT\", \"ACK\", \"ERROR\", \"BINARY_EVENT\", \"BINARY_ACK\"], exports.CONNECT = 0, exports.DISCONNECT = 1, exports.EVENT = 2, exports.ACK = 3, exports.ERROR = 4, exports.BINARY_EVENT = 5, exports.BINARY_ACK = 6, exports.Encoder = Encoder, exports.Decoder = Decoder, Encoder.prototype.encode = function (obj, callback) {\n        if (debug(\"encoding packet %j\", obj), exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) encodeAsBinary(obj, callback);else {\n          callback([encodeAsString(obj)]);\n        }\n      }, Emitter(Decoder.prototype), Decoder.prototype.add = function (obj) {\n        var packet;\n        if (\"string\" == typeof obj) packet = decodeString(obj), exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type ? (this.reconstructor = new BinaryReconstructor(packet), 0 === this.reconstructor.reconPack.attachments && this.emit(\"decoded\", packet)) : this.emit(\"decoded\", packet);else {\n          if (!isBuf(obj) && !obj.base64) throw new Error(\"Unknown type: \" + obj);\n          if (!this.reconstructor) throw new Error(\"got binary data when not reconstructing a packet\");\n          (packet = this.reconstructor.takeBinaryData(obj)) && (this.reconstructor = null, this.emit(\"decoded\", packet));\n        }\n      }, Decoder.prototype.destroy = function () {\n        this.reconstructor && this.reconstructor.finishedReconstruction();\n      }, BinaryReconstructor.prototype.takeBinaryData = function (binData) {\n        if (this.buffers.push(binData), this.buffers.length == this.reconPack.attachments) {\n          var packet = binary.reconstructPacket(this.reconPack, this.buffers);\n          return this.finishedReconstruction(), packet;\n        }\n\n        return null;\n      }, BinaryReconstructor.prototype.finishedReconstruction = function () {\n        this.reconPack = null, this.buffers = [];\n      };\n    }, {\n      \"./binary\": 39,\n      \"./is-buffer\": 41,\n      \"component-emitter\": 42,\n      debug: 14,\n      isarray: 33,\n      json3: 34\n    }],\n    41: [function (_dereq_, module, exports) {\n      (function (global) {\n        function isBuf(obj) {\n          return global.Buffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer;\n        }\n\n        module.exports = isBuf;\n      }).call(this, \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : {});\n    }, {}],\n    42: [function (_dereq_, module, exports) {\n      arguments[4][26][0].apply(exports, arguments);\n    }, {\n      dup: 26\n    }],\n    43: [function (_dereq_, module, exports) {\n      function toArray(list, index) {\n        var array = [];\n        index = index || 0;\n\n        for (var i = index || 0; i < list.length; i++) {\n          array[i - index] = list[i];\n        }\n\n        return array;\n      }\n\n      module.exports = toArray;\n    }, {}],\n    44: [function (_dereq_, module, exports) {\n      (function (global) {\n        !function (root) {\n          function ucs2decode(string) {\n            for (var value, extra, output = [], counter = 0, length = string.length; counter < length;) {\n              value = string.charCodeAt(counter++), value >= 55296 && value <= 56319 && counter < length ? (extra = string.charCodeAt(counter++), 56320 == (64512 & extra) ? output.push(((1023 & value) << 10) + (1023 & extra) + 65536) : (output.push(value), counter--)) : output.push(value);\n            }\n\n            return output;\n          }\n\n          function ucs2encode(array) {\n            for (var value, length = array.length, index = -1, output = \"\"; ++index < length;) {\n              value = array[index], value > 65535 && (value -= 65536, output += stringFromCharCode(value >>> 10 & 1023 | 55296), value = 56320 | 1023 & value), output += stringFromCharCode(value);\n            }\n\n            return output;\n          }\n\n          function checkScalarValue(codePoint) {\n            if (codePoint >= 55296 && codePoint <= 57343) throw Error(\"Lone surrogate U+\" + codePoint.toString(16).toUpperCase() + \" is not a scalar value\");\n          }\n\n          function createByte(codePoint, shift) {\n            return stringFromCharCode(codePoint >> shift & 63 | 128);\n          }\n\n          function encodeCodePoint(codePoint) {\n            if (0 == (4294967168 & codePoint)) return stringFromCharCode(codePoint);\n            var symbol = \"\";\n            return 0 == (4294965248 & codePoint) ? symbol = stringFromCharCode(codePoint >> 6 & 31 | 192) : 0 == (4294901760 & codePoint) ? (checkScalarValue(codePoint), symbol = stringFromCharCode(codePoint >> 12 & 15 | 224), symbol += createByte(codePoint, 6)) : 0 == (4292870144 & codePoint) && (symbol = stringFromCharCode(codePoint >> 18 & 7 | 240), symbol += createByte(codePoint, 12), symbol += createByte(codePoint, 6)), symbol += stringFromCharCode(63 & codePoint | 128);\n          }\n\n          function utf8encode(string) {\n            for (var codePoint, codePoints = ucs2decode(string), length = codePoints.length, index = -1, byteString = \"\"; ++index < length;) {\n              codePoint = codePoints[index], byteString += encodeCodePoint(codePoint);\n            }\n\n            return byteString;\n          }\n\n          function readContinuationByte() {\n            if (byteIndex >= byteCount) throw Error(\"Invalid byte index\");\n            var continuationByte = 255 & byteArray[byteIndex];\n            if (byteIndex++, 128 == (192 & continuationByte)) return 63 & continuationByte;\n            throw Error(\"Invalid continuation byte\");\n          }\n\n          function decodeSymbol() {\n            var byte1, byte2, byte3, byte4, codePoint;\n            if (byteIndex > byteCount) throw Error(\"Invalid byte index\");\n            if (byteIndex == byteCount) return !1;\n            if (byte1 = 255 & byteArray[byteIndex], byteIndex++, 0 == (128 & byte1)) return byte1;\n\n            if (192 == (224 & byte1)) {\n              var byte2 = readContinuationByte();\n              if ((codePoint = (31 & byte1) << 6 | byte2) >= 128) return codePoint;\n              throw Error(\"Invalid continuation byte\");\n            }\n\n            if (224 == (240 & byte1)) {\n              if (byte2 = readContinuationByte(), byte3 = readContinuationByte(), (codePoint = (15 & byte1) << 12 | byte2 << 6 | byte3) >= 2048) return checkScalarValue(codePoint), codePoint;\n              throw Error(\"Invalid continuation byte\");\n            }\n\n            if (240 == (248 & byte1) && (byte2 = readContinuationByte(), byte3 = readContinuationByte(), byte4 = readContinuationByte(), (codePoint = (15 & byte1) << 18 | byte2 << 12 | byte3 << 6 | byte4) >= 65536 && codePoint <= 1114111)) return codePoint;\n            throw Error(\"Invalid UTF-8 detected\");\n          }\n\n          function utf8decode(byteString) {\n            byteArray = ucs2decode(byteString), byteCount = byteArray.length, byteIndex = 0;\n\n            for (var tmp, codePoints = []; !1 !== (tmp = decodeSymbol());) {\n              codePoints.push(tmp);\n            }\n\n            return ucs2encode(codePoints);\n          }\n\n          var freeExports = \"object\" == typeof exports && exports,\n              freeModule = \"object\" == typeof module && module && module.exports == freeExports && module,\n              freeGlobal = \"object\" == typeof global && global;\n          freeGlobal.global !== freeGlobal && freeGlobal.window !== freeGlobal || (root = freeGlobal);\n          var byteArray,\n              byteCount,\n              byteIndex,\n              stringFromCharCode = String.fromCharCode,\n              utf8 = {\n            version: \"2.0.0\",\n            encode: utf8encode,\n            decode: utf8decode\n          };\n          if (\"function\" == typeof define && \"object\" == typeof define.amd && define.amd) define(function () {\n            return utf8;\n          });else if (freeExports && !freeExports.nodeType) {\n            if (freeModule) freeModule.exports = utf8;else {\n              var object = {},\n                  hasOwnProperty = object.hasOwnProperty;\n\n              for (var key in utf8) {\n                hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);\n              }\n            }\n          } else root.utf8 = utf8;\n        }(this);\n      }).call(this, \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : {});\n    }, {}],\n    45: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      function encode(num) {\n        var encoded = \"\";\n\n        do {\n          encoded = alphabet[num % length] + encoded, num = Math.floor(num / length);\n        } while (num > 0);\n\n        return encoded;\n      }\n\n      function decode(str) {\n        var decoded = 0;\n\n        for (i = 0; i < str.length; i++) {\n          decoded = decoded * length + map[str.charAt(i)];\n        }\n\n        return decoded;\n      }\n\n      function yeast() {\n        var now = encode(+new Date());\n        return now !== prev ? (seed = 0, prev = now) : now + \".\" + encode(seed++);\n      }\n\n      for (var prev, alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\".split(\"\"), length = 64, map = {}, seed = 0, i = 0; i < length; i++) {\n        map[alphabet[i]] = i;\n      }\n\n      yeast.encode = encode, yeast.decode = decode, module.exports = yeast;\n    }, {}]\n  }, {}, [1])(1);\n});\nvar AdapterJS = AdapterJS || window.AdapterJS || {};\n\nif (AdapterJS.options = AdapterJS.options || {}, AdapterJS.options.getAllCams = !!AdapterJS.options.getAllCams, AdapterJS.options.hidePluginInstallPrompt = !!AdapterJS.options.hidePluginInstallPrompt, AdapterJS.options.forceSafariPlugin = !!AdapterJS.options.forceSafariPlugin, AdapterJS.VERSION = \"0.15.4\", AdapterJS.onwebrtcready = AdapterJS.onwebrtcready || function (isUsingPlugin) {}, AdapterJS._onwebrtcreadies = [], AdapterJS.webRTCReady = function (baseCallback) {\n  if (\"function\" != typeof baseCallback) throw new Error(\"Callback provided is not a function\");\n\n  var callback = function callback() {\n    \"function\" == typeof window.require && \"function\" == typeof AdapterJS._defineMediaSourcePolyfill && AdapterJS._defineMediaSourcePolyfill(), baseCallback(null !== AdapterJS.WebRTCPlugin.plugin);\n  };\n\n  !0 === AdapterJS.onwebrtcreadyDone ? callback() : AdapterJS._onwebrtcreadies.push(callback);\n}, AdapterJS.WebRTCPlugin = AdapterJS.WebRTCPlugin || {}, AdapterJS.WebRTCPlugin.pluginInfo = AdapterJS.WebRTCPlugin.pluginInfo || {\n  prefix: \"Tem\",\n  plugName: \"TemWebRTCPlugin\",\n  pluginId: \"plugin0\",\n  type: \"application/x-temwebrtcplugin\",\n  onload: \"__TemWebRTCReady0\",\n  portalLink: \"https://skylink.io/plugin/\",\n  downloadLink: null,\n  companyName: \"Temasys\",\n  downloadLinks: {\n    mac: \"https://bit.ly/webrtcpluginpkg\",\n    win: \"https://bit.ly/webrtcpluginmsi\"\n  }\n}, void 0 !== AdapterJS.WebRTCPlugin.pluginInfo.downloadLinks && null !== AdapterJS.WebRTCPlugin.pluginInfo.downloadLinks && (navigator.platform.match(/^Mac/i) ? AdapterJS.WebRTCPlugin.pluginInfo.downloadLink = AdapterJS.WebRTCPlugin.pluginInfo.downloadLinks.mac : navigator.platform.match(/^Win/i) && (AdapterJS.WebRTCPlugin.pluginInfo.downloadLink = AdapterJS.WebRTCPlugin.pluginInfo.downloadLinks.win)), AdapterJS.WebRTCPlugin.TAGS = {\n  NONE: \"none\",\n  AUDIO: \"audio\",\n  VIDEO: \"video\"\n}, AdapterJS.WebRTCPlugin.pageId = Math.random().toString(36).slice(2), AdapterJS.WebRTCPlugin.plugin = null, AdapterJS.WebRTCPlugin.setLogLevel = null, AdapterJS.WebRTCPlugin.defineWebRTCInterface = null, AdapterJS.WebRTCPlugin.isPluginInstalled = null, AdapterJS.WebRTCPlugin.pluginInjectionInterval = null, AdapterJS.WebRTCPlugin.injectPlugin = null, AdapterJS.WebRTCPlugin.PLUGIN_STATES = {\n  NONE: 0,\n  INITIALIZING: 1,\n  INJECTING: 2,\n  INJECTED: 3,\n  READY: 4\n}, AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.NONE, AdapterJS.onwebrtcreadyDone = !1, AdapterJS.WebRTCPlugin.PLUGIN_LOG_LEVELS = {\n  NONE: \"NONE\",\n  ERROR: \"ERROR\",\n  WARNING: \"WARNING\",\n  INFO: \"INFO\",\n  VERBOSE: \"VERBOSE\",\n  SENSITIVE: \"SENSITIVE\"\n}, AdapterJS.WebRTCPlugin.WaitForPluginReady = null, AdapterJS.WebRTCPlugin.callWhenPluginReady = null, AdapterJS.documentReady = function () {\n  return \"interactive\" === document.readyState && !!document.body || \"complete\" === document.readyState;\n}, window.__TemWebRTCReady0 = function () {\n  AdapterJS.documentReady() ? (AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY, AdapterJS.maybeThroughWebRTCReady()) : setTimeout(__TemWebRTCReady0, 100);\n}, AdapterJS.maybeThroughWebRTCReady = function () {\n  AdapterJS.onwebrtcreadyDone || (AdapterJS.onwebrtcreadyDone = !0, AdapterJS._onwebrtcreadies.length ? AdapterJS._onwebrtcreadies.forEach(function (callback) {\n    \"function\" == typeof callback && callback(null !== AdapterJS.WebRTCPlugin.plugin);\n  }) : \"function\" == typeof AdapterJS.onwebrtcready && AdapterJS.onwebrtcready(null !== AdapterJS.WebRTCPlugin.plugin));\n}, AdapterJS.TEXT = {\n  PLUGIN: {\n    REQUIRE_INSTALLATION: \"This website requires you to install a WebRTC-enabling plugin to work on this browser.\",\n    REQUIRE_RESTART: \"Your plugin is being downloaded. Please run the installer, and restart your browser to begin using it.\",\n    NOT_SUPPORTED: \"Your browser does not support WebRTC.\",\n    BUTTON: \"Install Now\"\n  },\n  REFRESH: {\n    REQUIRE_REFRESH: \"Please refresh page\",\n    BUTTON: \"Refresh Page\"\n  }\n}, AdapterJS._iceConnectionStates = {\n  starting: \"starting\",\n  checking: \"checking\",\n  connected: \"connected\",\n  completed: \"connected\",\n  done: \"completed\",\n  disconnected: \"disconnected\",\n  failed: \"failed\",\n  closed: \"closed\"\n}, AdapterJS._iceConnectionFiredStates = [], AdapterJS.isDefined = null, window.webrtcDetectedType = null, window.MediaStream = \"function\" == typeof MediaStream ? MediaStream : null, window.RTCPeerConnection = \"function\" == typeof RTCPeerConnection ? RTCPeerConnection : null, window.RTCSessionDescription = \"function\" == typeof RTCSessionDescription ? RTCSessionDescription : null, window.RTCIceCandidate = \"function\" == typeof RTCIceCandidate ? RTCIceCandidate : null, window.getUserMedia = \"function\" == typeof getUserMedia ? getUserMedia : null, window.attachMediaStream = null, window.reattachMediaStream = null, window.webrtcDetectedBrowser = null, window.webrtcDetectedVersion = null, window.webrtcMinimumVersion = null, window.webrtcDetectedDCSupport = null, AdapterJS.parseWebrtcDetectedBrowser = function () {\n  var hasMatch = null;\n  if (window.opr && opr.addons || window.opera || navigator.userAgent.indexOf(\" OPR/\") >= 0) hasMatch = navigator.userAgent.match(/OPR\\/(\\d+)/i) || [], window.webrtcDetectedBrowser = \"opera\", window.webrtcDetectedVersion = parseInt(hasMatch[1] || \"0\", 10), window.webrtcMinimumVersion = 26, window.webrtcDetectedType = \"webkit\", window.webrtcDetectedDCSupport = \"SCTP\";else if (navigator.userAgent.match(/Bowser\\/[0-9.]*/g)) {\n    hasMatch = navigator.userAgent.match(/Bowser\\/[0-9.]*/g) || [];\n    var chromiumVersion = parseInt((navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./i) || [])[2] || \"0\", 10);\n    window.webrtcDetectedBrowser = \"bowser\", window.webrtcDetectedVersion = parseFloat((hasMatch[0] || \"0/0\").split(\"/\")[1], 10), window.webrtcMinimumVersion = 0, window.webrtcDetectedType = \"webkit\", window.webrtcDetectedDCSupport = chromiumVersion > 30 ? \"SCTP\" : \"RTP\";\n  } else if (navigator.userAgent.indexOf(\"OPiOS\") > 0) hasMatch = navigator.userAgent.match(/OPiOS\\/([0-9]+)\\./), window.webrtcDetectedBrowser = \"opera\", window.webrtcDetectedVersion = parseInt(hasMatch[1] || \"0\", 10), window.webrtcMinimumVersion = 0, window.webrtcDetectedType = null, window.webrtcDetectedDCSupport = null;else if (navigator.userAgent.indexOf(\"CriOS\") > 0) hasMatch = navigator.userAgent.match(/CriOS\\/([0-9]+)\\./) || [], window.webrtcDetectedVersion = parseInt(hasMatch[1] || \"0\", 10), window.webrtcMinimumVersion = 0, window.webrtcDetectedType = null, window.webrtcDetectedBrowser = \"chrome\", window.webrtcDetectedDCSupport = null;else if (navigator.userAgent.indexOf(\"FxiOS\") > 0) hasMatch = navigator.userAgent.match(/FxiOS\\/([0-9]+)\\./) || [], window.webrtcDetectedBrowser = \"firefox\", window.webrtcDetectedVersion = parseInt(hasMatch[1] || \"0\", 10), window.webrtcMinimumVersion = 0, window.webrtcDetectedType = null, window.webrtcDetectedDCSupport = null;else if (document.documentMode) hasMatch = /\\brv[ :]+(\\d+)/g.exec(navigator.userAgent) || [], window.webrtcDetectedBrowser = \"IE\", window.webrtcDetectedVersion = parseInt(hasMatch[1], 10), window.webrtcMinimumVersion = 9, window.webrtcDetectedType = \"plugin\", window.webrtcDetectedDCSupport = \"SCTP\", webrtcDetectedVersion || (hasMatch = /\\bMSIE[ :]+(\\d+)/g.exec(navigator.userAgent) || [], window.webrtcDetectedVersion = parseInt(hasMatch[1] || \"0\", 10));else if (window.StyleMedia || navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) hasMatch = navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/) || [], window.webrtcDetectedBrowser = \"edge\", window.webrtcDetectedVersion = parseFloat((hasMatch[0] || \"0/0\").split(\"/\")[1], 10), window.webrtcMinimumVersion = 13.10547, window.webrtcDetectedType = \"ms\", window.webrtcDetectedDCSupport = null;else if (\"undefined\" != typeof InstallTrigger || navigator.userAgent.indexOf(\"irefox\") > 0) hasMatch = navigator.userAgent.match(/Firefox\\/([0-9]+)\\./) || [], window.webrtcDetectedBrowser = \"firefox\", window.webrtcDetectedVersion = parseInt(hasMatch[1] || \"0\", 10), window.webrtcMinimumVersion = 33, window.webrtcDetectedType = \"moz\", window.webrtcDetectedDCSupport = \"SCTP\";else if (window.chrome && window.chrome.webstore || navigator.userAgent.indexOf(\"Chrom\") > 0) hasMatch = navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./i) || [], window.webrtcDetectedBrowser = \"chrome\", window.webrtcDetectedVersion = parseInt(hasMatch[2] || \"0\", 10), window.webrtcMinimumVersion = 38, window.webrtcDetectedType = \"webkit\", window.webrtcDetectedDCSupport = window.webrtcDetectedVersion > 30 ? \"SCTP\" : \"RTP\";else if (/constructor/i.test(window.HTMLElement) || function (p) {\n    return \"[object SafariRemoteNotification]\" === p.toString();\n  }(!window.safari || safari.pushNotification) || navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./) || navigator.userAgent.match(/Version\\/(\\d+).(\\d+)/)) {\n    hasMatch = navigator.userAgent.match(/version\\/(\\d+)\\.(\\d+)/i) || [];\n    var AppleWebKitBuild = navigator.userAgent.match(/AppleWebKit\\/(\\d+)/i) || [],\n        isMobile = navigator.userAgent.match(/(iPhone|iPad)/gi),\n        hasNativeImpl = AppleWebKitBuild.length >= 1 && AppleWebKitBuild[1] >= 604;\n    if (window.webrtcDetectedBrowser = \"safari\", window.webrtcDetectedVersion = parseInt(hasMatch[1] || \"0\", 10), window.webrtcMinimumVersion = 7, isMobile) window.webrtcDetectedType = hasNativeImpl ? \"AppleWebKit\" : null;else {\n      var majorVersion = window.webrtcDetectedVersion,\n          minorVersion = parseInt(hasMatch[2] || \"0\", 10),\n          nativeImplIsOverridable = 11 == majorVersion && minorVersion < 2;\n      window.webrtcDetectedType = !hasNativeImpl || AdapterJS.options.forceSafariPlugin && nativeImplIsOverridable ? \"plugin\" : \"AppleWebKit\";\n    }\n    window.webrtcDetectedDCSupport = \"SCTP\";\n  }\n  AdapterJS.webrtcDetectedBrowser = window.webrtcDetectedBrowser, AdapterJS.webrtcDetectedVersion = window.webrtcDetectedVersion, AdapterJS.webrtcMinimumVersion = window.webrtcMinimumVersion, AdapterJS.webrtcDetectedType = window.webrtcDetectedType, AdapterJS.webrtcDetectedDCSupport = window.webrtcDetectedDCSupport;\n}, AdapterJS.addEvent = function (elem, evnt, func) {\n  elem.addEventListener ? elem.addEventListener(evnt, func, !1) : elem.attachEvent ? elem.attachEvent(\"on\" + evnt, func) : elem[evnt] = func;\n}, AdapterJS.renderNotificationBar = function (message, buttonText, buttonCallback) {\n  if (AdapterJS.documentReady()) {\n    var w = window,\n        i = document.createElement(\"iframe\");\n    i.name = \"adapterjs-alert\", i.style.position = \"fixed\", i.style.top = \"-41px\", i.style.left = 0, i.style.right = 0, i.style.width = \"100%\", i.style.height = \"40px\", i.style.backgroundColor = \"#ffffe1\", i.style.border = \"none\", i.style.borderBottom = \"1px solid #888888\", i.style.zIndex = \"9999999\", \"string\" == typeof i.style.webkitTransition ? i.style.webkitTransition = \"all .5s ease-out\" : \"string\" == typeof i.style.transition && (i.style.transition = \"all .5s ease-out\"), document.body.appendChild(i);\n    var c = i.contentWindow ? i.contentWindow : i.contentDocument.document ? i.contentDocument.document : i.contentDocument;\n    c.document.open(), c.document.write('<span style=\"display: inline-block; font-family: Helvetica, Arial,sans-serif; font-size: .9rem; padding: 4px; vertical-align: middle; cursor: default;\">' + message + \"</span>\"), buttonText && \"function\" == typeof buttonCallback ? (c.document.write('<button id=\"okay\">' + buttonText + '</button><button id=\"cancel\">Cancel</button>'), c.document.close(), AdapterJS.addEvent(c.document.getElementById(\"okay\"), \"click\", function (e) {\n      e.preventDefault();\n\n      try {\n        e.cancelBubble = !0;\n      } catch (error) {}\n\n      buttonCallback(e);\n    }), AdapterJS.addEvent(c.document.getElementById(\"cancel\"), \"click\", function (e) {\n      w.document.body.removeChild(i);\n    })) : c.document.close(), setTimeout(function () {\n      \"string\" == typeof i.style.webkitTransform ? i.style.webkitTransform = \"translateY(40px)\" : \"string\" == typeof i.style.transform ? i.style.transform = \"translateY(40px)\" : i.style.top = \"0px\";\n    }, 300);\n  }\n}, window.requestUserMedia = \"function\" == typeof requestUserMedia ? requestUserMedia : null, AdapterJS.parseWebrtcDetectedBrowser(), [\"webkit\", \"moz\", \"ms\", \"AppleWebKit\"].indexOf(AdapterJS.webrtcDetectedType) > -1) {\n  navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/) && window.RTCPeerConnection && (window.msRTCPeerConnection = window.RTCPeerConnection), function (f) {\n    if (\"object\" == typeof exports && \"undefined\" != typeof module) module.exports = f();else if (\"function\" == typeof define && define.amd) define([], f);else {\n      var g;\n      g = \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : this, g.adapter = f();\n    }\n  }(function () {\n    return function e(t, n, r) {\n      function s(o, u) {\n        if (!n[o]) {\n          if (!t[o]) {\n            var a = \"function\" == typeof require && require;\n            if (!u && a) return a(o, !0);\n            if (i) return i(o, !0);\n            var f = new Error(\"Cannot find module '\" + o + \"'\");\n            throw f.code = \"MODULE_NOT_FOUND\", f;\n          }\n\n          var l = n[o] = {\n            exports: {}\n          };\n          t[o][0].call(l.exports, function (e) {\n            var n = t[o][1][e];\n            return s(n || e);\n          }, l, l.exports, e, t, n, r);\n        }\n\n        return n[o].exports;\n      }\n\n      for (var i = \"function\" == typeof require && require, o = 0; o < r.length; o++) {\n        s(r[o]);\n      }\n\n      return s;\n    }({\n      1: [function (requirecopy, module, exports) {\n        \"use strict\";\n\n        function fixStatsType(stat) {\n          return {\n            inboundrtp: \"inbound-rtp\",\n            outboundrtp: \"outbound-rtp\",\n            candidatepair: \"candidate-pair\",\n            localcandidate: \"local-candidate\",\n            remotecandidate: \"remote-candidate\"\n          }[stat.type] || stat.type;\n        }\n\n        function writeMediaSection(transceiver, caps, type, stream, dtlsRole) {\n          var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\n          if (sdp += SDPUtils.writeIceParameters(transceiver.iceGatherer.getLocalParameters()), sdp += SDPUtils.writeDtlsParameters(transceiver.dtlsTransport.getLocalParameters(), \"offer\" === type ? \"actpass\" : dtlsRole || \"active\"), sdp += \"a=mid:\" + transceiver.mid + \"\\r\\n\", transceiver.rtpSender && transceiver.rtpReceiver ? sdp += \"a=sendrecv\\r\\n\" : transceiver.rtpSender ? sdp += \"a=sendonly\\r\\n\" : transceiver.rtpReceiver ? sdp += \"a=recvonly\\r\\n\" : sdp += \"a=inactive\\r\\n\", transceiver.rtpSender) {\n            var trackId = transceiver.rtpSender._initialTrackId || transceiver.rtpSender.track.id;\n            transceiver.rtpSender._initialTrackId = trackId;\n            var msid = \"msid:\" + (stream ? stream.id : \"-\") + \" \" + trackId + \"\\r\\n\";\n            sdp += \"a=\" + msid, sdp += \"a=ssrc:\" + transceiver.sendEncodingParameters[0].ssrc + \" \" + msid, transceiver.sendEncodingParameters[0].rtx && (sdp += \"a=ssrc:\" + transceiver.sendEncodingParameters[0].rtx.ssrc + \" \" + msid, sdp += \"a=ssrc-group:FID \" + transceiver.sendEncodingParameters[0].ssrc + \" \" + transceiver.sendEncodingParameters[0].rtx.ssrc + \"\\r\\n\");\n          }\n\n          return sdp += \"a=ssrc:\" + transceiver.sendEncodingParameters[0].ssrc + \" cname:\" + SDPUtils.localCName + \"\\r\\n\", transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx && (sdp += \"a=ssrc:\" + transceiver.sendEncodingParameters[0].rtx.ssrc + \" cname:\" + SDPUtils.localCName + \"\\r\\n\"), sdp;\n        }\n\n        function filterIceServers(iceServers, edgeVersion) {\n          var hasTurn = !1;\n          return iceServers = JSON.parse(JSON.stringify(iceServers)), iceServers.filter(function (server) {\n            if (server && (server.urls || server.url)) {\n              var urls = server.urls || server.url;\n              server.url && !server.urls && console.warn(\"RTCIceServer.url is deprecated! Use urls instead.\");\n              var isString = \"string\" == typeof urls;\n              return isString && (urls = [urls]), urls = urls.filter(function (url) {\n                return 0 !== url.indexOf(\"turn:\") || -1 === url.indexOf(\"transport=udp\") || -1 !== url.indexOf(\"turn:[\") || hasTurn ? 0 === url.indexOf(\"stun:\") && edgeVersion >= 14393 && -1 === url.indexOf(\"?transport=udp\") : (hasTurn = !0, !0);\n              }), delete server.url, server.urls = isString ? urls[0] : urls, !!urls.length;\n            }\n          });\n        }\n\n        function getCommonCapabilities(localCapabilities, remoteCapabilities) {\n          var commonCapabilities = {\n            codecs: [],\n            headerExtensions: [],\n            fecMechanisms: []\n          },\n              findCodecByPayloadType = function findCodecByPayloadType(pt, codecs) {\n            pt = parseInt(pt, 10);\n\n            for (var i = 0; i < codecs.length; i++) {\n              if (codecs[i].payloadType === pt || codecs[i].preferredPayloadType === pt) return codecs[i];\n            }\n          },\n              rtxCapabilityMatches = function rtxCapabilityMatches(lRtx, rRtx, lCodecs, rCodecs) {\n            var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs),\n                rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);\n            return lCodec && rCodec && lCodec.name.toLowerCase() === rCodec.name.toLowerCase();\n          };\n\n          return localCapabilities.codecs.forEach(function (lCodec) {\n            for (var i = 0; i < remoteCapabilities.codecs.length; i++) {\n              var rCodec = remoteCapabilities.codecs[i];\n\n              if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() && lCodec.clockRate === rCodec.clockRate) {\n                if (\"rtx\" === lCodec.name.toLowerCase() && lCodec.parameters && rCodec.parameters.apt && !rtxCapabilityMatches(lCodec, rCodec, localCapabilities.codecs, remoteCapabilities.codecs)) continue;\n                rCodec = JSON.parse(JSON.stringify(rCodec)), rCodec.numChannels = Math.min(lCodec.numChannels, rCodec.numChannels), commonCapabilities.codecs.push(rCodec), rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function (fb) {\n                  for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {\n                    if (lCodec.rtcpFeedback[j].type === fb.type && lCodec.rtcpFeedback[j].parameter === fb.parameter) return !0;\n                  }\n\n                  return !1;\n                });\n                break;\n              }\n            }\n          }), localCapabilities.headerExtensions.forEach(function (lHeaderExtension) {\n            for (var i = 0; i < remoteCapabilities.headerExtensions.length; i++) {\n              var rHeaderExtension = remoteCapabilities.headerExtensions[i];\n\n              if (lHeaderExtension.uri === rHeaderExtension.uri) {\n                commonCapabilities.headerExtensions.push(rHeaderExtension);\n                break;\n              }\n            }\n          }), commonCapabilities;\n        }\n\n        function isActionAllowedInSignalingState(action, type, signalingState) {\n          return -1 !== {\n            offer: {\n              setLocalDescription: [\"stable\", \"have-local-offer\"],\n              setRemoteDescription: [\"stable\", \"have-remote-offer\"]\n            },\n            answer: {\n              setLocalDescription: [\"have-remote-offer\", \"have-local-pranswer\"],\n              setRemoteDescription: [\"have-local-offer\", \"have-remote-pranswer\"]\n            }\n          }[type][action].indexOf(signalingState);\n        }\n\n        function maybeAddCandidate(iceTransport, candidate) {\n          var alreadyAdded = iceTransport.getRemoteCandidates().find(function (remoteCandidate) {\n            return candidate.foundation === remoteCandidate.foundation && candidate.ip === remoteCandidate.ip && candidate.port === remoteCandidate.port && candidate.priority === remoteCandidate.priority && candidate.protocol === remoteCandidate.protocol && candidate.type === remoteCandidate.type;\n          });\n          return alreadyAdded || iceTransport.addRemoteCandidate(candidate), !alreadyAdded;\n        }\n\n        function makeError(name, description) {\n          var e = new Error(description);\n          return e.name = name, e.code = {\n            NotSupportedError: 9,\n            InvalidStateError: 11,\n            InvalidAccessError: 15,\n            TypeError: void 0,\n            OperationError: void 0\n          }[name], e;\n        }\n\n        var SDPUtils = requirecopy(\"sdp\");\n\n        module.exports = function (window, edgeVersion) {\n          function addTrackToStreamAndFireEvent(track, stream) {\n            stream.addTrack(track), stream.dispatchEvent(new window.MediaStreamTrackEvent(\"addtrack\", {\n              track: track\n            }));\n          }\n\n          function removeTrackFromStreamAndFireEvent(track, stream) {\n            stream.removeTrack(track), stream.dispatchEvent(new window.MediaStreamTrackEvent(\"removetrack\", {\n              track: track\n            }));\n          }\n\n          function fireAddTrack(pc, track, receiver, streams) {\n            var trackEvent = new Event(\"track\");\n            trackEvent.track = track, trackEvent.receiver = receiver, trackEvent.transceiver = {\n              receiver: receiver\n            }, trackEvent.streams = streams, window.setTimeout(function () {\n              pc._dispatchEvent(\"track\", trackEvent);\n            });\n          }\n\n          var RTCPeerConnection = function RTCPeerConnection(config) {\n            var pc = this,\n                _eventTarget = document.createDocumentFragment();\n\n            if ([\"addEventListener\", \"removeEventListener\", \"dispatchEvent\"].forEach(function (method) {\n              pc[method] = _eventTarget[method].bind(_eventTarget);\n            }), this.canTrickleIceCandidates = null, this.needNegotiation = !1, this.localStreams = [], this.remoteStreams = [], this._localDescription = null, this._remoteDescription = null, this.signalingState = \"stable\", this.iceConnectionState = \"new\", this.connectionState = \"new\", this.iceGatheringState = \"new\", config = JSON.parse(JSON.stringify(config || {})), this.usingBundle = \"max-bundle\" === config.bundlePolicy, \"negotiate\" === config.rtcpMuxPolicy) throw makeError(\"NotSupportedError\", \"rtcpMuxPolicy 'negotiate' is not supported\");\n\n            switch (config.rtcpMuxPolicy || (config.rtcpMuxPolicy = \"require\"), config.iceTransportPolicy) {\n              case \"all\":\n              case \"relay\":\n                break;\n\n              default:\n                config.iceTransportPolicy = \"all\";\n            }\n\n            switch (config.bundlePolicy) {\n              case \"balanced\":\n              case \"max-compat\":\n              case \"max-bundle\":\n                break;\n\n              default:\n                config.bundlePolicy = \"balanced\";\n            }\n\n            if (config.iceServers = filterIceServers(config.iceServers || [], edgeVersion), this._iceGatherers = [], config.iceCandidatePoolSize) for (var i = config.iceCandidatePoolSize; i > 0; i--) {\n              this._iceGatherers.push(new window.RTCIceGatherer({\n                iceServers: config.iceServers,\n                gatherPolicy: config.iceTransportPolicy\n              }));\n            } else config.iceCandidatePoolSize = 0;\n            this._config = config, this.transceivers = [], this._sdpSessionId = SDPUtils.generateSessionId(), this._sdpSessionVersion = 0, this._dtlsRole = void 0, this._isClosed = !1;\n          };\n\n          Object.defineProperty(RTCPeerConnection.prototype, \"localDescription\", {\n            configurable: !0,\n            get: function get() {\n              return this._localDescription;\n            }\n          }), Object.defineProperty(RTCPeerConnection.prototype, \"remoteDescription\", {\n            configurable: !0,\n            get: function get() {\n              return this._remoteDescription;\n            }\n          }), RTCPeerConnection.prototype.onicecandidate = null, RTCPeerConnection.prototype.onaddstream = null, RTCPeerConnection.prototype.ontrack = null, RTCPeerConnection.prototype.onremovestream = null, RTCPeerConnection.prototype.onsignalingstatechange = null, RTCPeerConnection.prototype.oniceconnectionstatechange = null, RTCPeerConnection.prototype.onconnectionstatechange = null, RTCPeerConnection.prototype.onicegatheringstatechange = null, RTCPeerConnection.prototype.onnegotiationneeded = null, RTCPeerConnection.prototype.ondatachannel = null, RTCPeerConnection.prototype._dispatchEvent = function (name, event) {\n            this._isClosed || (this.dispatchEvent(event), \"function\" == typeof this[\"on\" + name] && this[\"on\" + name](event));\n          }, RTCPeerConnection.prototype._emitGatheringStateChange = function () {\n            var event = new Event(\"icegatheringstatechange\");\n\n            this._dispatchEvent(\"icegatheringstatechange\", event);\n          }, RTCPeerConnection.prototype.getConfiguration = function () {\n            return this._config;\n          }, RTCPeerConnection.prototype.getLocalStreams = function () {\n            return this.localStreams;\n          }, RTCPeerConnection.prototype.getRemoteStreams = function () {\n            return this.remoteStreams;\n          }, RTCPeerConnection.prototype._createTransceiver = function (kind, doNotAdd) {\n            var hasBundleTransport = this.transceivers.length > 0,\n                transceiver = {\n              track: null,\n              iceGatherer: null,\n              iceTransport: null,\n              dtlsTransport: null,\n              localCapabilities: null,\n              remoteCapabilities: null,\n              rtpSender: null,\n              rtpReceiver: null,\n              kind: kind,\n              mid: null,\n              sendEncodingParameters: null,\n              recvEncodingParameters: null,\n              stream: null,\n              associatedRemoteMediaStreams: [],\n              wantReceive: !0\n            };\n            if (this.usingBundle && hasBundleTransport) transceiver.iceTransport = this.transceivers[0].iceTransport, transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;else {\n              var transports = this._createIceAndDtlsTransports();\n\n              transceiver.iceTransport = transports.iceTransport, transceiver.dtlsTransport = transports.dtlsTransport;\n            }\n            return doNotAdd || this.transceivers.push(transceiver), transceiver;\n          }, RTCPeerConnection.prototype.addTrack = function (track, stream) {\n            if (this._isClosed) throw makeError(\"InvalidStateError\", \"Attempted to call addTrack on a closed peerconnection.\");\n            if (this.transceivers.find(function (s) {\n              return s.track === track;\n            })) throw makeError(\"InvalidAccessError\", \"Track already exists.\");\n\n            for (var transceiver, i = 0; i < this.transceivers.length; i++) {\n              this.transceivers[i].track || this.transceivers[i].kind !== track.kind || (transceiver = this.transceivers[i]);\n            }\n\n            return transceiver || (transceiver = this._createTransceiver(track.kind)), this._maybeFireNegotiationNeeded(), -1 === this.localStreams.indexOf(stream) && this.localStreams.push(stream), transceiver.track = track, transceiver.stream = stream, transceiver.rtpSender = new window.RTCRtpSender(track, transceiver.dtlsTransport), transceiver.rtpSender;\n          }, RTCPeerConnection.prototype.addStream = function (stream) {\n            var pc = this;\n            if (edgeVersion >= 15025) stream.getTracks().forEach(function (track) {\n              pc.addTrack(track, stream);\n            });else {\n              var clonedStream = stream.clone();\n              stream.getTracks().forEach(function (track, idx) {\n                var clonedTrack = clonedStream.getTracks()[idx];\n                track.addEventListener(\"enabled\", function (event) {\n                  clonedTrack.enabled = event.enabled;\n                });\n              }), clonedStream.getTracks().forEach(function (track) {\n                pc.addTrack(track, clonedStream);\n              });\n            }\n          }, RTCPeerConnection.prototype.removeTrack = function (sender) {\n            if (this._isClosed) throw makeError(\"InvalidStateError\", \"Attempted to call removeTrack on a closed peerconnection.\");\n            if (!(sender instanceof window.RTCRtpSender)) throw new TypeError(\"Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.\");\n            var transceiver = this.transceivers.find(function (t) {\n              return t.rtpSender === sender;\n            });\n            if (!transceiver) throw makeError(\"InvalidAccessError\", \"Sender was not created by this connection.\");\n            var stream = transceiver.stream;\n            transceiver.rtpSender.stop(), transceiver.rtpSender = null, transceiver.track = null, transceiver.stream = null, -1 === this.transceivers.map(function (t) {\n              return t.stream;\n            }).indexOf(stream) && this.localStreams.indexOf(stream) > -1 && this.localStreams.splice(this.localStreams.indexOf(stream), 1), this._maybeFireNegotiationNeeded();\n          }, RTCPeerConnection.prototype.removeStream = function (stream) {\n            var pc = this;\n            stream.getTracks().forEach(function (track) {\n              var sender = pc.getSenders().find(function (s) {\n                return s.track === track;\n              });\n              sender && pc.removeTrack(sender);\n            });\n          }, RTCPeerConnection.prototype.getSenders = function () {\n            return this.transceivers.filter(function (transceiver) {\n              return !!transceiver.rtpSender;\n            }).map(function (transceiver) {\n              return transceiver.rtpSender;\n            });\n          }, RTCPeerConnection.prototype.getReceivers = function () {\n            return this.transceivers.filter(function (transceiver) {\n              return !!transceiver.rtpReceiver;\n            }).map(function (transceiver) {\n              return transceiver.rtpReceiver;\n            });\n          }, RTCPeerConnection.prototype._createIceGatherer = function (sdpMLineIndex, usingBundle) {\n            var pc = this;\n            if (usingBundle && sdpMLineIndex > 0) return this.transceivers[0].iceGatherer;\n            if (this._iceGatherers.length) return this._iceGatherers.shift();\n            var iceGatherer = new window.RTCIceGatherer({\n              iceServers: this._config.iceServers,\n              gatherPolicy: this._config.iceTransportPolicy\n            });\n            return Object.defineProperty(iceGatherer, \"state\", {\n              value: \"new\",\n              writable: !0\n            }), this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [], this.transceivers[sdpMLineIndex].bufferCandidates = function (event) {\n              var end = !event.candidate || 0 === Object.keys(event.candidate).length;\n              iceGatherer.state = end ? \"completed\" : \"gathering\", null !== pc.transceivers[sdpMLineIndex].bufferedCandidateEvents && pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);\n            }, iceGatherer.addEventListener(\"localcandidate\", this.transceivers[sdpMLineIndex].bufferCandidates), iceGatherer;\n          }, RTCPeerConnection.prototype._gather = function (mid, sdpMLineIndex) {\n            var pc = this,\n                iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\n\n            if (!iceGatherer.onlocalcandidate) {\n              var bufferedCandidateEvents = this.transceivers[sdpMLineIndex].bufferedCandidateEvents;\n              this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null, iceGatherer.removeEventListener(\"localcandidate\", this.transceivers[sdpMLineIndex].bufferCandidates), iceGatherer.onlocalcandidate = function (evt) {\n                if (!(pc.usingBundle && sdpMLineIndex > 0)) {\n                  var event = new Event(\"icecandidate\");\n                  event.candidate = {\n                    sdpMid: mid,\n                    sdpMLineIndex: sdpMLineIndex\n                  };\n                  var cand = evt.candidate,\n                      end = !cand || 0 === Object.keys(cand).length;\n                  if (end) \"new\" !== iceGatherer.state && \"gathering\" !== iceGatherer.state || (iceGatherer.state = \"completed\");else {\n                    \"new\" === iceGatherer.state && (iceGatherer.state = \"gathering\"), cand.component = 1, cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;\n                    var serializedCandidate = SDPUtils.writeCandidate(cand);\n                    event.candidate = Object.assign(event.candidate, SDPUtils.parseCandidate(serializedCandidate)), event.candidate.candidate = serializedCandidate, event.candidate.toJSON = function () {\n                      return {\n                        candidate: event.candidate.candidate,\n                        sdpMid: event.candidate.sdpMid,\n                        sdpMLineIndex: event.candidate.sdpMLineIndex,\n                        usernameFragment: event.candidate.usernameFragment\n                      };\n                    };\n                  }\n                  var sections = SDPUtils.getMediaSections(pc._localDescription.sdp);\n                  sections[event.candidate.sdpMLineIndex] += end ? \"a=end-of-candidates\\r\\n\" : \"a=\" + event.candidate.candidate + \"\\r\\n\", pc._localDescription.sdp = SDPUtils.getDescription(pc._localDescription.sdp) + sections.join(\"\");\n                  var complete = pc.transceivers.every(function (transceiver) {\n                    return transceiver.iceGatherer && \"completed\" === transceiver.iceGatherer.state;\n                  });\n                  \"gathering\" !== pc.iceGatheringState && (pc.iceGatheringState = \"gathering\", pc._emitGatheringStateChange()), end || pc._dispatchEvent(\"icecandidate\", event), complete && (pc._dispatchEvent(\"icecandidate\", new Event(\"icecandidate\")), pc.iceGatheringState = \"complete\", pc._emitGatheringStateChange());\n                }\n              }, window.setTimeout(function () {\n                bufferedCandidateEvents.forEach(function (e) {\n                  iceGatherer.onlocalcandidate(e);\n                });\n              }, 0);\n            }\n          }, RTCPeerConnection.prototype._createIceAndDtlsTransports = function () {\n            var pc = this,\n                iceTransport = new window.RTCIceTransport(null);\n\n            iceTransport.onicestatechange = function () {\n              pc._updateIceConnectionState(), pc._updateConnectionState();\n            };\n\n            var dtlsTransport = new window.RTCDtlsTransport(iceTransport);\n            return dtlsTransport.ondtlsstatechange = function () {\n              pc._updateConnectionState();\n            }, dtlsTransport.onerror = function () {\n              Object.defineProperty(dtlsTransport, \"state\", {\n                value: \"failed\",\n                writable: !0\n              }), pc._updateConnectionState();\n            }, {\n              iceTransport: iceTransport,\n              dtlsTransport: dtlsTransport\n            };\n          }, RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function (sdpMLineIndex) {\n            var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\n            iceGatherer && (delete iceGatherer.onlocalcandidate, delete this.transceivers[sdpMLineIndex].iceGatherer);\n            var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;\n            iceTransport && (delete iceTransport.onicestatechange, delete this.transceivers[sdpMLineIndex].iceTransport);\n            var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;\n            dtlsTransport && (delete dtlsTransport.ondtlsstatechange, delete dtlsTransport.onerror, delete this.transceivers[sdpMLineIndex].dtlsTransport);\n          }, RTCPeerConnection.prototype._transceive = function (transceiver, send, recv) {\n            var params = getCommonCapabilities(transceiver.localCapabilities, transceiver.remoteCapabilities);\n            send && transceiver.rtpSender && (params.encodings = transceiver.sendEncodingParameters, params.rtcp = {\n              cname: SDPUtils.localCName,\n              compound: transceiver.rtcpParameters.compound\n            }, transceiver.recvEncodingParameters.length && (params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc), transceiver.rtpSender.send(params)), recv && transceiver.rtpReceiver && params.codecs.length > 0 && (\"video\" === transceiver.kind && transceiver.recvEncodingParameters && edgeVersion < 15019 && transceiver.recvEncodingParameters.forEach(function (p) {\n              delete p.rtx;\n            }), transceiver.recvEncodingParameters.length ? params.encodings = transceiver.recvEncodingParameters : params.encodings = [{}], params.rtcp = {\n              compound: transceiver.rtcpParameters.compound\n            }, transceiver.rtcpParameters.cname && (params.rtcp.cname = transceiver.rtcpParameters.cname), transceiver.sendEncodingParameters.length && (params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc), transceiver.rtpReceiver.receive(params));\n          }, RTCPeerConnection.prototype.setLocalDescription = function (description) {\n            var pc = this;\n            if (-1 === [\"offer\", \"answer\"].indexOf(description.type)) return Promise.reject(makeError(\"TypeError\", 'Unsupported type \"' + description.type + '\"'));\n            if (!isActionAllowedInSignalingState(\"setLocalDescription\", description.type, pc.signalingState) || pc._isClosed) return Promise.reject(makeError(\"InvalidStateError\", \"Can not set local \" + description.type + \" in state \" + pc.signalingState));\n            var sections, sessionpart;\n            if (\"offer\" === description.type) sections = SDPUtils.splitSections(description.sdp), sessionpart = sections.shift(), sections.forEach(function (mediaSection, sdpMLineIndex) {\n              var caps = SDPUtils.parseRtpParameters(mediaSection);\n              pc.transceivers[sdpMLineIndex].localCapabilities = caps;\n            }), pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {\n              pc._gather(transceiver.mid, sdpMLineIndex);\n            });else if (\"answer\" === description.type) {\n              sections = SDPUtils.splitSections(pc._remoteDescription.sdp), sessionpart = sections.shift();\n              var isIceLite = SDPUtils.matchPrefix(sessionpart, \"a=ice-lite\").length > 0;\n              sections.forEach(function (mediaSection, sdpMLineIndex) {\n                var transceiver = pc.transceivers[sdpMLineIndex],\n                    iceGatherer = transceiver.iceGatherer,\n                    iceTransport = transceiver.iceTransport,\n                    dtlsTransport = transceiver.dtlsTransport,\n                    localCapabilities = transceiver.localCapabilities,\n                    remoteCapabilities = transceiver.remoteCapabilities;\n\n                if (!(SDPUtils.isRejected(mediaSection) && 0 === SDPUtils.matchPrefix(mediaSection, \"a=bundle-only\").length || transceiver.rejected)) {\n                  var remoteIceParameters = SDPUtils.getIceParameters(mediaSection, sessionpart),\n                      remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection, sessionpart);\n                  isIceLite && (remoteDtlsParameters.role = \"server\"), pc.usingBundle && 0 !== sdpMLineIndex || (pc._gather(transceiver.mid, sdpMLineIndex), \"new\" === iceTransport.state && iceTransport.start(iceGatherer, remoteIceParameters, isIceLite ? \"controlling\" : \"controlled\"), \"new\" === dtlsTransport.state && dtlsTransport.start(remoteDtlsParameters));\n                  var params = getCommonCapabilities(localCapabilities, remoteCapabilities);\n\n                  pc._transceive(transceiver, params.codecs.length > 0, !1);\n                }\n              });\n            }\n            return pc._localDescription = {\n              type: description.type,\n              sdp: description.sdp\n            }, \"offer\" === description.type ? pc._updateSignalingState(\"have-local-offer\") : pc._updateSignalingState(\"stable\"), Promise.resolve();\n          }, RTCPeerConnection.prototype.setRemoteDescription = function (description) {\n            var pc = this;\n            if (-1 === [\"offer\", \"answer\"].indexOf(description.type)) return Promise.reject(makeError(\"TypeError\", 'Unsupported type \"' + description.type + '\"'));\n            if (!isActionAllowedInSignalingState(\"setRemoteDescription\", description.type, pc.signalingState) || pc._isClosed) return Promise.reject(makeError(\"InvalidStateError\", \"Can not set remote \" + description.type + \" in state \" + pc.signalingState));\n            var streams = {};\n            pc.remoteStreams.forEach(function (stream) {\n              streams[stream.id] = stream;\n            });\n            var receiverList = [],\n                sections = SDPUtils.splitSections(description.sdp),\n                sessionpart = sections.shift(),\n                isIceLite = SDPUtils.matchPrefix(sessionpart, \"a=ice-lite\").length > 0,\n                usingBundle = SDPUtils.matchPrefix(sessionpart, \"a=group:BUNDLE \").length > 0;\n            pc.usingBundle = usingBundle;\n            var iceOptions = SDPUtils.matchPrefix(sessionpart, \"a=ice-options:\")[0];\n            return pc.canTrickleIceCandidates = !!iceOptions && iceOptions.substr(14).split(\" \").indexOf(\"trickle\") >= 0, sections.forEach(function (mediaSection, sdpMLineIndex) {\n              var lines = SDPUtils.splitLines(mediaSection),\n                  kind = SDPUtils.getKind(mediaSection),\n                  rejected = SDPUtils.isRejected(mediaSection) && 0 === SDPUtils.matchPrefix(mediaSection, \"a=bundle-only\").length,\n                  protocol = lines[0].substr(2).split(\" \")[2],\n                  direction = SDPUtils.getDirection(mediaSection, sessionpart),\n                  remoteMsid = SDPUtils.parseMsid(mediaSection),\n                  mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();\n              if (rejected || \"application\" === kind && (\"DTLS/SCTP\" === protocol || \"UDP/DTLS/SCTP\" === protocol)) return void (pc.transceivers[sdpMLineIndex] = {\n                mid: mid,\n                kind: kind,\n                protocol: protocol,\n                rejected: !0\n              });\n              !rejected && pc.transceivers[sdpMLineIndex] && pc.transceivers[sdpMLineIndex].rejected && (pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, !0));\n              var transceiver,\n                  iceGatherer,\n                  iceTransport,\n                  dtlsTransport,\n                  rtpReceiver,\n                  sendEncodingParameters,\n                  recvEncodingParameters,\n                  localCapabilities,\n                  track,\n                  remoteIceParameters,\n                  remoteDtlsParameters,\n                  remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);\n              rejected || (remoteIceParameters = SDPUtils.getIceParameters(mediaSection, sessionpart), remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection, sessionpart), remoteDtlsParameters.role = \"client\"), recvEncodingParameters = SDPUtils.parseRtpEncodingParameters(mediaSection);\n              var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection),\n                  isComplete = SDPUtils.matchPrefix(mediaSection, \"a=end-of-candidates\", sessionpart).length > 0,\n                  cands = SDPUtils.matchPrefix(mediaSection, \"a=candidate:\").map(function (cand) {\n                return SDPUtils.parseCandidate(cand);\n              }).filter(function (cand) {\n                return 1 === cand.component;\n              });\n              if ((\"offer\" === description.type || \"answer\" === description.type) && !rejected && usingBundle && sdpMLineIndex > 0 && pc.transceivers[sdpMLineIndex] && (pc._disposeIceAndDtlsTransports(sdpMLineIndex), pc.transceivers[sdpMLineIndex].iceGatherer = pc.transceivers[0].iceGatherer, pc.transceivers[sdpMLineIndex].iceTransport = pc.transceivers[0].iceTransport, pc.transceivers[sdpMLineIndex].dtlsTransport = pc.transceivers[0].dtlsTransport, pc.transceivers[sdpMLineIndex].rtpSender && pc.transceivers[sdpMLineIndex].rtpSender.setTransport(pc.transceivers[0].dtlsTransport), pc.transceivers[sdpMLineIndex].rtpReceiver && pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(pc.transceivers[0].dtlsTransport)), \"offer\" !== description.type || rejected) \"answer\" !== description.type || rejected || (transceiver = pc.transceivers[sdpMLineIndex], iceGatherer = transceiver.iceGatherer, iceTransport = transceiver.iceTransport, dtlsTransport = transceiver.dtlsTransport, rtpReceiver = transceiver.rtpReceiver, sendEncodingParameters = transceiver.sendEncodingParameters, localCapabilities = transceiver.localCapabilities, pc.transceivers[sdpMLineIndex].recvEncodingParameters = recvEncodingParameters, pc.transceivers[sdpMLineIndex].remoteCapabilities = remoteCapabilities, pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters, cands.length && \"new\" === iceTransport.state && (!isIceLite && !isComplete || usingBundle && 0 !== sdpMLineIndex ? cands.forEach(function (candidate) {\n                maybeAddCandidate(transceiver.iceTransport, candidate);\n              }) : iceTransport.setRemoteCandidates(cands)), usingBundle && 0 !== sdpMLineIndex || (\"new\" === iceTransport.state && iceTransport.start(iceGatherer, remoteIceParameters, \"controlling\"), \"new\" === dtlsTransport.state && dtlsTransport.start(remoteDtlsParameters)), pc._transceive(transceiver, \"sendrecv\" === direction || \"recvonly\" === direction, \"sendrecv\" === direction || \"sendonly\" === direction), !rtpReceiver || \"sendrecv\" !== direction && \"sendonly\" !== direction ? delete transceiver.rtpReceiver : (track = rtpReceiver.track, remoteMsid ? (streams[remoteMsid.stream] || (streams[remoteMsid.stream] = new window.MediaStream()), addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]), receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]])) : (streams.default || (streams.default = new window.MediaStream()), addTrackToStreamAndFireEvent(track, streams.default), receiverList.push([track, rtpReceiver, streams.default]))));else {\n                transceiver = pc.transceivers[sdpMLineIndex] || pc._createTransceiver(kind), transceiver.mid = mid, transceiver.iceGatherer || (transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex, usingBundle)), cands.length && \"new\" === transceiver.iceTransport.state && (!isComplete || usingBundle && 0 !== sdpMLineIndex ? cands.forEach(function (candidate) {\n                  maybeAddCandidate(transceiver.iceTransport, candidate);\n                }) : transceiver.iceTransport.setRemoteCandidates(cands)), localCapabilities = window.RTCRtpReceiver.getCapabilities(kind), edgeVersion < 15019 && (localCapabilities.codecs = localCapabilities.codecs.filter(function (codec) {\n                  return \"rtx\" !== codec.name;\n                })), sendEncodingParameters = transceiver.sendEncodingParameters || [{\n                  ssrc: 1001 * (2 * sdpMLineIndex + 2)\n                }];\n                var isNewTrack = !1;\n\n                if (\"sendrecv\" === direction || \"sendonly\" === direction) {\n                  if (isNewTrack = !transceiver.rtpReceiver, rtpReceiver = transceiver.rtpReceiver || new window.RTCRtpReceiver(transceiver.dtlsTransport, kind), isNewTrack) {\n                    var stream;\n                    track = rtpReceiver.track, remoteMsid && \"-\" === remoteMsid.stream || (remoteMsid ? (streams[remoteMsid.stream] || (streams[remoteMsid.stream] = new window.MediaStream(), Object.defineProperty(streams[remoteMsid.stream], \"id\", {\n                      get: function get() {\n                        return remoteMsid.stream;\n                      }\n                    })), Object.defineProperty(track, \"id\", {\n                      get: function get() {\n                        return remoteMsid.track;\n                      }\n                    }), stream = streams[remoteMsid.stream]) : (streams.default || (streams.default = new window.MediaStream()), stream = streams.default)), stream && (addTrackToStreamAndFireEvent(track, stream), transceiver.associatedRemoteMediaStreams.push(stream)), receiverList.push([track, rtpReceiver, stream]);\n                  }\n                } else transceiver.rtpReceiver && transceiver.rtpReceiver.track && (transceiver.associatedRemoteMediaStreams.forEach(function (s) {\n                  var nativeTrack = s.getTracks().find(function (t) {\n                    return t.id === transceiver.rtpReceiver.track.id;\n                  });\n                  nativeTrack && removeTrackFromStreamAndFireEvent(nativeTrack, s);\n                }), transceiver.associatedRemoteMediaStreams = []);\n\n                transceiver.localCapabilities = localCapabilities, transceiver.remoteCapabilities = remoteCapabilities, transceiver.rtpReceiver = rtpReceiver, transceiver.rtcpParameters = rtcpParameters, transceiver.sendEncodingParameters = sendEncodingParameters, transceiver.recvEncodingParameters = recvEncodingParameters, pc._transceive(pc.transceivers[sdpMLineIndex], !1, isNewTrack);\n              }\n            }), void 0 === pc._dtlsRole && (pc._dtlsRole = \"offer\" === description.type ? \"active\" : \"passive\"), pc._remoteDescription = {\n              type: description.type,\n              sdp: description.sdp\n            }, \"offer\" === description.type ? pc._updateSignalingState(\"have-remote-offer\") : pc._updateSignalingState(\"stable\"), Object.keys(streams).forEach(function (sid) {\n              var stream = streams[sid];\n\n              if (stream.getTracks().length) {\n                if (-1 === pc.remoteStreams.indexOf(stream)) {\n                  pc.remoteStreams.push(stream);\n                  var event = new Event(\"addstream\");\n                  event.stream = stream, window.setTimeout(function () {\n                    pc._dispatchEvent(\"addstream\", event);\n                  });\n                }\n\n                receiverList.forEach(function (item) {\n                  var track = item[0],\n                      receiver = item[1];\n                  stream.id === item[2].id && fireAddTrack(pc, track, receiver, [stream]);\n                });\n              }\n            }), receiverList.forEach(function (item) {\n              item[2] || fireAddTrack(pc, item[0], item[1], []);\n            }), window.setTimeout(function () {\n              pc && pc.transceivers && pc.transceivers.forEach(function (transceiver) {\n                transceiver.iceTransport && \"new\" === transceiver.iceTransport.state && transceiver.iceTransport.getRemoteCandidates().length > 0 && (console.warn(\"Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification\"), transceiver.iceTransport.addRemoteCandidate({}));\n              });\n            }, 4e3), Promise.resolve();\n          }, RTCPeerConnection.prototype.close = function () {\n            this.transceivers.forEach(function (transceiver) {\n              transceiver.iceTransport && transceiver.iceTransport.stop(), transceiver.dtlsTransport && transceiver.dtlsTransport.stop(), transceiver.rtpSender && transceiver.rtpSender.stop(), transceiver.rtpReceiver && transceiver.rtpReceiver.stop();\n            }), this._isClosed = !0, this._updateSignalingState(\"closed\");\n          }, RTCPeerConnection.prototype._updateSignalingState = function (newState) {\n            this.signalingState = newState;\n            var event = new Event(\"signalingstatechange\");\n\n            this._dispatchEvent(\"signalingstatechange\", event);\n          }, RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function () {\n            var pc = this;\n            \"stable\" === this.signalingState && !0 !== this.needNegotiation && (this.needNegotiation = !0, window.setTimeout(function () {\n              if (pc.needNegotiation) {\n                pc.needNegotiation = !1;\n                var event = new Event(\"negotiationneeded\");\n\n                pc._dispatchEvent(\"negotiationneeded\", event);\n              }\n            }, 0));\n          }, RTCPeerConnection.prototype._updateIceConnectionState = function () {\n            var newState,\n                states = {\n              new: 0,\n              closed: 0,\n              checking: 0,\n              connected: 0,\n              completed: 0,\n              disconnected: 0,\n              failed: 0\n            };\n\n            if (this.transceivers.forEach(function (transceiver) {\n              states[transceiver.iceTransport.state]++;\n            }), newState = \"new\", states.failed > 0 ? newState = \"failed\" : states.checking > 0 ? newState = \"checking\" : states.disconnected > 0 ? newState = \"disconnected\" : states.new > 0 ? newState = \"new\" : states.connected > 0 ? newState = \"connected\" : states.completed > 0 && (newState = \"completed\"), newState !== this.iceConnectionState) {\n              this.iceConnectionState = newState;\n              var event = new Event(\"iceconnectionstatechange\");\n\n              this._dispatchEvent(\"iceconnectionstatechange\", event);\n            }\n          }, RTCPeerConnection.prototype._updateConnectionState = function () {\n            var newState,\n                states = {\n              new: 0,\n              closed: 0,\n              connecting: 0,\n              connected: 0,\n              completed: 0,\n              disconnected: 0,\n              failed: 0\n            };\n\n            if (this.transceivers.forEach(function (transceiver) {\n              states[transceiver.iceTransport.state]++, states[transceiver.dtlsTransport.state]++;\n            }), states.connected += states.completed, newState = \"new\", states.failed > 0 ? newState = \"failed\" : states.connecting > 0 ? newState = \"connecting\" : states.disconnected > 0 ? newState = \"disconnected\" : states.new > 0 ? newState = \"new\" : states.connected > 0 && (newState = \"connected\"), newState !== this.connectionState) {\n              this.connectionState = newState;\n              var event = new Event(\"connectionstatechange\");\n\n              this._dispatchEvent(\"connectionstatechange\", event);\n            }\n          }, RTCPeerConnection.prototype.createOffer = function () {\n            var pc = this;\n            if (pc._isClosed) return Promise.reject(makeError(\"InvalidStateError\", \"Can not call createOffer after close\"));\n            var numAudioTracks = pc.transceivers.filter(function (t) {\n              return \"audio\" === t.kind;\n            }).length,\n                numVideoTracks = pc.transceivers.filter(function (t) {\n              return \"video\" === t.kind;\n            }).length,\n                offerOptions = arguments[0];\n\n            if (offerOptions) {\n              if (offerOptions.mandatory || offerOptions.optional) throw new TypeError(\"Legacy mandatory/optional constraints not supported.\");\n              void 0 !== offerOptions.offerToReceiveAudio && (numAudioTracks = !0 === offerOptions.offerToReceiveAudio ? 1 : !1 === offerOptions.offerToReceiveAudio ? 0 : offerOptions.offerToReceiveAudio), void 0 !== offerOptions.offerToReceiveVideo && (numVideoTracks = !0 === offerOptions.offerToReceiveVideo ? 1 : !1 === offerOptions.offerToReceiveVideo ? 0 : offerOptions.offerToReceiveVideo);\n            }\n\n            for (pc.transceivers.forEach(function (transceiver) {\n              \"audio\" === transceiver.kind ? --numAudioTracks < 0 && (transceiver.wantReceive = !1) : \"video\" === transceiver.kind && --numVideoTracks < 0 && (transceiver.wantReceive = !1);\n            }); numAudioTracks > 0 || numVideoTracks > 0;) {\n              numAudioTracks > 0 && (pc._createTransceiver(\"audio\"), numAudioTracks--), numVideoTracks > 0 && (pc._createTransceiver(\"video\"), numVideoTracks--);\n            }\n\n            var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId, pc._sdpSessionVersion++);\n            pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {\n              var track = transceiver.track,\n                  kind = transceiver.kind,\n                  mid = transceiver.mid || SDPUtils.generateIdentifier();\n              transceiver.mid = mid, transceiver.iceGatherer || (transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex, pc.usingBundle));\n              var localCapabilities = window.RTCRtpSender.getCapabilities(kind);\n              edgeVersion < 15019 && (localCapabilities.codecs = localCapabilities.codecs.filter(function (codec) {\n                return \"rtx\" !== codec.name;\n              })), localCapabilities.codecs.forEach(function (codec) {\n                \"H264\" === codec.name && void 0 === codec.parameters[\"level-asymmetry-allowed\"] && (codec.parameters[\"level-asymmetry-allowed\"] = \"1\"), transceiver.remoteCapabilities && transceiver.remoteCapabilities.codecs && transceiver.remoteCapabilities.codecs.forEach(function (remoteCodec) {\n                  codec.name.toLowerCase() === remoteCodec.name.toLowerCase() && codec.clockRate === remoteCodec.clockRate && (codec.preferredPayloadType = remoteCodec.payloadType);\n                });\n              }), localCapabilities.headerExtensions.forEach(function (hdrExt) {\n                (transceiver.remoteCapabilities && transceiver.remoteCapabilities.headerExtensions || []).forEach(function (rHdrExt) {\n                  hdrExt.uri === rHdrExt.uri && (hdrExt.id = rHdrExt.id);\n                });\n              });\n              var sendEncodingParameters = transceiver.sendEncodingParameters || [{\n                ssrc: 1001 * (2 * sdpMLineIndex + 1)\n              }];\n              track && edgeVersion >= 15019 && \"video\" === kind && !sendEncodingParameters[0].rtx && (sendEncodingParameters[0].rtx = {\n                ssrc: sendEncodingParameters[0].ssrc + 1\n              }), transceiver.wantReceive && (transceiver.rtpReceiver = new window.RTCRtpReceiver(transceiver.dtlsTransport, kind)), transceiver.localCapabilities = localCapabilities, transceiver.sendEncodingParameters = sendEncodingParameters;\n            }), \"max-compat\" !== pc._config.bundlePolicy && (sdp += \"a=group:BUNDLE \" + pc.transceivers.map(function (t) {\n              return t.mid;\n            }).join(\" \") + \"\\r\\n\"), sdp += \"a=ice-options:trickle\\r\\n\", pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {\n              sdp += writeMediaSection(transceiver, transceiver.localCapabilities, \"offer\", transceiver.stream, pc._dtlsRole), sdp += \"a=rtcp-rsize\\r\\n\", !transceiver.iceGatherer || \"new\" === pc.iceGatheringState || 0 !== sdpMLineIndex && pc.usingBundle || (transceiver.iceGatherer.getLocalCandidates().forEach(function (cand) {\n                cand.component = 1, sdp += \"a=\" + SDPUtils.writeCandidate(cand) + \"\\r\\n\";\n              }), \"completed\" === transceiver.iceGatherer.state && (sdp += \"a=end-of-candidates\\r\\n\"));\n            });\n            var desc = new window.RTCSessionDescription({\n              type: \"offer\",\n              sdp: sdp\n            });\n            return Promise.resolve(desc);\n          }, RTCPeerConnection.prototype.createAnswer = function () {\n            var pc = this;\n            if (pc._isClosed) return Promise.reject(makeError(\"InvalidStateError\", \"Can not call createAnswer after close\"));\n            if (\"have-remote-offer\" !== pc.signalingState && \"have-local-pranswer\" !== pc.signalingState) return Promise.reject(makeError(\"InvalidStateError\", \"Can not call createAnswer in signalingState \" + pc.signalingState));\n            var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId, pc._sdpSessionVersion++);\n            pc.usingBundle && (sdp += \"a=group:BUNDLE \" + pc.transceivers.map(function (t) {\n              return t.mid;\n            }).join(\" \") + \"\\r\\n\");\n            var mediaSectionsInOffer = SDPUtils.getMediaSections(pc._remoteDescription.sdp).length;\n            pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {\n              if (!(sdpMLineIndex + 1 > mediaSectionsInOffer)) {\n                if (transceiver.rejected) return \"application\" === transceiver.kind ? \"DTLS/SCTP\" === transceiver.protocol ? sdp += \"m=application 0 DTLS/SCTP 5000\\r\\n\" : sdp += \"m=application 0 \" + transceiver.protocol + \" webrtc-datachannel\\r\\n\" : \"audio\" === transceiver.kind ? sdp += \"m=audio 0 UDP/TLS/RTP/SAVPF 0\\r\\na=rtpmap:0 PCMU/8000\\r\\n\" : \"video\" === transceiver.kind && (sdp += \"m=video 0 UDP/TLS/RTP/SAVPF 120\\r\\na=rtpmap:120 VP8/90000\\r\\n\"), void (sdp += \"c=IN IP4 0.0.0.0\\r\\na=inactive\\r\\na=mid:\" + transceiver.mid + \"\\r\\n\");\n\n                if (transceiver.stream) {\n                  var localTrack;\n                  \"audio\" === transceiver.kind ? localTrack = transceiver.stream.getAudioTracks()[0] : \"video\" === transceiver.kind && (localTrack = transceiver.stream.getVideoTracks()[0]), localTrack && edgeVersion >= 15019 && \"video\" === transceiver.kind && !transceiver.sendEncodingParameters[0].rtx && (transceiver.sendEncodingParameters[0].rtx = {\n                    ssrc: transceiver.sendEncodingParameters[0].ssrc + 1\n                  });\n                }\n\n                var commonCapabilities = getCommonCapabilities(transceiver.localCapabilities, transceiver.remoteCapabilities);\n                !commonCapabilities.codecs.filter(function (c) {\n                  return \"rtx\" === c.name.toLowerCase();\n                }).length && transceiver.sendEncodingParameters[0].rtx && delete transceiver.sendEncodingParameters[0].rtx, sdp += writeMediaSection(transceiver, commonCapabilities, \"answer\", transceiver.stream, pc._dtlsRole), transceiver.rtcpParameters && transceiver.rtcpParameters.reducedSize && (sdp += \"a=rtcp-rsize\\r\\n\");\n              }\n            });\n            var desc = new window.RTCSessionDescription({\n              type: \"answer\",\n              sdp: sdp\n            });\n            return Promise.resolve(desc);\n          }, RTCPeerConnection.prototype.addIceCandidate = function (candidate) {\n            var sections,\n                pc = this;\n            return candidate && void 0 === candidate.sdpMLineIndex && !candidate.sdpMid ? Promise.reject(new TypeError(\"sdpMLineIndex or sdpMid required\")) : new Promise(function (resolve, reject) {\n              if (!pc._remoteDescription) return reject(makeError(\"InvalidStateError\", \"Can not add ICE candidate without a remote description\"));\n\n              if (candidate && \"\" !== candidate.candidate) {\n                var sdpMLineIndex = candidate.sdpMLineIndex;\n                if (candidate.sdpMid) for (var i = 0; i < pc.transceivers.length; i++) {\n                  if (pc.transceivers[i].mid === candidate.sdpMid) {\n                    sdpMLineIndex = i;\n                    break;\n                  }\n                }\n                var transceiver = pc.transceivers[sdpMLineIndex];\n                if (!transceiver) return reject(makeError(\"OperationError\", \"Can not add ICE candidate\"));\n                if (transceiver.rejected) return resolve();\n                var cand = Object.keys(candidate.candidate).length > 0 ? SDPUtils.parseCandidate(candidate.candidate) : {};\n                if (\"tcp\" === cand.protocol && (0 === cand.port || 9 === cand.port)) return resolve();\n                if (cand.component && 1 !== cand.component) return resolve();\n                if ((0 === sdpMLineIndex || sdpMLineIndex > 0 && transceiver.iceTransport !== pc.transceivers[0].iceTransport) && !maybeAddCandidate(transceiver.iceTransport, cand)) return reject(makeError(\"OperationError\", \"Can not add ICE candidate\"));\n                var candidateString = candidate.candidate.trim();\n                0 === candidateString.indexOf(\"a=\") && (candidateString = candidateString.substr(2)), sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp), sections[sdpMLineIndex] += \"a=\" + (cand.type ? candidateString : \"end-of-candidates\") + \"\\r\\n\", pc._remoteDescription.sdp = SDPUtils.getDescription(pc._remoteDescription.sdp) + sections.join(\"\");\n              } else for (var j = 0; j < pc.transceivers.length && (pc.transceivers[j].rejected || (pc.transceivers[j].iceTransport.addRemoteCandidate({}), sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp), sections[j] += \"a=end-of-candidates\\r\\n\", pc._remoteDescription.sdp = SDPUtils.getDescription(pc._remoteDescription.sdp) + sections.join(\"\"), !pc.usingBundle)); j++) {\n                ;\n              }\n\n              resolve();\n            });\n          }, RTCPeerConnection.prototype.getStats = function (selector) {\n            if (selector && selector instanceof window.MediaStreamTrack) {\n              var senderOrReceiver = null;\n              if (this.transceivers.forEach(function (transceiver) {\n                transceiver.rtpSender && transceiver.rtpSender.track === selector ? senderOrReceiver = transceiver.rtpSender : transceiver.rtpReceiver && transceiver.rtpReceiver.track === selector && (senderOrReceiver = transceiver.rtpReceiver);\n              }), !senderOrReceiver) throw makeError(\"InvalidAccessError\", \"Invalid selector.\");\n              return senderOrReceiver.getStats();\n            }\n\n            var promises = [];\n            return this.transceivers.forEach(function (transceiver) {\n              [\"rtpSender\", \"rtpReceiver\", \"iceGatherer\", \"iceTransport\", \"dtlsTransport\"].forEach(function (method) {\n                transceiver[method] && promises.push(transceiver[method].getStats());\n              });\n            }), Promise.all(promises).then(function (allStats) {\n              var results = new Map();\n              return allStats.forEach(function (stats) {\n                stats.forEach(function (stat) {\n                  results.set(stat.id, stat);\n                });\n              }), results;\n            });\n          }, [\"RTCRtpSender\", \"RTCRtpReceiver\", \"RTCIceGatherer\", \"RTCIceTransport\", \"RTCDtlsTransport\"].forEach(function (ortcObjectName) {\n            var obj = window[ortcObjectName];\n\n            if (obj && obj.prototype && obj.prototype.getStats) {\n              var nativeGetstats = obj.prototype.getStats;\n\n              obj.prototype.getStats = function () {\n                return nativeGetstats.apply(this).then(function (nativeStats) {\n                  var mapStats = new Map();\n                  return Object.keys(nativeStats).forEach(function (id) {\n                    nativeStats[id].type = fixStatsType(nativeStats[id]), mapStats.set(id, nativeStats[id]);\n                  }), mapStats;\n                });\n              };\n            }\n          });\n          var methods = [\"createOffer\", \"createAnswer\"];\n          return methods.forEach(function (method) {\n            var nativeMethod = RTCPeerConnection.prototype[method];\n\n            RTCPeerConnection.prototype[method] = function () {\n              var args = arguments;\n              return \"function\" == typeof args[0] || \"function\" == typeof args[1] ? nativeMethod.apply(this, [arguments[2]]).then(function (description) {\n                \"function\" == typeof args[0] && args[0].apply(null, [description]);\n              }, function (error) {\n                \"function\" == typeof args[1] && args[1].apply(null, [error]);\n              }) : nativeMethod.apply(this, arguments);\n            };\n          }), methods = [\"setLocalDescription\", \"setRemoteDescription\", \"addIceCandidate\"], methods.forEach(function (method) {\n            var nativeMethod = RTCPeerConnection.prototype[method];\n\n            RTCPeerConnection.prototype[method] = function () {\n              var args = arguments;\n              return \"function\" == typeof args[1] || \"function\" == typeof args[2] ? nativeMethod.apply(this, arguments).then(function () {\n                \"function\" == typeof args[1] && args[1].apply(null);\n              }, function (error) {\n                \"function\" == typeof args[2] && args[2].apply(null, [error]);\n              }) : nativeMethod.apply(this, arguments);\n            };\n          }), [\"getStats\"].forEach(function (method) {\n            var nativeMethod = RTCPeerConnection.prototype[method];\n\n            RTCPeerConnection.prototype[method] = function () {\n              var args = arguments;\n              return \"function\" == typeof args[1] ? nativeMethod.apply(this, arguments).then(function () {\n                \"function\" == typeof args[1] && args[1].apply(null);\n              }) : nativeMethod.apply(this, arguments);\n            };\n          }), RTCPeerConnection;\n        };\n      }, {\n        sdp: 2\n      }],\n      2: [function (requirecopy, module, exports) {\n        \"use strict\";\n\n        var SDPUtils = {};\n        SDPUtils.generateIdentifier = function () {\n          return Math.random().toString(36).substr(2, 10);\n        }, SDPUtils.localCName = SDPUtils.generateIdentifier(), SDPUtils.splitLines = function (blob) {\n          return blob.trim().split(\"\\n\").map(function (line) {\n            return line.trim();\n          });\n        }, SDPUtils.splitSections = function (blob) {\n          return blob.split(\"\\nm=\").map(function (part, index) {\n            return (index > 0 ? \"m=\" + part : part).trim() + \"\\r\\n\";\n          });\n        }, SDPUtils.getDescription = function (blob) {\n          var sections = SDPUtils.splitSections(blob);\n          return sections && sections[0];\n        }, SDPUtils.getMediaSections = function (blob) {\n          var sections = SDPUtils.splitSections(blob);\n          return sections.shift(), sections;\n        }, SDPUtils.matchPrefix = function (blob, prefix) {\n          return SDPUtils.splitLines(blob).filter(function (line) {\n            return 0 === line.indexOf(prefix);\n          });\n        }, SDPUtils.parseCandidate = function (line) {\n          var parts;\n          parts = 0 === line.indexOf(\"a=candidate:\") ? line.substring(12).split(\" \") : line.substring(10).split(\" \");\n\n          for (var candidate = {\n            foundation: parts[0],\n            component: parseInt(parts[1], 10),\n            protocol: parts[2].toLowerCase(),\n            priority: parseInt(parts[3], 10),\n            ip: parts[4],\n            port: parseInt(parts[5], 10),\n            type: parts[7]\n          }, i = 8; i < parts.length; i += 2) {\n            switch (parts[i]) {\n              case \"raddr\":\n                candidate.relatedAddress = parts[i + 1];\n                break;\n\n              case \"rport\":\n                candidate.relatedPort = parseInt(parts[i + 1], 10);\n                break;\n\n              case \"tcptype\":\n                candidate.tcpType = parts[i + 1];\n                break;\n\n              case \"ufrag\":\n                candidate.ufrag = parts[i + 1], candidate.usernameFragment = parts[i + 1];\n                break;\n\n              default:\n                candidate[parts[i]] = parts[i + 1];\n            }\n          }\n\n          return candidate;\n        }, SDPUtils.writeCandidate = function (candidate) {\n          var sdp = [];\n          sdp.push(candidate.foundation), sdp.push(candidate.component), sdp.push(candidate.protocol.toUpperCase()), sdp.push(candidate.priority), sdp.push(candidate.ip), sdp.push(candidate.port);\n          var type = candidate.type;\n          return sdp.push(\"typ\"), sdp.push(type), \"host\" !== type && candidate.relatedAddress && candidate.relatedPort && (sdp.push(\"raddr\"), sdp.push(candidate.relatedAddress), sdp.push(\"rport\"), sdp.push(candidate.relatedPort)), candidate.tcpType && \"tcp\" === candidate.protocol.toLowerCase() && (sdp.push(\"tcptype\"), sdp.push(candidate.tcpType)), (candidate.usernameFragment || candidate.ufrag) && (sdp.push(\"ufrag\"), sdp.push(candidate.usernameFragment || candidate.ufrag)), \"candidate:\" + sdp.join(\" \");\n        }, SDPUtils.parseIceOptions = function (line) {\n          return line.substr(14).split(\" \");\n        }, SDPUtils.parseRtpMap = function (line) {\n          var parts = line.substr(9).split(\" \"),\n              parsed = {\n            payloadType: parseInt(parts.shift(), 10)\n          };\n          return parts = parts[0].split(\"/\"), parsed.name = parts[0], parsed.clockRate = parseInt(parts[1], 10), parsed.channels = 3 === parts.length ? parseInt(parts[2], 10) : 1, parsed.numChannels = parsed.channels, parsed;\n        }, SDPUtils.writeRtpMap = function (codec) {\n          var pt = codec.payloadType;\n          void 0 !== codec.preferredPayloadType && (pt = codec.preferredPayloadType);\n          var channels = codec.channels || codec.numChannels || 1;\n          return \"a=rtpmap:\" + pt + \" \" + codec.name + \"/\" + codec.clockRate + (1 !== channels ? \"/\" + channels : \"\") + \"\\r\\n\";\n        }, SDPUtils.parseExtmap = function (line) {\n          var parts = line.substr(9).split(\" \");\n          return {\n            id: parseInt(parts[0], 10),\n            direction: parts[0].indexOf(\"/\") > 0 ? parts[0].split(\"/\")[1] : \"sendrecv\",\n            uri: parts[1]\n          };\n        }, SDPUtils.writeExtmap = function (headerExtension) {\n          return \"a=extmap:\" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && \"sendrecv\" !== headerExtension.direction ? \"/\" + headerExtension.direction : \"\") + \" \" + headerExtension.uri + \"\\r\\n\";\n        }, SDPUtils.parseFmtp = function (line) {\n          for (var kv, parsed = {}, parts = line.substr(line.indexOf(\" \") + 1).split(\";\"), j = 0; j < parts.length; j++) {\n            kv = parts[j].trim().split(\"=\"), parsed[kv[0].trim()] = kv[1];\n          }\n\n          return parsed;\n        }, SDPUtils.writeFmtp = function (codec) {\n          var line = \"\",\n              pt = codec.payloadType;\n\n          if (void 0 !== codec.preferredPayloadType && (pt = codec.preferredPayloadType), codec.parameters && Object.keys(codec.parameters).length) {\n            var params = [];\n            Object.keys(codec.parameters).forEach(function (param) {\n              codec.parameters[param] ? params.push(param + \"=\" + codec.parameters[param]) : params.push(param);\n            }), line += \"a=fmtp:\" + pt + \" \" + params.join(\";\") + \"\\r\\n\";\n          }\n\n          return line;\n        }, SDPUtils.parseRtcpFb = function (line) {\n          var parts = line.substr(line.indexOf(\" \") + 1).split(\" \");\n          return {\n            type: parts.shift(),\n            parameter: parts.join(\" \")\n          };\n        }, SDPUtils.writeRtcpFb = function (codec) {\n          var lines = \"\",\n              pt = codec.payloadType;\n          return void 0 !== codec.preferredPayloadType && (pt = codec.preferredPayloadType), codec.rtcpFeedback && codec.rtcpFeedback.length && codec.rtcpFeedback.forEach(function (fb) {\n            lines += \"a=rtcp-fb:\" + pt + \" \" + fb.type + (fb.parameter && fb.parameter.length ? \" \" + fb.parameter : \"\") + \"\\r\\n\";\n          }), lines;\n        }, SDPUtils.parseSsrcMedia = function (line) {\n          var sp = line.indexOf(\" \"),\n              parts = {\n            ssrc: parseInt(line.substr(7, sp - 7), 10)\n          },\n              colon = line.indexOf(\":\", sp);\n          return colon > -1 ? (parts.attribute = line.substr(sp + 1, colon - sp - 1), parts.value = line.substr(colon + 1)) : parts.attribute = line.substr(sp + 1), parts;\n        }, SDPUtils.parseSsrcGroup = function (line) {\n          var parts = line.substr(13).split(\" \");\n          return {\n            semantics: parts.shift(),\n            ssrcs: parts.map(function (ssrc) {\n              return parseInt(ssrc, 10);\n            })\n          };\n        }, SDPUtils.getMid = function (mediaSection) {\n          var mid = SDPUtils.matchPrefix(mediaSection, \"a=mid:\")[0];\n          if (mid) return mid.substr(6);\n        }, SDPUtils.parseFingerprint = function (line) {\n          var parts = line.substr(14).split(\" \");\n          return {\n            algorithm: parts[0].toLowerCase(),\n            value: parts[1]\n          };\n        }, SDPUtils.getDtlsParameters = function (mediaSection, sessionpart) {\n          return {\n            role: \"auto\",\n            fingerprints: SDPUtils.matchPrefix(mediaSection + sessionpart, \"a=fingerprint:\").map(SDPUtils.parseFingerprint)\n          };\n        }, SDPUtils.writeDtlsParameters = function (params, setupType) {\n          var sdp = \"a=setup:\" + setupType + \"\\r\\n\";\n          return params.fingerprints.forEach(function (fp) {\n            sdp += \"a=fingerprint:\" + fp.algorithm + \" \" + fp.value + \"\\r\\n\";\n          }), sdp;\n        }, SDPUtils.getIceParameters = function (mediaSection, sessionpart) {\n          var lines = SDPUtils.splitLines(mediaSection);\n          return lines = lines.concat(SDPUtils.splitLines(sessionpart)), {\n            usernameFragment: lines.filter(function (line) {\n              return 0 === line.indexOf(\"a=ice-ufrag:\");\n            })[0].substr(12),\n            password: lines.filter(function (line) {\n              return 0 === line.indexOf(\"a=ice-pwd:\");\n            })[0].substr(10)\n          };\n        }, SDPUtils.writeIceParameters = function (params) {\n          return \"a=ice-ufrag:\" + params.usernameFragment + \"\\r\\na=ice-pwd:\" + params.password + \"\\r\\n\";\n        }, SDPUtils.parseRtpParameters = function (mediaSection) {\n          for (var description = {\n            codecs: [],\n            headerExtensions: [],\n            fecMechanisms: [],\n            rtcp: []\n          }, lines = SDPUtils.splitLines(mediaSection), mline = lines[0].split(\" \"), i = 3; i < mline.length; i++) {\n            var pt = mline[i],\n                rtpmapline = SDPUtils.matchPrefix(mediaSection, \"a=rtpmap:\" + pt + \" \")[0];\n\n            if (rtpmapline) {\n              var codec = SDPUtils.parseRtpMap(rtpmapline),\n                  fmtps = SDPUtils.matchPrefix(mediaSection, \"a=fmtp:\" + pt + \" \");\n\n              switch (codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {}, codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-fb:\" + pt + \" \").map(SDPUtils.parseRtcpFb), description.codecs.push(codec), codec.name.toUpperCase()) {\n                case \"RED\":\n                case \"ULPFEC\":\n                  description.fecMechanisms.push(codec.name.toUpperCase());\n              }\n            }\n          }\n\n          return SDPUtils.matchPrefix(mediaSection, \"a=extmap:\").forEach(function (line) {\n            description.headerExtensions.push(SDPUtils.parseExtmap(line));\n          }), description;\n        }, SDPUtils.writeRtpDescription = function (kind, caps) {\n          var sdp = \"\";\n          sdp += \"m=\" + kind + \" \", sdp += caps.codecs.length > 0 ? \"9\" : \"0\", sdp += \" UDP/TLS/RTP/SAVPF \", sdp += caps.codecs.map(function (codec) {\n            return void 0 !== codec.preferredPayloadType ? codec.preferredPayloadType : codec.payloadType;\n          }).join(\" \") + \"\\r\\n\", sdp += \"c=IN IP4 0.0.0.0\\r\\n\", sdp += \"a=rtcp:9 IN IP4 0.0.0.0\\r\\n\", caps.codecs.forEach(function (codec) {\n            sdp += SDPUtils.writeRtpMap(codec), sdp += SDPUtils.writeFmtp(codec), sdp += SDPUtils.writeRtcpFb(codec);\n          });\n          var maxptime = 0;\n          return caps.codecs.forEach(function (codec) {\n            codec.maxptime > maxptime && (maxptime = codec.maxptime);\n          }), maxptime > 0 && (sdp += \"a=maxptime:\" + maxptime + \"\\r\\n\"), sdp += \"a=rtcp-mux\\r\\n\", caps.headerExtensions && caps.headerExtensions.forEach(function (extension) {\n            sdp += SDPUtils.writeExtmap(extension);\n          }), sdp;\n        }, SDPUtils.parseRtpEncodingParameters = function (mediaSection) {\n          var secondarySsrc,\n              encodingParameters = [],\n              description = SDPUtils.parseRtpParameters(mediaSection),\n              hasRed = -1 !== description.fecMechanisms.indexOf(\"RED\"),\n              hasUlpfec = -1 !== description.fecMechanisms.indexOf(\"ULPFEC\"),\n              ssrcs = SDPUtils.matchPrefix(mediaSection, \"a=ssrc:\").map(function (line) {\n            return SDPUtils.parseSsrcMedia(line);\n          }).filter(function (parts) {\n            return \"cname\" === parts.attribute;\n          }),\n              primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc,\n              flows = SDPUtils.matchPrefix(mediaSection, \"a=ssrc-group:FID\").map(function (line) {\n            return line.substr(17).split(\" \").map(function (part) {\n              return parseInt(part, 10);\n            });\n          });\n          flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc && (secondarySsrc = flows[0][1]), description.codecs.forEach(function (codec) {\n            if (\"RTX\" === codec.name.toUpperCase() && codec.parameters.apt) {\n              var encParam = {\n                ssrc: primarySsrc,\n                codecPayloadType: parseInt(codec.parameters.apt, 10)\n              };\n              primarySsrc && secondarySsrc && (encParam.rtx = {\n                ssrc: secondarySsrc\n              }), encodingParameters.push(encParam), hasRed && (encParam = JSON.parse(JSON.stringify(encParam)), encParam.fec = {\n                ssrc: secondarySsrc,\n                mechanism: hasUlpfec ? \"red+ulpfec\" : \"red\"\n              }, encodingParameters.push(encParam));\n            }\n          }), 0 === encodingParameters.length && primarySsrc && encodingParameters.push({\n            ssrc: primarySsrc\n          });\n          var bandwidth = SDPUtils.matchPrefix(mediaSection, \"b=\");\n          return bandwidth.length && (bandwidth = 0 === bandwidth[0].indexOf(\"b=TIAS:\") ? parseInt(bandwidth[0].substr(7), 10) : 0 === bandwidth[0].indexOf(\"b=AS:\") ? 1e3 * parseInt(bandwidth[0].substr(5), 10) * .95 - 16e3 : void 0, encodingParameters.forEach(function (params) {\n            params.maxBitrate = bandwidth;\n          })), encodingParameters;\n        }, SDPUtils.parseRtcpParameters = function (mediaSection) {\n          var rtcpParameters = {},\n              remoteSsrc = SDPUtils.matchPrefix(mediaSection, \"a=ssrc:\").map(function (line) {\n            return SDPUtils.parseSsrcMedia(line);\n          }).filter(function (obj) {\n            return \"cname\" === obj.attribute;\n          })[0];\n          remoteSsrc && (rtcpParameters.cname = remoteSsrc.value, rtcpParameters.ssrc = remoteSsrc.ssrc);\n          var rsize = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-rsize\");\n          rtcpParameters.reducedSize = rsize.length > 0, rtcpParameters.compound = 0 === rsize.length;\n          var mux = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-mux\");\n          return rtcpParameters.mux = mux.length > 0, rtcpParameters;\n        }, SDPUtils.parseMsid = function (mediaSection) {\n          var parts,\n              spec = SDPUtils.matchPrefix(mediaSection, \"a=msid:\");\n          if (1 === spec.length) return parts = spec[0].substr(7).split(\" \"), {\n            stream: parts[0],\n            track: parts[1]\n          };\n          var planB = SDPUtils.matchPrefix(mediaSection, \"a=ssrc:\").map(function (line) {\n            return SDPUtils.parseSsrcMedia(line);\n          }).filter(function (msidParts) {\n            return \"msid\" === msidParts.attribute;\n          });\n          return planB.length > 0 ? (parts = planB[0].value.split(\" \"), {\n            stream: parts[0],\n            track: parts[1]\n          }) : void 0;\n        }, SDPUtils.generateSessionId = function () {\n          return Math.random().toString().substr(2, 21);\n        }, SDPUtils.writeSessionBoilerplate = function (sessId, sessVer) {\n          var version = void 0 !== sessVer ? sessVer : 2;\n          return \"v=0\\r\\no=thisisadapterortc \" + (sessId || SDPUtils.generateSessionId()) + \" \" + version + \" IN IP4 127.0.0.1\\r\\ns=-\\r\\nt=0 0\\r\\n\";\n        }, SDPUtils.writeMediaSection = function (transceiver, caps, type, stream) {\n          var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\n          if (sdp += SDPUtils.writeIceParameters(transceiver.iceGatherer.getLocalParameters()), sdp += SDPUtils.writeDtlsParameters(transceiver.dtlsTransport.getLocalParameters(), \"offer\" === type ? \"actpass\" : \"active\"), sdp += \"a=mid:\" + transceiver.mid + \"\\r\\n\", transceiver.direction ? sdp += \"a=\" + transceiver.direction + \"\\r\\n\" : transceiver.rtpSender && transceiver.rtpReceiver ? sdp += \"a=sendrecv\\r\\n\" : transceiver.rtpSender ? sdp += \"a=sendonly\\r\\n\" : transceiver.rtpReceiver ? sdp += \"a=recvonly\\r\\n\" : sdp += \"a=inactive\\r\\n\", transceiver.rtpSender) {\n            var msid = \"msid:\" + stream.id + \" \" + transceiver.rtpSender.track.id + \"\\r\\n\";\n            sdp += \"a=\" + msid, sdp += \"a=ssrc:\" + transceiver.sendEncodingParameters[0].ssrc + \" \" + msid, transceiver.sendEncodingParameters[0].rtx && (sdp += \"a=ssrc:\" + transceiver.sendEncodingParameters[0].rtx.ssrc + \" \" + msid, sdp += \"a=ssrc-group:FID \" + transceiver.sendEncodingParameters[0].ssrc + \" \" + transceiver.sendEncodingParameters[0].rtx.ssrc + \"\\r\\n\");\n          }\n\n          return sdp += \"a=ssrc:\" + transceiver.sendEncodingParameters[0].ssrc + \" cname:\" + SDPUtils.localCName + \"\\r\\n\", transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx && (sdp += \"a=ssrc:\" + transceiver.sendEncodingParameters[0].rtx.ssrc + \" cname:\" + SDPUtils.localCName + \"\\r\\n\"), sdp;\n        }, SDPUtils.getDirection = function (mediaSection, sessionpart) {\n          for (var lines = SDPUtils.splitLines(mediaSection), i = 0; i < lines.length; i++) {\n            switch (lines[i]) {\n              case \"a=sendrecv\":\n              case \"a=sendonly\":\n              case \"a=recvonly\":\n              case \"a=inactive\":\n                return lines[i].substr(2);\n            }\n          }\n\n          return sessionpart ? SDPUtils.getDirection(sessionpart) : \"sendrecv\";\n        }, SDPUtils.getKind = function (mediaSection) {\n          return SDPUtils.splitLines(mediaSection)[0].split(\" \")[0].substr(2);\n        }, SDPUtils.isRejected = function (mediaSection) {\n          return \"0\" === mediaSection.split(\" \", 2)[1];\n        }, SDPUtils.parseMLine = function (mediaSection) {\n          var lines = SDPUtils.splitLines(mediaSection),\n              parts = lines[0].substr(2).split(\" \");\n          return {\n            kind: parts[0],\n            port: parseInt(parts[1], 10),\n            protocol: parts[2],\n            fmt: parts.slice(3).join(\" \")\n          };\n        }, SDPUtils.parseOLine = function (mediaSection) {\n          var line = SDPUtils.matchPrefix(mediaSection, \"o=\")[0],\n              parts = line.substr(2).split(\" \");\n          return {\n            username: parts[0],\n            sessionId: parts[1],\n            sessionVersion: parseInt(parts[2], 10),\n            netType: parts[3],\n            addressType: parts[4],\n            address: parts[5]\n          };\n        }, SDPUtils.isValidSDP = function (blob) {\n          if (\"string\" != typeof blob || 0 === blob.length) return !1;\n\n          for (var lines = SDPUtils.splitLines(blob), i = 0; i < lines.length; i++) {\n            if (lines[i].length < 2 || \"=\" !== lines[i].charAt(1)) return !1;\n          }\n\n          return !0;\n        }, \"object\" == typeof module && (module.exports = SDPUtils);\n      }, {}],\n      3: [function (requirecopy, module, exports) {\n        (function (global) {\n          \"use strict\";\n\n          var adapterFactory = requirecopy(\"./adapter_factory.js\");\n          module.exports = adapterFactory({\n            window: global.window\n          });\n        }).call(this, \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : {});\n      }, {\n        \"./adapter_factory.js\": 4\n      }],\n      4: [function (requirecopy, module, exports) {\n        \"use strict\";\n\n        var utils = requirecopy(\"./utils\");\n\n        module.exports = function (dependencies, opts) {\n          var window = dependencies && dependencies.window,\n              options = {\n            shimChrome: !0,\n            shimFirefox: !0,\n            shimEdge: !0,\n            shimSafari: !0\n          };\n\n          for (var key in opts) {\n            hasOwnProperty.call(opts, key) && (options[key] = opts[key]);\n          }\n\n          var logging = utils.log,\n              browserDetails = utils.detectBrowser(window),\n              chromeShim = requirecopy(\"./chrome/chrome_shim\") || null,\n              edgeShim = requirecopy(\"./edge/edge_shim\") || null,\n              firefoxShim = requirecopy(\"./firefox/firefox_shim\") || null,\n              safariShim = requirecopy(\"./safari/safari_shim\") || null,\n              commonShim = requirecopy(\"./common_shim\") || null,\n              adapter = {\n            browserDetails: browserDetails,\n            commonShim: commonShim,\n            extractVersion: utils.extractVersion,\n            disableLog: utils.disableLog,\n            disableWarnings: utils.disableWarnings\n          };\n\n          switch (browserDetails.browser) {\n            case \"chrome\":\n              if (!chromeShim || !chromeShim.shimPeerConnection || !options.shimChrome) return logging(\"Chrome shim is not included in this adapter release.\"), adapter;\n              logging(\"adapter.js shimming chrome.\"), adapter.browserShim = chromeShim, commonShim.shimCreateObjectURL(window), chromeShim.shimGetUserMedia(window), chromeShim.shimMediaStream(window), chromeShim.shimSourceObject(window), chromeShim.shimPeerConnection(window), chromeShim.shimOnTrack(window), chromeShim.shimAddTrackRemoveTrack(window), chromeShim.shimGetSendersWithDtmf(window), chromeShim.shimSenderReceiverGetStats(window), chromeShim.fixNegotiationNeeded(window), commonShim.shimRTCIceCandidate(window), commonShim.shimMaxMessageSize(window), commonShim.shimSendThrowTypeError(window);\n              break;\n\n            case \"firefox\":\n              if (!firefoxShim || !firefoxShim.shimPeerConnection || !options.shimFirefox) return logging(\"Firefox shim is not included in this adapter release.\"), adapter;\n              logging(\"adapter.js shimming firefox.\"), adapter.browserShim = firefoxShim, commonShim.shimCreateObjectURL(window), firefoxShim.shimGetUserMedia(window), firefoxShim.shimSourceObject(window), firefoxShim.shimPeerConnection(window), firefoxShim.shimOnTrack(window), firefoxShim.shimRemoveStream(window), firefoxShim.shimSenderGetStats(window), firefoxShim.shimReceiverGetStats(window), firefoxShim.shimRTCDataChannel(window), commonShim.shimRTCIceCandidate(window), commonShim.shimMaxMessageSize(window), commonShim.shimSendThrowTypeError(window);\n              break;\n\n            case \"edge\":\n              if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) return logging(\"MS edge shim is not included in this adapter release.\"), adapter;\n              logging(\"adapter.js shimming edge.\"), adapter.browserShim = edgeShim, commonShim.shimCreateObjectURL(window), edgeShim.shimGetUserMedia(window), edgeShim.shimPeerConnection(window), edgeShim.shimReplaceTrack(window), commonShim.shimMaxMessageSize(window), commonShim.shimSendThrowTypeError(window);\n              break;\n\n            case \"safari\":\n              if (!safariShim || !options.shimSafari) return logging(\"Safari shim is not included in this adapter release.\"), adapter;\n              logging(\"adapter.js shimming safari.\"), adapter.browserShim = safariShim, commonShim.shimCreateObjectURL(window), safariShim.shimRTCIceServerUrls(window), safariShim.shimCreateOfferLegacy(window), safariShim.shimCallbacksAPI(window), safariShim.shimLocalStreamsAPI(window), safariShim.shimRemoteStreamsAPI(window), safariShim.shimTrackEventTransceiver(window), safariShim.shimGetUserMedia(window), commonShim.shimRTCIceCandidate(window), commonShim.shimMaxMessageSize(window), commonShim.shimSendThrowTypeError(window);\n              break;\n\n            default:\n              logging(\"Unsupported browser!\");\n          }\n\n          return adapter;\n        };\n      }, {\n        \"./chrome/chrome_shim\": 5,\n        \"./common_shim\": 7,\n        \"./edge/edge_shim\": 8,\n        \"./firefox/firefox_shim\": 11,\n        \"./safari/safari_shim\": 13,\n        \"./utils\": 14\n      }],\n      5: [function (requirecopy, module, exports) {\n        \"use strict\";\n\n        function walkStats(stats, base, resultSet) {\n          base && !resultSet.has(base.id) && (resultSet.set(base.id, base), Object.keys(base).forEach(function (name) {\n            name.endsWith(\"Id\") ? walkStats(stats, stats.get(base[name]), resultSet) : name.endsWith(\"Ids\") && base[name].forEach(function (id) {\n              walkStats(stats, stats.get(id), resultSet);\n            });\n          }));\n        }\n\n        function filterStats(result, track, outbound) {\n          var streamStatsType = outbound ? \"outbound-rtp\" : \"inbound-rtp\",\n              filteredResult = new Map();\n          if (null === track) return filteredResult;\n          var trackStats = [];\n          return result.forEach(function (value) {\n            \"track\" === value.type && value.trackIdentifier === track.id && trackStats.push(value);\n          }), trackStats.forEach(function (trackStat) {\n            result.forEach(function (stats) {\n              stats.type === streamStatsType && stats.trackId === trackStat.id && walkStats(result, stats, filteredResult);\n            });\n          }), filteredResult;\n        }\n\n        var utils = requirecopy(\"../utils.js\"),\n            logging = utils.log;\n        module.exports = {\n          shimGetUserMedia: requirecopy(\"./getusermedia\"),\n          shimMediaStream: function shimMediaStream(window) {\n            window.MediaStream = window.MediaStream || window.webkitMediaStream;\n          },\n          shimOnTrack: function shimOnTrack(window) {\n            if (\"object\" != typeof window || !window.RTCPeerConnection || \"ontrack\" in window.RTCPeerConnection.prototype) \"RTCRtpTransceiver\" in window || utils.wrapPeerConnectionEvent(window, \"track\", function (e) {\n              return e.transceiver || (e.transceiver = {\n                receiver: e.receiver\n              }), e;\n            });else {\n              Object.defineProperty(window.RTCPeerConnection.prototype, \"ontrack\", {\n                get: function get() {\n                  return this._ontrack;\n                },\n                set: function set(f) {\n                  this._ontrack && this.removeEventListener(\"track\", this._ontrack), this.addEventListener(\"track\", this._ontrack = f);\n                },\n                enumerable: !0,\n                configurable: !0\n              });\n              var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n\n              window.RTCPeerConnection.prototype.setRemoteDescription = function () {\n                var pc = this;\n                return pc._ontrackpoly || (pc._ontrackpoly = function (e) {\n                  e.stream.addEventListener(\"addtrack\", function (te) {\n                    var receiver;\n                    receiver = window.RTCPeerConnection.prototype.getReceivers ? pc.getReceivers().find(function (r) {\n                      return r.track && r.track.id === te.track.id;\n                    }) : {\n                      track: te.track\n                    };\n                    var event = new Event(\"track\");\n                    event.track = te.track, event.receiver = receiver, event.transceiver = {\n                      receiver: receiver\n                    }, event.streams = [e.stream], pc.dispatchEvent(event);\n                  }), e.stream.getTracks().forEach(function (track) {\n                    var receiver;\n                    receiver = window.RTCPeerConnection.prototype.getReceivers ? pc.getReceivers().find(function (r) {\n                      return r.track && r.track.id === track.id;\n                    }) : {\n                      track: track\n                    };\n                    var event = new Event(\"track\");\n                    event.track = track, event.receiver = receiver, event.transceiver = {\n                      receiver: receiver\n                    }, event.streams = [e.stream], pc.dispatchEvent(event);\n                  });\n                }, pc.addEventListener(\"addstream\", pc._ontrackpoly)), origSetRemoteDescription.apply(pc, arguments);\n              };\n            }\n          },\n          shimGetSendersWithDtmf: function shimGetSendersWithDtmf(window) {\n            if (\"object\" == typeof window && window.RTCPeerConnection && !(\"getSenders\" in window.RTCPeerConnection.prototype) && \"createDTMFSender\" in window.RTCPeerConnection.prototype) {\n              var shimSenderWithDtmf = function shimSenderWithDtmf(pc, track) {\n                return {\n                  track: track,\n\n                  get dtmf() {\n                    return void 0 === this._dtmf && (\"audio\" === track.kind ? this._dtmf = pc.createDTMFSender(track) : this._dtmf = null), this._dtmf;\n                  },\n\n                  _pc: pc\n                };\n              };\n\n              if (!window.RTCPeerConnection.prototype.getSenders) {\n                window.RTCPeerConnection.prototype.getSenders = function () {\n                  return this._senders = this._senders || [], this._senders.slice();\n                };\n\n                var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n\n                window.RTCPeerConnection.prototype.addTrack = function (track, stream) {\n                  var pc = this,\n                      sender = origAddTrack.apply(pc, arguments);\n                  return sender || (sender = shimSenderWithDtmf(pc, track), pc._senders.push(sender)), sender;\n                };\n\n                var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n\n                window.RTCPeerConnection.prototype.removeTrack = function (sender) {\n                  var pc = this;\n                  origRemoveTrack.apply(pc, arguments);\n\n                  var idx = pc._senders.indexOf(sender);\n\n                  -1 !== idx && pc._senders.splice(idx, 1);\n                };\n              }\n\n              var origAddStream = window.RTCPeerConnection.prototype.addStream;\n\n              window.RTCPeerConnection.prototype.addStream = function (stream) {\n                var pc = this;\n                pc._senders = pc._senders || [], origAddStream.apply(pc, [stream]), stream.getTracks().forEach(function (track) {\n                  pc._senders.push(shimSenderWithDtmf(pc, track));\n                });\n              };\n\n              var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n\n              window.RTCPeerConnection.prototype.removeStream = function (stream) {\n                var pc = this;\n                pc._senders = pc._senders || [], origRemoveStream.apply(pc, [stream]), stream.getTracks().forEach(function (track) {\n                  var sender = pc._senders.find(function (s) {\n                    return s.track === track;\n                  });\n\n                  sender && pc._senders.splice(pc._senders.indexOf(sender), 1);\n                });\n              };\n            } else if (\"object\" == typeof window && window.RTCPeerConnection && \"getSenders\" in window.RTCPeerConnection.prototype && \"createDTMFSender\" in window.RTCPeerConnection.prototype && window.RTCRtpSender && !(\"dtmf\" in window.RTCRtpSender.prototype)) {\n              var origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n              window.RTCPeerConnection.prototype.getSenders = function () {\n                var pc = this,\n                    senders = origGetSenders.apply(pc, []);\n                return senders.forEach(function (sender) {\n                  sender._pc = pc;\n                }), senders;\n              }, Object.defineProperty(window.RTCRtpSender.prototype, \"dtmf\", {\n                get: function get() {\n                  return void 0 === this._dtmf && (\"audio\" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;\n                }\n              });\n            }\n          },\n          shimSenderReceiverGetStats: function shimSenderReceiverGetStats(window) {\n            if (\"object\" == typeof window && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver) {\n              if (!(\"getStats\" in window.RTCRtpSender.prototype)) {\n                var origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n                origGetSenders && (window.RTCPeerConnection.prototype.getSenders = function () {\n                  var pc = this,\n                      senders = origGetSenders.apply(pc, []);\n                  return senders.forEach(function (sender) {\n                    sender._pc = pc;\n                  }), senders;\n                });\n                var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n                origAddTrack && (window.RTCPeerConnection.prototype.addTrack = function () {\n                  var sender = origAddTrack.apply(this, arguments);\n                  return sender._pc = this, sender;\n                }), window.RTCRtpSender.prototype.getStats = function () {\n                  var sender = this;\n                  return this._pc.getStats().then(function (result) {\n                    return filterStats(result, sender.track, !0);\n                  });\n                };\n              }\n\n              if (!(\"getStats\" in window.RTCRtpReceiver.prototype)) {\n                var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n                origGetReceivers && (window.RTCPeerConnection.prototype.getReceivers = function () {\n                  var pc = this,\n                      receivers = origGetReceivers.apply(pc, []);\n                  return receivers.forEach(function (receiver) {\n                    receiver._pc = pc;\n                  }), receivers;\n                }), utils.wrapPeerConnectionEvent(window, \"track\", function (e) {\n                  return e.receiver._pc = e.srcElement, e;\n                }), window.RTCRtpReceiver.prototype.getStats = function () {\n                  var receiver = this;\n                  return this._pc.getStats().then(function (result) {\n                    return filterStats(result, receiver.track, !1);\n                  });\n                };\n              }\n\n              if (\"getStats\" in window.RTCRtpSender.prototype && \"getStats\" in window.RTCRtpReceiver.prototype) {\n                var origGetStats = window.RTCPeerConnection.prototype.getStats;\n\n                window.RTCPeerConnection.prototype.getStats = function () {\n                  var pc = this;\n\n                  if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {\n                    var sender,\n                        receiver,\n                        err,\n                        track = arguments[0];\n                    return pc.getSenders().forEach(function (s) {\n                      s.track === track && (sender ? err = !0 : sender = s);\n                    }), pc.getReceivers().forEach(function (r) {\n                      return r.track === track && (receiver ? err = !0 : receiver = r), r.track === track;\n                    }), err || sender && receiver ? Promise.reject(new DOMException(\"There are more than one sender or receiver for the track.\", \"InvalidAccessError\")) : sender ? sender.getStats() : receiver ? receiver.getStats() : Promise.reject(new DOMException(\"There is no sender or receiver for the track.\", \"InvalidAccessError\"));\n                  }\n\n                  return origGetStats.apply(pc, arguments);\n                };\n              }\n            }\n          },\n          shimSourceObject: function shimSourceObject(window) {\n            var URL = window && window.URL;\n            \"object\" == typeof window && (!window.HTMLMediaElement || \"srcObject\" in window.HTMLMediaElement.prototype || Object.defineProperty(window.HTMLMediaElement.prototype, \"srcObject\", {\n              get: function get() {\n                return this._srcObject;\n              },\n              set: function set(stream) {\n                var self = this;\n                if (this._srcObject = stream, this.src && URL.revokeObjectURL(this.src), !stream) return void (this.src = \"\");\n                this.src = URL.createObjectURL(stream), stream.addEventListener(\"addtrack\", function () {\n                  self.src && URL.revokeObjectURL(self.src), self.src = URL.createObjectURL(stream);\n                }), stream.addEventListener(\"removetrack\", function () {\n                  self.src && URL.revokeObjectURL(self.src), self.src = URL.createObjectURL(stream);\n                });\n              }\n            }));\n          },\n          shimAddTrackRemoveTrackWithNative: function shimAddTrackRemoveTrackWithNative(window) {\n            window.RTCPeerConnection.prototype.getLocalStreams = function () {\n              var pc = this;\n              return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map(function (streamId) {\n                return pc._shimmedLocalStreams[streamId][0];\n              });\n            };\n\n            var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n\n            window.RTCPeerConnection.prototype.addTrack = function (track, stream) {\n              if (!stream) return origAddTrack.apply(this, arguments);\n              this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n              var sender = origAddTrack.apply(this, arguments);\n              return this._shimmedLocalStreams[stream.id] ? -1 === this._shimmedLocalStreams[stream.id].indexOf(sender) && this._shimmedLocalStreams[stream.id].push(sender) : this._shimmedLocalStreams[stream.id] = [stream, sender], sender;\n            };\n\n            var origAddStream = window.RTCPeerConnection.prototype.addStream;\n\n            window.RTCPeerConnection.prototype.addStream = function (stream) {\n              var pc = this;\n              this._shimmedLocalStreams = this._shimmedLocalStreams || {}, stream.getTracks().forEach(function (track) {\n                if (pc.getSenders().find(function (s) {\n                  return s.track === track;\n                })) throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n              });\n              var existingSenders = pc.getSenders();\n              origAddStream.apply(this, arguments);\n              var newSenders = pc.getSenders().filter(function (newSender) {\n                return -1 === existingSenders.indexOf(newSender);\n              });\n              this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n            };\n\n            var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n\n            window.RTCPeerConnection.prototype.removeStream = function (stream) {\n              return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[stream.id], origRemoveStream.apply(this, arguments);\n            };\n\n            var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n\n            window.RTCPeerConnection.prototype.removeTrack = function (sender) {\n              var pc = this;\n              return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, sender && Object.keys(this._shimmedLocalStreams).forEach(function (streamId) {\n                var idx = pc._shimmedLocalStreams[streamId].indexOf(sender);\n\n                -1 !== idx && pc._shimmedLocalStreams[streamId].splice(idx, 1), 1 === pc._shimmedLocalStreams[streamId].length && delete pc._shimmedLocalStreams[streamId];\n              }), origRemoveTrack.apply(this, arguments);\n            };\n          },\n          shimAddTrackRemoveTrack: function shimAddTrackRemoveTrack(window) {\n            function replaceInternalStreamId(pc, description) {\n              var sdp = description.sdp;\n              return Object.keys(pc._reverseStreams || []).forEach(function (internalId) {\n                var externalStream = pc._reverseStreams[internalId],\n                    internalStream = pc._streams[externalStream.id];\n                sdp = sdp.replace(new RegExp(internalStream.id, \"g\"), externalStream.id);\n              }), new RTCSessionDescription({\n                type: description.type,\n                sdp: sdp\n              });\n            }\n\n            function replaceExternalStreamId(pc, description) {\n              var sdp = description.sdp;\n              return Object.keys(pc._reverseStreams || []).forEach(function (internalId) {\n                var externalStream = pc._reverseStreams[internalId],\n                    internalStream = pc._streams[externalStream.id];\n                sdp = sdp.replace(new RegExp(externalStream.id, \"g\"), internalStream.id);\n              }), new RTCSessionDescription({\n                type: description.type,\n                sdp: sdp\n              });\n            }\n\n            var browserDetails = utils.detectBrowser(window);\n            if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) return this.shimAddTrackRemoveTrackWithNative(window);\n            var origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;\n\n            window.RTCPeerConnection.prototype.getLocalStreams = function () {\n              var pc = this,\n                  nativeStreams = origGetLocalStreams.apply(this);\n              return pc._reverseStreams = pc._reverseStreams || {}, nativeStreams.map(function (stream) {\n                return pc._reverseStreams[stream.id];\n              });\n            };\n\n            var origAddStream = window.RTCPeerConnection.prototype.addStream;\n\n            window.RTCPeerConnection.prototype.addStream = function (stream) {\n              var pc = this;\n\n              if (pc._streams = pc._streams || {}, pc._reverseStreams = pc._reverseStreams || {}, stream.getTracks().forEach(function (track) {\n                if (pc.getSenders().find(function (s) {\n                  return s.track === track;\n                })) throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n              }), !pc._reverseStreams[stream.id]) {\n                var newStream = new window.MediaStream(stream.getTracks());\n                pc._streams[stream.id] = newStream, pc._reverseStreams[newStream.id] = stream, stream = newStream;\n              }\n\n              origAddStream.apply(pc, [stream]);\n            };\n\n            var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n            window.RTCPeerConnection.prototype.removeStream = function (stream) {\n              var pc = this;\n              pc._streams = pc._streams || {}, pc._reverseStreams = pc._reverseStreams || {}, origRemoveStream.apply(pc, [pc._streams[stream.id] || stream]), delete pc._reverseStreams[pc._streams[stream.id] ? pc._streams[stream.id].id : stream.id], delete pc._streams[stream.id];\n            }, window.RTCPeerConnection.prototype.addTrack = function (track, stream) {\n              var pc = this;\n              if (\"closed\" === pc.signalingState) throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n              var streams = [].slice.call(arguments, 1);\n              if (1 !== streams.length || !streams[0].getTracks().find(function (t) {\n                return t === track;\n              })) throw new DOMException(\"The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.\", \"NotSupportedError\");\n              if (pc.getSenders().find(function (s) {\n                return s.track === track;\n              })) throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n              pc._streams = pc._streams || {}, pc._reverseStreams = pc._reverseStreams || {};\n              var oldStream = pc._streams[stream.id];\n              if (oldStream) oldStream.addTrack(track), Promise.resolve().then(function () {\n                pc.dispatchEvent(new Event(\"negotiationneeded\"));\n              });else {\n                var newStream = new window.MediaStream([track]);\n                pc._streams[stream.id] = newStream, pc._reverseStreams[newStream.id] = stream, pc.addStream(newStream);\n              }\n              return pc.getSenders().find(function (s) {\n                return s.track === track;\n              });\n            }, [\"createOffer\", \"createAnswer\"].forEach(function (method) {\n              var nativeMethod = window.RTCPeerConnection.prototype[method];\n\n              window.RTCPeerConnection.prototype[method] = function () {\n                var pc = this,\n                    args = arguments;\n                return arguments.length && \"function\" == typeof arguments[0] ? nativeMethod.apply(pc, [function (description) {\n                  var desc = replaceInternalStreamId(pc, description);\n                  args[0].apply(null, [desc]);\n                }, function (err) {\n                  args[1] && args[1].apply(null, err);\n                }, arguments[2]]) : nativeMethod.apply(pc, arguments).then(function (description) {\n                  return replaceInternalStreamId(pc, description);\n                });\n              };\n            });\n            var origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;\n\n            window.RTCPeerConnection.prototype.setLocalDescription = function () {\n              var pc = this;\n              return arguments.length && arguments[0].type ? (arguments[0] = replaceExternalStreamId(pc, arguments[0]), origSetLocalDescription.apply(pc, arguments)) : origSetLocalDescription.apply(pc, arguments);\n            };\n\n            var origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, \"localDescription\");\n            Object.defineProperty(window.RTCPeerConnection.prototype, \"localDescription\", {\n              get: function get() {\n                var pc = this,\n                    description = origLocalDescription.get.apply(this);\n                return \"\" === description.type ? description : replaceInternalStreamId(pc, description);\n              }\n            }), window.RTCPeerConnection.prototype.removeTrack = function (sender) {\n              var pc = this;\n              if (\"closed\" === pc.signalingState) throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n              if (!sender._pc) throw new DOMException(\"Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.\", \"TypeError\");\n              if (sender._pc !== pc) throw new DOMException(\"Sender was not created by this connection.\", \"InvalidAccessError\");\n              pc._streams = pc._streams || {};\n              var stream;\n              Object.keys(pc._streams).forEach(function (streamid) {\n                pc._streams[streamid].getTracks().find(function (track) {\n                  return sender.track === track;\n                }) && (stream = pc._streams[streamid]);\n              }), stream && (1 === stream.getTracks().length ? pc.removeStream(pc._reverseStreams[stream.id]) : stream.removeTrack(sender.track), pc.dispatchEvent(new Event(\"negotiationneeded\")));\n            };\n          },\n          shimPeerConnection: function shimPeerConnection(window) {\n            var browserDetails = utils.detectBrowser(window);\n            if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) window.RTCPeerConnection = function (pcConfig, pcConstraints) {\n              return logging(\"PeerConnection\"), pcConfig && pcConfig.iceTransportPolicy && (pcConfig.iceTransports = pcConfig.iceTransportPolicy), new window.webkitRTCPeerConnection(pcConfig, pcConstraints);\n            }, window.RTCPeerConnection.prototype = window.webkitRTCPeerConnection.prototype, window.webkitRTCPeerConnection.generateCertificate && Object.defineProperty(window.RTCPeerConnection, \"generateCertificate\", {\n              get: function get() {\n                return window.webkitRTCPeerConnection.generateCertificate;\n              }\n            });else {\n              var OrigPeerConnection = window.RTCPeerConnection;\n              window.RTCPeerConnection = function (pcConfig, pcConstraints) {\n                if (pcConfig && pcConfig.iceServers) {\n                  for (var newIceServers = [], i = 0; i < pcConfig.iceServers.length; i++) {\n                    var server = pcConfig.iceServers[i];\n                    !server.hasOwnProperty(\"urls\") && server.hasOwnProperty(\"url\") ? (utils.deprecated(\"RTCIceServer.url\", \"RTCIceServer.urls\"), server = JSON.parse(JSON.stringify(server)), server.urls = server.url, newIceServers.push(server)) : newIceServers.push(pcConfig.iceServers[i]);\n                  }\n\n                  pcConfig.iceServers = newIceServers;\n                }\n\n                return new OrigPeerConnection(pcConfig, pcConstraints);\n              }, window.RTCPeerConnection.prototype = OrigPeerConnection.prototype, Object.defineProperty(window.RTCPeerConnection, \"generateCertificate\", {\n                get: function get() {\n                  return OrigPeerConnection.generateCertificate;\n                }\n              });\n            }\n            var origGetStats = window.RTCPeerConnection.prototype.getStats;\n            window.RTCPeerConnection.prototype.getStats = function (selector, successCallback, errorCallback) {\n              var pc = this,\n                  args = arguments;\n              if (arguments.length > 0 && \"function\" == typeof selector) return origGetStats.apply(this, arguments);\n              if (0 === origGetStats.length && (0 === arguments.length || \"function\" != typeof arguments[0])) return origGetStats.apply(this, []);\n\n              var fixChromeStats_ = function fixChromeStats_(response) {\n                var standardReport = {};\n                return response.result().forEach(function (report) {\n                  var standardStats = {\n                    id: report.id,\n                    timestamp: report.timestamp,\n                    type: {\n                      localcandidate: \"local-candidate\",\n                      remotecandidate: \"remote-candidate\"\n                    }[report.type] || report.type\n                  };\n                  report.names().forEach(function (name) {\n                    standardStats[name] = report.stat(name);\n                  }), standardReport[standardStats.id] = standardStats;\n                }), standardReport;\n              },\n                  makeMapStats = function makeMapStats(stats) {\n                return new Map(Object.keys(stats).map(function (key) {\n                  return [key, stats[key]];\n                }));\n              };\n\n              if (arguments.length >= 2) {\n                var successCallbackWrapper_ = function successCallbackWrapper_(response) {\n                  args[1](makeMapStats(fixChromeStats_(response)));\n                };\n\n                return origGetStats.apply(this, [successCallbackWrapper_, arguments[0]]);\n              }\n\n              return new Promise(function (resolve, reject) {\n                origGetStats.apply(pc, [function (response) {\n                  resolve(makeMapStats(fixChromeStats_(response)));\n                }, reject]);\n              }).then(successCallback, errorCallback);\n            }, browserDetails.version < 51 && [\"setLocalDescription\", \"setRemoteDescription\", \"addIceCandidate\"].forEach(function (method) {\n              var nativeMethod = window.RTCPeerConnection.prototype[method];\n\n              window.RTCPeerConnection.prototype[method] = function () {\n                var args = arguments,\n                    pc = this,\n                    promise = new Promise(function (resolve, reject) {\n                  nativeMethod.apply(pc, [args[0], resolve, reject]);\n                });\n                return args.length < 2 ? promise : promise.then(function () {\n                  args[1].apply(null, []);\n                }, function (err) {\n                  args.length >= 3 && args[2].apply(null, [err]);\n                });\n              };\n            }), browserDetails.version < 52 && [\"createOffer\", \"createAnswer\"].forEach(function (method) {\n              var nativeMethod = window.RTCPeerConnection.prototype[method];\n\n              window.RTCPeerConnection.prototype[method] = function () {\n                var pc = this;\n\n                if (arguments.length < 1 || 1 === arguments.length && \"object\" == typeof arguments[0]) {\n                  var opts = 1 === arguments.length ? arguments[0] : void 0;\n                  return new Promise(function (resolve, reject) {\n                    nativeMethod.apply(pc, [resolve, reject, opts]);\n                  });\n                }\n\n                return nativeMethod.apply(this, arguments);\n              };\n            }), [\"setLocalDescription\", \"setRemoteDescription\", \"addIceCandidate\"].forEach(function (method) {\n              var nativeMethod = window.RTCPeerConnection.prototype[method];\n\n              window.RTCPeerConnection.prototype[method] = function () {\n                return arguments[0] = new (\"addIceCandidate\" === method ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]), nativeMethod.apply(this, arguments);\n              };\n            });\n            var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;\n\n            window.RTCPeerConnection.prototype.addIceCandidate = function () {\n              return arguments[0] ? nativeAddIceCandidate.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve());\n            };\n          },\n          fixNegotiationNeeded: function fixNegotiationNeeded(window) {\n            utils.wrapPeerConnectionEvent(window, \"negotiationneeded\", function (e) {\n              if (\"stable\" === e.target.signalingState) return e;\n            });\n          },\n          shimGetDisplayMedia: function shimGetDisplayMedia(window, getSourceId) {\n            if (!(\"getDisplayMedia\" in window.navigator)) return \"function\" != typeof getSourceId ? void console.error(\"shimGetDisplayMedia: getSourceId argument is not a function\") : void (navigator.getDisplayMedia = function (constraints) {\n              return getSourceId(constraints).then(function (sourceId) {\n                return constraints.video = {\n                  mandatory: {\n                    chromeMediaSource: \"desktop\",\n                    chromeMediaSourceId: sourceId,\n                    maxFrameRate: constraints.video.frameRate || 3\n                  }\n                }, navigator.mediaDevices.getUserMedia(constraints);\n              });\n            });\n          }\n        };\n      }, {\n        \"../utils.js\": 14,\n        \"./getusermedia\": 6\n      }],\n      6: [function (requirecopy, module, exports) {\n        \"use strict\";\n\n        var utils = requirecopy(\"../utils.js\"),\n            logging = utils.log;\n\n        module.exports = function (window) {\n          var browserDetails = utils.detectBrowser(window),\n              navigator = window && window.navigator,\n              constraintsToChrome_ = function constraintsToChrome_(c) {\n            if (\"object\" != typeof c || c.mandatory || c.optional) return c;\n            var cc = {};\n            return Object.keys(c).forEach(function (key) {\n              if (\"require\" !== key && \"advanced\" !== key && \"mediaSource\" !== key) {\n                var r = \"object\" == typeof c[key] ? c[key] : {\n                  ideal: c[key]\n                };\n                void 0 !== r.exact && \"number\" == typeof r.exact && (r.min = r.max = r.exact);\n\n                var oldname_ = function oldname_(prefix, name) {\n                  return prefix ? prefix + name.charAt(0).toUpperCase() + name.slice(1) : \"deviceId\" === name ? \"sourceId\" : name;\n                };\n\n                if (void 0 !== r.ideal) {\n                  cc.optional = cc.optional || [];\n                  var oc = {};\n                  \"number\" == typeof r.ideal ? (oc[oldname_(\"min\", key)] = r.ideal, cc.optional.push(oc), oc = {}, oc[oldname_(\"max\", key)] = r.ideal, cc.optional.push(oc)) : (oc[oldname_(\"\", key)] = r.ideal, cc.optional.push(oc));\n                }\n\n                void 0 !== r.exact && \"number\" != typeof r.exact ? (cc.mandatory = cc.mandatory || {}, cc.mandatory[oldname_(\"\", key)] = r.exact) : [\"min\", \"max\"].forEach(function (mix) {\n                  void 0 !== r[mix] && (cc.mandatory = cc.mandatory || {}, cc.mandatory[oldname_(mix, key)] = r[mix]);\n                });\n              }\n            }), c.advanced && (cc.optional = (cc.optional || []).concat(c.advanced)), cc;\n          },\n              shimConstraints_ = function shimConstraints_(constraints, func) {\n            if (browserDetails.version >= 61) return func(constraints);\n\n            if ((constraints = JSON.parse(JSON.stringify(constraints))) && \"object\" == typeof constraints.audio) {\n              var remap = function remap(obj, a, b) {\n                a in obj && !(b in obj) && (obj[b] = obj[a], delete obj[a]);\n              };\n\n              constraints = JSON.parse(JSON.stringify(constraints)), remap(constraints.audio, \"autoGainControl\", \"googAutoGainControl\"), remap(constraints.audio, \"noiseSuppression\", \"googNoiseSuppression\"), constraints.audio = constraintsToChrome_(constraints.audio);\n            }\n\n            if (constraints && \"object\" == typeof constraints.video) {\n              var face = constraints.video.facingMode;\n              face = face && (\"object\" == typeof face ? face : {\n                ideal: face\n              });\n              var getSupportedFacingModeLies = browserDetails.version < 66;\n\n              if (face && (\"user\" === face.exact || \"environment\" === face.exact || \"user\" === face.ideal || \"environment\" === face.ideal) && (!navigator.mediaDevices.getSupportedConstraints || !navigator.mediaDevices.getSupportedConstraints().facingMode || getSupportedFacingModeLies)) {\n                delete constraints.video.facingMode;\n                var matches;\n                if (\"environment\" === face.exact || \"environment\" === face.ideal ? matches = [\"back\", \"rear\"] : \"user\" !== face.exact && \"user\" !== face.ideal || (matches = [\"front\"]), matches) return navigator.mediaDevices.enumerateDevices().then(function (devices) {\n                  devices = devices.filter(function (d) {\n                    return \"videoinput\" === d.kind;\n                  });\n                  var dev = devices.find(function (d) {\n                    return matches.some(function (match) {\n                      return -1 !== d.label.toLowerCase().indexOf(match);\n                    });\n                  });\n                  return !dev && devices.length && -1 !== matches.indexOf(\"back\") && (dev = devices[devices.length - 1]), dev && (constraints.video.deviceId = face.exact ? {\n                    exact: dev.deviceId\n                  } : {\n                    ideal: dev.deviceId\n                  }), constraints.video = constraintsToChrome_(constraints.video), logging(\"chrome: \" + JSON.stringify(constraints)), func(constraints);\n                });\n              }\n\n              constraints.video = constraintsToChrome_(constraints.video);\n            }\n\n            return logging(\"chrome: \" + JSON.stringify(constraints)), func(constraints);\n          },\n              shimError_ = function shimError_(e) {\n            return browserDetails.version >= 64 ? e : {\n              name: {\n                PermissionDeniedError: \"NotAllowedError\",\n                PermissionDismissedError: \"NotAllowedError\",\n                InvalidStateError: \"NotAllowedError\",\n                DevicesNotFoundError: \"NotFoundError\",\n                ConstraintNotSatisfiedError: \"OverconstrainedError\",\n                TrackStartError: \"NotReadableError\",\n                MediaDeviceFailedDueToShutdown: \"NotAllowedError\",\n                MediaDeviceKillSwitchOn: \"NotAllowedError\",\n                TabCaptureError: \"AbortError\",\n                ScreenCaptureError: \"AbortError\",\n                DeviceCaptureError: \"AbortError\"\n              }[e.name] || e.name,\n              message: e.message,\n              constraint: e.constraint || e.constraintName,\n              toString: function toString() {\n                return this.name + (this.message && \": \") + this.message;\n              }\n            };\n          },\n              getUserMedia_ = function getUserMedia_(constraints, onSuccess, onError) {\n            shimConstraints_(constraints, function (c) {\n              navigator.webkitGetUserMedia(c, onSuccess, function (e) {\n                onError && onError(shimError_(e));\n              });\n            });\n          };\n\n          navigator.getUserMedia = getUserMedia_;\n\n          var getUserMediaPromise_ = function getUserMediaPromise_(constraints) {\n            return new Promise(function (resolve, reject) {\n              navigator.getUserMedia(constraints, resolve, reject);\n            });\n          };\n\n          if (navigator.mediaDevices || (navigator.mediaDevices = {\n            getUserMedia: getUserMediaPromise_,\n            enumerateDevices: function enumerateDevices() {\n              return new Promise(function (resolve) {\n                var kinds = {\n                  audio: \"audioinput\",\n                  video: \"videoinput\"\n                };\n                return window.MediaStreamTrack.getSources(function (devices) {\n                  resolve(devices.map(function (device) {\n                    return {\n                      label: device.label,\n                      kind: kinds[device.kind],\n                      deviceId: device.id,\n                      groupId: \"\"\n                    };\n                  }));\n                });\n              });\n            },\n            getSupportedConstraints: function getSupportedConstraints() {\n              return {\n                deviceId: !0,\n                echoCancellation: !0,\n                facingMode: !0,\n                frameRate: !0,\n                height: !0,\n                width: !0\n              };\n            }\n          }), navigator.mediaDevices.getUserMedia) {\n            var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\n\n            navigator.mediaDevices.getUserMedia = function (cs) {\n              return shimConstraints_(cs, function (c) {\n                return origGetUserMedia(c).then(function (stream) {\n                  if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) throw stream.getTracks().forEach(function (track) {\n                    track.stop();\n                  }), new DOMException(\"\", \"NotFoundError\");\n                  return stream;\n                }, function (e) {\n                  return Promise.reject(shimError_(e));\n                });\n              });\n            };\n          } else navigator.mediaDevices.getUserMedia = function (constraints) {\n            return getUserMediaPromise_(constraints);\n          };\n\n          void 0 === navigator.mediaDevices.addEventListener && (navigator.mediaDevices.addEventListener = function () {\n            logging(\"Dummy mediaDevices.addEventListener called.\");\n          }), void 0 === navigator.mediaDevices.removeEventListener && (navigator.mediaDevices.removeEventListener = function () {\n            logging(\"Dummy mediaDevices.removeEventListener called.\");\n          });\n        };\n      }, {\n        \"../utils.js\": 14\n      }],\n      7: [function (requirecopy, module, exports) {\n        \"use strict\";\n\n        var SDPUtils = requirecopy(\"sdp\"),\n            utils = requirecopy(\"./utils\");\n        module.exports = {\n          shimRTCIceCandidate: function shimRTCIceCandidate(window) {\n            if (window.RTCIceCandidate && !(window.RTCIceCandidate && \"foundation\" in window.RTCIceCandidate.prototype)) {\n              var NativeRTCIceCandidate = window.RTCIceCandidate;\n              window.RTCIceCandidate = function (args) {\n                if (\"object\" == typeof args && args.candidate && 0 === args.candidate.indexOf(\"a=\") && (args = JSON.parse(JSON.stringify(args)), args.candidate = args.candidate.substr(2)), args.candidate && args.candidate.length) {\n                  var nativeCandidate = new NativeRTCIceCandidate(args),\n                      parsedCandidate = SDPUtils.parseCandidate(args.candidate),\n                      augmentedCandidate = Object.assign(nativeCandidate, parsedCandidate);\n                  return augmentedCandidate.toJSON = function () {\n                    return {\n                      candidate: augmentedCandidate.candidate,\n                      sdpMid: augmentedCandidate.sdpMid,\n                      sdpMLineIndex: augmentedCandidate.sdpMLineIndex,\n                      usernameFragment: augmentedCandidate.usernameFragment\n                    };\n                  }, augmentedCandidate;\n                }\n\n                return new NativeRTCIceCandidate(args);\n              }, window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype, utils.wrapPeerConnectionEvent(window, \"icecandidate\", function (e) {\n                return e.candidate && Object.defineProperty(e, \"candidate\", {\n                  value: new window.RTCIceCandidate(e.candidate),\n                  writable: \"false\"\n                }), e;\n              });\n            }\n          },\n          shimCreateObjectURL: function shimCreateObjectURL(window) {\n            var URL = window && window.URL;\n\n            if (\"object\" == typeof window && window.HTMLMediaElement && \"srcObject\" in window.HTMLMediaElement.prototype && URL.createObjectURL && URL.revokeObjectURL) {\n              var nativeCreateObjectURL = URL.createObjectURL.bind(URL),\n                  nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL),\n                  streams = new Map(),\n                  newId = 0;\n              URL.createObjectURL = function (stream) {\n                if (\"getTracks\" in stream) {\n                  var url = \"polyblob:\" + ++newId;\n                  return streams.set(url, stream), utils.deprecated(\"URL.createObjectURL(stream)\", \"elem.srcObject = stream\"), url;\n                }\n\n                return nativeCreateObjectURL(stream);\n              }, URL.revokeObjectURL = function (url) {\n                nativeRevokeObjectURL(url), streams.delete(url);\n              };\n              var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype, \"src\");\n              Object.defineProperty(window.HTMLMediaElement.prototype, \"src\", {\n                get: function get() {\n                  return dsc.get.apply(this);\n                },\n                set: function set(url) {\n                  return this.srcObject = streams.get(url) || null, dsc.set.apply(this, [url]);\n                }\n              });\n              var nativeSetAttribute = window.HTMLMediaElement.prototype.setAttribute;\n\n              window.HTMLMediaElement.prototype.setAttribute = function () {\n                return 2 === arguments.length && \"src\" === (\"\" + arguments[0]).toLowerCase() && (this.srcObject = streams.get(arguments[1]) || null), nativeSetAttribute.apply(this, arguments);\n              };\n            }\n          },\n          shimMaxMessageSize: function shimMaxMessageSize(window) {\n            if (!window.RTCSctpTransport && window.RTCPeerConnection) {\n              var browserDetails = utils.detectBrowser(window);\n              \"sctp\" in window.RTCPeerConnection.prototype || Object.defineProperty(window.RTCPeerConnection.prototype, \"sctp\", {\n                get: function get() {\n                  return void 0 === this._sctp ? null : this._sctp;\n                }\n              });\n\n              var sctpInDescription = function sctpInDescription(description) {\n                var sections = SDPUtils.splitSections(description.sdp);\n                return sections.shift(), sections.some(function (mediaSection) {\n                  var mLine = SDPUtils.parseMLine(mediaSection);\n                  return mLine && \"application\" === mLine.kind && -1 !== mLine.protocol.indexOf(\"SCTP\");\n                });\n              },\n                  getRemoteFirefoxVersion = function getRemoteFirefoxVersion(description) {\n                var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n                if (null === match || match.length < 2) return -1;\n                var version = parseInt(match[1], 10);\n                return version !== version ? -1 : version;\n              },\n                  getCanSendMaxMessageSize = function getCanSendMaxMessageSize(remoteIsFirefox) {\n                var canSendMaxMessageSize = 65536;\n                return \"firefox\" === browserDetails.browser && (canSendMaxMessageSize = browserDetails.version < 57 ? -1 === remoteIsFirefox ? 16384 : 2147483637 : browserDetails.version < 60 ? 57 === browserDetails.version ? 65535 : 65536 : 2147483637), canSendMaxMessageSize;\n              },\n                  getMaxMessageSize = function getMaxMessageSize(description, remoteIsFirefox) {\n                var maxMessageSize = 65536;\n                \"firefox\" === browserDetails.browser && 57 === browserDetails.version && (maxMessageSize = 65535);\n                var match = SDPUtils.matchPrefix(description.sdp, \"a=max-message-size:\");\n                return match.length > 0 ? maxMessageSize = parseInt(match[0].substr(19), 10) : \"firefox\" === browserDetails.browser && -1 !== remoteIsFirefox && (maxMessageSize = 2147483637), maxMessageSize;\n              },\n                  origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n\n              window.RTCPeerConnection.prototype.setRemoteDescription = function () {\n                var pc = this;\n\n                if (pc._sctp = null, sctpInDescription(arguments[0])) {\n                  var maxMessageSize,\n                      isFirefox = getRemoteFirefoxVersion(arguments[0]),\n                      canSendMMS = getCanSendMaxMessageSize(isFirefox),\n                      remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n                  maxMessageSize = 0 === canSendMMS && 0 === remoteMMS ? Number.POSITIVE_INFINITY : 0 === canSendMMS || 0 === remoteMMS ? Math.max(canSendMMS, remoteMMS) : Math.min(canSendMMS, remoteMMS);\n                  var sctp = {};\n                  Object.defineProperty(sctp, \"maxMessageSize\", {\n                    get: function get() {\n                      return maxMessageSize;\n                    }\n                  }), pc._sctp = sctp;\n                }\n\n                return origSetRemoteDescription.apply(pc, arguments);\n              };\n            }\n          },\n          shimSendThrowTypeError: function shimSendThrowTypeError(window) {\n            function wrapDcSend(dc, pc) {\n              var origDataChannelSend = dc.send;\n\n              dc.send = function () {\n                var data = arguments[0],\n                    length = data.length || data.size || data.byteLength;\n                if (\"open\" === dc.readyState && pc.sctp && length > pc.sctp.maxMessageSize) throw new TypeError(\"Message too large (can send a maximum of \" + pc.sctp.maxMessageSize + \" bytes)\");\n                return origDataChannelSend.apply(dc, arguments);\n              };\n            }\n\n            if (window.RTCPeerConnection && \"createDataChannel\" in window.RTCPeerConnection.prototype) {\n              var origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;\n              window.RTCPeerConnection.prototype.createDataChannel = function () {\n                var pc = this,\n                    dataChannel = origCreateDataChannel.apply(pc, arguments);\n                return wrapDcSend(dataChannel, pc), dataChannel;\n              }, utils.wrapPeerConnectionEvent(window, \"datachannel\", function (e) {\n                return wrapDcSend(e.channel, e.target), e;\n              });\n            }\n          }\n        };\n      }, {\n        \"./utils\": 14,\n        sdp: 2\n      }],\n      8: [function (requirecopy, module, exports) {\n        \"use strict\";\n\n        var utils = requirecopy(\"../utils\"),\n            filterIceServers = requirecopy(\"./filtericeservers\"),\n            shimRTCPeerConnection = requirecopy(\"rtcpeerconnection-shim\");\n        module.exports = {\n          shimGetUserMedia: requirecopy(\"./getusermedia\"),\n          shimPeerConnection: function shimPeerConnection(window) {\n            var browserDetails = utils.detectBrowser(window);\n\n            if (window.RTCIceGatherer && (window.RTCIceCandidate || (window.RTCIceCandidate = function (args) {\n              return args;\n            }), window.RTCSessionDescription || (window.RTCSessionDescription = function (args) {\n              return args;\n            }), browserDetails.version < 15025)) {\n              var origMSTEnabled = Object.getOwnPropertyDescriptor(window.MediaStreamTrack.prototype, \"enabled\");\n              Object.defineProperty(window.MediaStreamTrack.prototype, \"enabled\", {\n                set: function set(value) {\n                  origMSTEnabled.set.call(this, value);\n                  var ev = new Event(\"enabled\");\n                  ev.enabled = value, this.dispatchEvent(ev);\n                }\n              });\n            }\n\n            !window.RTCRtpSender || \"dtmf\" in window.RTCRtpSender.prototype || Object.defineProperty(window.RTCRtpSender.prototype, \"dtmf\", {\n              get: function get() {\n                return void 0 === this._dtmf && (\"audio\" === this.track.kind ? this._dtmf = new window.RTCDtmfSender(this) : \"video\" === this.track.kind && (this._dtmf = null)), this._dtmf;\n              }\n            }), window.RTCDtmfSender && !window.RTCDTMFSender && (window.RTCDTMFSender = window.RTCDtmfSender);\n            var RTCPeerConnectionShim = shimRTCPeerConnection(window, browserDetails.version);\n            window.RTCPeerConnection = function (config) {\n              return config && config.iceServers && (config.iceServers = filterIceServers(config.iceServers)), new RTCPeerConnectionShim(config);\n            }, window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;\n          },\n          shimReplaceTrack: function shimReplaceTrack(window) {\n            !window.RTCRtpSender || \"replaceTrack\" in window.RTCRtpSender.prototype || (window.RTCRtpSender.prototype.replaceTrack = window.RTCRtpSender.prototype.setTrack);\n          }\n        };\n      }, {\n        \"../utils\": 14,\n        \"./filtericeservers\": 9,\n        \"./getusermedia\": 10,\n        \"rtcpeerconnection-shim\": 1\n      }],\n      9: [function (requirecopy, module, exports) {\n        \"use strict\";\n\n        var utils = requirecopy(\"../utils\");\n\n        module.exports = function (iceServers, edgeVersion) {\n          var hasTurn = !1;\n          return iceServers = JSON.parse(JSON.stringify(iceServers)), iceServers.filter(function (server) {\n            if (server && (server.urls || server.url)) {\n              var urls = server.urls || server.url;\n              server.url && !server.urls && utils.deprecated(\"RTCIceServer.url\", \"RTCIceServer.urls\");\n              var isString = \"string\" == typeof urls;\n              return isString && (urls = [urls]), urls = urls.filter(function (url) {\n                return 0 !== url.indexOf(\"turn:\") || -1 === url.indexOf(\"transport=udp\") || -1 !== url.indexOf(\"turn:[\") || hasTurn ? 0 === url.indexOf(\"stun:\") && edgeVersion >= 14393 && -1 === url.indexOf(\"?transport=udp\") : (hasTurn = !0, !0);\n              }), delete server.url, server.urls = isString ? urls[0] : urls, !!urls.length;\n            }\n          });\n        };\n      }, {\n        \"../utils\": 14\n      }],\n      10: [function (requirecopy, module, exports) {\n        \"use strict\";\n\n        module.exports = function (window) {\n          var navigator = window && window.navigator,\n              shimError_ = function shimError_(e) {\n            return {\n              name: {\n                PermissionDeniedError: \"NotAllowedError\"\n              }[e.name] || e.name,\n              message: e.message,\n              constraint: e.constraint,\n              toString: function toString() {\n                return this.name;\n              }\n            };\n          },\n              origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\n\n          navigator.mediaDevices.getUserMedia = function (c) {\n            return origGetUserMedia(c).catch(function (e) {\n              return Promise.reject(shimError_(e));\n            });\n          };\n        };\n      }, {}],\n      11: [function (requirecopy, module, exports) {\n        \"use strict\";\n\n        var utils = requirecopy(\"../utils\");\n        module.exports = {\n          shimGetUserMedia: requirecopy(\"./getusermedia\"),\n          shimOnTrack: function shimOnTrack(window) {\n            \"object\" != typeof window || !window.RTCPeerConnection || \"ontrack\" in window.RTCPeerConnection.prototype || Object.defineProperty(window.RTCPeerConnection.prototype, \"ontrack\", {\n              get: function get() {\n                return this._ontrack;\n              },\n              set: function set(f) {\n                this._ontrack && (this.removeEventListener(\"track\", this._ontrack), this.removeEventListener(\"addstream\", this._ontrackpoly)), this.addEventListener(\"track\", this._ontrack = f), this.addEventListener(\"addstream\", this._ontrackpoly = function (e) {\n                  e.stream.getTracks().forEach(function (track) {\n                    var event = new Event(\"track\");\n                    event.track = track, event.receiver = {\n                      track: track\n                    }, event.transceiver = {\n                      receiver: event.receiver\n                    }, event.streams = [e.stream], this.dispatchEvent(event);\n                  }.bind(this));\n                }.bind(this));\n              },\n              enumerable: !0,\n              configurable: !0\n            }), \"object\" == typeof window && window.RTCTrackEvent && \"receiver\" in window.RTCTrackEvent.prototype && !(\"transceiver\" in window.RTCTrackEvent.prototype) && Object.defineProperty(window.RTCTrackEvent.prototype, \"transceiver\", {\n              get: function get() {\n                return {\n                  receiver: this.receiver\n                };\n              }\n            });\n          },\n          shimSourceObject: function shimSourceObject(window) {\n            \"object\" == typeof window && (!window.HTMLMediaElement || \"srcObject\" in window.HTMLMediaElement.prototype || Object.defineProperty(window.HTMLMediaElement.prototype, \"srcObject\", {\n              get: function get() {\n                return this.mozSrcObject;\n              },\n              set: function set(stream) {\n                this.mozSrcObject = stream;\n              }\n            }));\n          },\n          shimPeerConnection: function shimPeerConnection(window) {\n            var browserDetails = utils.detectBrowser(window);\n\n            if (\"object\" == typeof window && (window.RTCPeerConnection || window.mozRTCPeerConnection)) {\n              window.RTCPeerConnection || (window.RTCPeerConnection = function (pcConfig, pcConstraints) {\n                if (browserDetails.version < 38 && pcConfig && pcConfig.iceServers) {\n                  for (var newIceServers = [], i = 0; i < pcConfig.iceServers.length; i++) {\n                    var server = pcConfig.iceServers[i];\n                    if (server.hasOwnProperty(\"urls\")) for (var j = 0; j < server.urls.length; j++) {\n                      var newServer = {\n                        url: server.urls[j]\n                      };\n                      0 === server.urls[j].indexOf(\"turn\") && (newServer.username = server.username, newServer.credential = server.credential), newIceServers.push(newServer);\n                    } else newIceServers.push(pcConfig.iceServers[i]);\n                  }\n\n                  pcConfig.iceServers = newIceServers;\n                }\n\n                return new window.mozRTCPeerConnection(pcConfig, pcConstraints);\n              }, window.RTCPeerConnection.prototype = window.mozRTCPeerConnection.prototype, window.mozRTCPeerConnection.generateCertificate && Object.defineProperty(window.RTCPeerConnection, \"generateCertificate\", {\n                get: function get() {\n                  return window.mozRTCPeerConnection.generateCertificate;\n                }\n              }), window.RTCSessionDescription = window.mozRTCSessionDescription, window.RTCIceCandidate = window.mozRTCIceCandidate), [\"setLocalDescription\", \"setRemoteDescription\", \"addIceCandidate\"].forEach(function (method) {\n                var nativeMethod = window.RTCPeerConnection.prototype[method];\n\n                window.RTCPeerConnection.prototype[method] = function () {\n                  return arguments[0] = new (\"addIceCandidate\" === method ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]), nativeMethod.apply(this, arguments);\n                };\n              });\n              var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;\n\n              window.RTCPeerConnection.prototype.addIceCandidate = function () {\n                return arguments[0] ? nativeAddIceCandidate.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve());\n              };\n\n              var makeMapStats = function makeMapStats(stats) {\n                var map = new Map();\n                return Object.keys(stats).forEach(function (key) {\n                  map.set(key, stats[key]), map[key] = stats[key];\n                }), map;\n              },\n                  modernStatsTypes = {\n                inboundrtp: \"inbound-rtp\",\n                outboundrtp: \"outbound-rtp\",\n                candidatepair: \"candidate-pair\",\n                localcandidate: \"local-candidate\",\n                remotecandidate: \"remote-candidate\"\n              },\n                  nativeGetStats = window.RTCPeerConnection.prototype.getStats;\n\n              window.RTCPeerConnection.prototype.getStats = function (selector, onSucc, onErr) {\n                return nativeGetStats.apply(this, [selector || null]).then(function (stats) {\n                  if (browserDetails.version < 48 && (stats = makeMapStats(stats)), browserDetails.version < 53 && !onSucc) try {\n                    stats.forEach(function (stat) {\n                      stat.type = modernStatsTypes[stat.type] || stat.type;\n                    });\n                  } catch (e) {\n                    if (\"TypeError\" !== e.name) throw e;\n                    stats.forEach(function (stat, i) {\n                      stats.set(i, Object.assign({}, stat, {\n                        type: modernStatsTypes[stat.type] || stat.type\n                      }));\n                    });\n                  }\n                  return stats;\n                }).then(onSucc, onErr);\n              };\n            }\n          },\n          shimSenderGetStats: function shimSenderGetStats(window) {\n            if (\"object\" == typeof window && window.RTCPeerConnection && window.RTCRtpSender && !(window.RTCRtpSender && \"getStats\" in window.RTCRtpSender.prototype)) {\n              var origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n              origGetSenders && (window.RTCPeerConnection.prototype.getSenders = function () {\n                var pc = this,\n                    senders = origGetSenders.apply(pc, []);\n                return senders.forEach(function (sender) {\n                  sender._pc = pc;\n                }), senders;\n              });\n              var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n              origAddTrack && (window.RTCPeerConnection.prototype.addTrack = function () {\n                var sender = origAddTrack.apply(this, arguments);\n                return sender._pc = this, sender;\n              }), window.RTCRtpSender.prototype.getStats = function () {\n                return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());\n              };\n            }\n          },\n          shimReceiverGetStats: function shimReceiverGetStats(window) {\n            if (\"object\" == typeof window && window.RTCPeerConnection && window.RTCRtpSender && !(window.RTCRtpSender && \"getStats\" in window.RTCRtpReceiver.prototype)) {\n              var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n              origGetReceivers && (window.RTCPeerConnection.prototype.getReceivers = function () {\n                var pc = this,\n                    receivers = origGetReceivers.apply(pc, []);\n                return receivers.forEach(function (receiver) {\n                  receiver._pc = pc;\n                }), receivers;\n              }), utils.wrapPeerConnectionEvent(window, \"track\", function (e) {\n                return e.receiver._pc = e.srcElement, e;\n              }), window.RTCRtpReceiver.prototype.getStats = function () {\n                return this._pc.getStats(this.track);\n              };\n            }\n          },\n          shimRemoveStream: function shimRemoveStream(window) {\n            !window.RTCPeerConnection || \"removeStream\" in window.RTCPeerConnection.prototype || (window.RTCPeerConnection.prototype.removeStream = function (stream) {\n              var pc = this;\n              utils.deprecated(\"removeStream\", \"removeTrack\"), this.getSenders().forEach(function (sender) {\n                sender.track && -1 !== stream.getTracks().indexOf(sender.track) && pc.removeTrack(sender);\n              });\n            });\n          },\n          shimRTCDataChannel: function shimRTCDataChannel(window) {\n            window.DataChannel && !window.RTCDataChannel && (window.RTCDataChannel = window.DataChannel);\n          },\n          shimGetDisplayMedia: function shimGetDisplayMedia(window, preferredMediaSource) {\n            \"getDisplayMedia\" in window.navigator || (navigator.getDisplayMedia = function (constraints) {\n              if (!constraints || !constraints.video) {\n                var err = new DOMException(\"getDisplayMedia without video constraints is undefined\");\n                return err.name = \"NotFoundError\", err.code = 8, Promise.reject(err);\n              }\n\n              return !0 === constraints.video ? constraints.video = {\n                mediaSource: preferredMediaSource\n              } : constraints.video.mediaSource = preferredMediaSource, navigator.mediaDevices.getUserMedia(constraints);\n            });\n          }\n        };\n      }, {\n        \"../utils\": 14,\n        \"./getusermedia\": 12\n      }],\n      12: [function (requirecopy, module, exports) {\n        \"use strict\";\n\n        var utils = requirecopy(\"../utils\"),\n            logging = utils.log;\n\n        module.exports = function (window) {\n          var browserDetails = utils.detectBrowser(window),\n              navigator = window && window.navigator,\n              MediaStreamTrack = window && window.MediaStreamTrack,\n              shimError_ = function shimError_(e) {\n            return {\n              name: {\n                InternalError: \"NotReadableError\",\n                NotSupportedError: \"TypeError\",\n                PermissionDeniedError: \"NotAllowedError\",\n                SecurityError: \"NotAllowedError\"\n              }[e.name] || e.name,\n              message: {\n                \"The operation is insecure.\": \"The request is not allowed by the user agent or the platform in the current context.\"\n              }[e.message] || e.message,\n              constraint: e.constraint,\n              toString: function toString() {\n                return this.name + (this.message && \": \") + this.message;\n              }\n            };\n          },\n              getUserMedia_ = function getUserMedia_(constraints, onSuccess, onError) {\n            var constraintsToFF37_ = function constraintsToFF37_(c) {\n              if (\"object\" != typeof c || c.require) return c;\n              var require = [];\n              return Object.keys(c).forEach(function (key) {\n                if (\"require\" !== key && \"advanced\" !== key && \"mediaSource\" !== key) {\n                  var r = c[key] = \"object\" == typeof c[key] ? c[key] : {\n                    ideal: c[key]\n                  };\n\n                  if (void 0 === r.min && void 0 === r.max && void 0 === r.exact || require.push(key), void 0 !== r.exact && (\"number\" == typeof r.exact ? r.min = r.max = r.exact : c[key] = r.exact, delete r.exact), void 0 !== r.ideal) {\n                    c.advanced = c.advanced || [];\n                    var oc = {};\n                    \"number\" == typeof r.ideal ? oc[key] = {\n                      min: r.ideal,\n                      max: r.ideal\n                    } : oc[key] = r.ideal, c.advanced.push(oc), delete r.ideal, Object.keys(r).length || delete c[key];\n                  }\n                }\n              }), require.length && (c.require = require), c;\n            };\n\n            return constraints = JSON.parse(JSON.stringify(constraints)), browserDetails.version < 38 && (logging(\"spec: \" + JSON.stringify(constraints)), constraints.audio && (constraints.audio = constraintsToFF37_(constraints.audio)), constraints.video && (constraints.video = constraintsToFF37_(constraints.video)), logging(\"ff37: \" + JSON.stringify(constraints))), navigator.mozGetUserMedia(constraints, onSuccess, function (e) {\n              onError(shimError_(e));\n            });\n          },\n              getUserMediaPromise_ = function getUserMediaPromise_(constraints) {\n            return new Promise(function (resolve, reject) {\n              getUserMedia_(constraints, resolve, reject);\n            });\n          };\n\n          if (navigator.mediaDevices || (navigator.mediaDevices = {\n            getUserMedia: getUserMediaPromise_,\n            addEventListener: function addEventListener() {},\n            removeEventListener: function removeEventListener() {}\n          }), navigator.mediaDevices.enumerateDevices = navigator.mediaDevices.enumerateDevices || function () {\n            return new Promise(function (resolve) {\n              resolve([{\n                kind: \"audioinput\",\n                deviceId: \"default\",\n                label: \"\",\n                groupId: \"\"\n              }, {\n                kind: \"videoinput\",\n                deviceId: \"default\",\n                label: \"\",\n                groupId: \"\"\n              }]);\n            });\n          }, browserDetails.version < 41) {\n            var orgEnumerateDevices = navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);\n\n            navigator.mediaDevices.enumerateDevices = function () {\n              return orgEnumerateDevices().then(void 0, function (e) {\n                if (\"NotFoundError\" === e.name) return [];\n                throw e;\n              });\n            };\n          }\n\n          if (browserDetails.version < 49) {\n            var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\n\n            navigator.mediaDevices.getUserMedia = function (c) {\n              return origGetUserMedia(c).then(function (stream) {\n                if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) throw stream.getTracks().forEach(function (track) {\n                  track.stop();\n                }), new DOMException(\"The object can not be found here.\", \"NotFoundError\");\n                return stream;\n              }, function (e) {\n                return Promise.reject(shimError_(e));\n              });\n            };\n          }\n\n          if (!(browserDetails.version > 55 && \"autoGainControl\" in navigator.mediaDevices.getSupportedConstraints())) {\n            var remap = function remap(obj, a, b) {\n              a in obj && !(b in obj) && (obj[b] = obj[a], delete obj[a]);\n            },\n                nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\n\n            if (navigator.mediaDevices.getUserMedia = function (c) {\n              return \"object\" == typeof c && \"object\" == typeof c.audio && (c = JSON.parse(JSON.stringify(c)), remap(c.audio, \"autoGainControl\", \"mozAutoGainControl\"), remap(c.audio, \"noiseSuppression\", \"mozNoiseSuppression\")), nativeGetUserMedia(c);\n            }, MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {\n              var nativeGetSettings = MediaStreamTrack.prototype.getSettings;\n\n              MediaStreamTrack.prototype.getSettings = function () {\n                var obj = nativeGetSettings.apply(this, arguments);\n                return remap(obj, \"mozAutoGainControl\", \"autoGainControl\"), remap(obj, \"mozNoiseSuppression\", \"noiseSuppression\"), obj;\n              };\n            }\n\n            if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {\n              var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;\n\n              MediaStreamTrack.prototype.applyConstraints = function (c) {\n                return \"audio\" === this.kind && \"object\" == typeof c && (c = JSON.parse(JSON.stringify(c)), remap(c, \"autoGainControl\", \"mozAutoGainControl\"), remap(c, \"noiseSuppression\", \"mozNoiseSuppression\")), nativeApplyConstraints.apply(this, [c]);\n              };\n            }\n          }\n\n          navigator.getUserMedia = function (constraints, onSuccess, onError) {\n            if (browserDetails.version < 44) return getUserMedia_(constraints, onSuccess, onError);\n            utils.deprecated(\"navigator.getUserMedia\", \"navigator.mediaDevices.getUserMedia\"), navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n          };\n        };\n      }, {\n        \"../utils\": 14\n      }],\n      13: [function (requirecopy, module, exports) {\n        \"use strict\";\n\n        var utils = requirecopy(\"../utils\");\n        module.exports = {\n          shimLocalStreamsAPI: function shimLocalStreamsAPI(window) {\n            if (\"object\" == typeof window && window.RTCPeerConnection) {\n              if (\"getLocalStreams\" in window.RTCPeerConnection.prototype || (window.RTCPeerConnection.prototype.getLocalStreams = function () {\n                return this._localStreams || (this._localStreams = []), this._localStreams;\n              }), \"getStreamById\" in window.RTCPeerConnection.prototype || (window.RTCPeerConnection.prototype.getStreamById = function (id) {\n                var result = null;\n                return this._localStreams && this._localStreams.forEach(function (stream) {\n                  stream.id === id && (result = stream);\n                }), this._remoteStreams && this._remoteStreams.forEach(function (stream) {\n                  stream.id === id && (result = stream);\n                }), result;\n              }), !(\"addStream\" in window.RTCPeerConnection.prototype)) {\n                var _addTrack = window.RTCPeerConnection.prototype.addTrack;\n                window.RTCPeerConnection.prototype.addStream = function (stream) {\n                  this._localStreams || (this._localStreams = []), -1 === this._localStreams.indexOf(stream) && this._localStreams.push(stream);\n                  var pc = this;\n                  stream.getTracks().forEach(function (track) {\n                    _addTrack.call(pc, track, stream);\n                  });\n                }, window.RTCPeerConnection.prototype.addTrack = function (track, stream) {\n                  return stream && (this._localStreams ? -1 === this._localStreams.indexOf(stream) && this._localStreams.push(stream) : this._localStreams = [stream]), _addTrack.call(this, track, stream);\n                };\n              }\n\n              \"removeStream\" in window.RTCPeerConnection.prototype || (window.RTCPeerConnection.prototype.removeStream = function (stream) {\n                this._localStreams || (this._localStreams = []);\n\n                var index = this._localStreams.indexOf(stream);\n\n                if (-1 !== index) {\n                  this._localStreams.splice(index, 1);\n\n                  var pc = this,\n                      tracks = stream.getTracks();\n                  this.getSenders().forEach(function (sender) {\n                    -1 !== tracks.indexOf(sender.track) && pc.removeTrack(sender);\n                  });\n                }\n              });\n            }\n          },\n          shimRemoteStreamsAPI: function shimRemoteStreamsAPI(window) {\n            if (\"object\" == typeof window && window.RTCPeerConnection && (\"getRemoteStreams\" in window.RTCPeerConnection.prototype || (window.RTCPeerConnection.prototype.getRemoteStreams = function () {\n              return this._remoteStreams ? this._remoteStreams : [];\n            }), !(\"onaddstream\" in window.RTCPeerConnection.prototype))) {\n              Object.defineProperty(window.RTCPeerConnection.prototype, \"onaddstream\", {\n                get: function get() {\n                  return this._onaddstream;\n                },\n                set: function set(f) {\n                  this._onaddstream && this.removeEventListener(\"addstream\", this._onaddstream), this.addEventListener(\"addstream\", this._onaddstream = f);\n                }\n              });\n              var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n\n              window.RTCPeerConnection.prototype.setRemoteDescription = function () {\n                var pc = this;\n                return this._onaddstreampoly || this.addEventListener(\"track\", this._onaddstreampoly = function (e) {\n                  e.streams.forEach(function (stream) {\n                    if (pc._remoteStreams || (pc._remoteStreams = []), !(pc._remoteStreams.indexOf(stream) >= 0)) {\n                      pc._remoteStreams.push(stream);\n\n                      var event = new Event(\"addstream\");\n                      event.stream = stream, pc.dispatchEvent(event);\n                    }\n                  });\n                }), origSetRemoteDescription.apply(pc, arguments);\n              };\n            }\n          },\n          shimCallbacksAPI: function shimCallbacksAPI(window) {\n            if (\"object\" == typeof window && window.RTCPeerConnection) {\n              var prototype = window.RTCPeerConnection.prototype,\n                  createOffer = prototype.createOffer,\n                  createAnswer = prototype.createAnswer,\n                  setLocalDescription = prototype.setLocalDescription,\n                  setRemoteDescription = prototype.setRemoteDescription,\n                  addIceCandidate = prototype.addIceCandidate;\n              prototype.createOffer = function (successCallback, failureCallback) {\n                var options = arguments.length >= 2 ? arguments[2] : arguments[0],\n                    promise = createOffer.apply(this, [options]);\n                return failureCallback ? (promise.then(successCallback, failureCallback), Promise.resolve()) : promise;\n              }, prototype.createAnswer = function (successCallback, failureCallback) {\n                var options = arguments.length >= 2 ? arguments[2] : arguments[0],\n                    promise = createAnswer.apply(this, [options]);\n                return failureCallback ? (promise.then(successCallback, failureCallback), Promise.resolve()) : promise;\n              };\n\n              var withCallback = function withCallback(description, successCallback, failureCallback) {\n                var promise = setLocalDescription.apply(this, [description]);\n                return failureCallback ? (promise.then(successCallback, failureCallback), Promise.resolve()) : promise;\n              };\n\n              prototype.setLocalDescription = withCallback, withCallback = function withCallback(description, successCallback, failureCallback) {\n                var promise = setRemoteDescription.apply(this, [description]);\n                return failureCallback ? (promise.then(successCallback, failureCallback), Promise.resolve()) : promise;\n              }, prototype.setRemoteDescription = withCallback, withCallback = function withCallback(candidate, successCallback, failureCallback) {\n                var promise = addIceCandidate.apply(this, [candidate]);\n                return failureCallback ? (promise.then(successCallback, failureCallback), Promise.resolve()) : promise;\n              }, prototype.addIceCandidate = withCallback;\n            }\n          },\n          shimGetUserMedia: function shimGetUserMedia(window) {\n            var navigator = window && window.navigator;\n            navigator.getUserMedia || (navigator.webkitGetUserMedia ? navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator) : navigator.mediaDevices && navigator.mediaDevices.getUserMedia && (navigator.getUserMedia = function (constraints, cb, errcb) {\n              navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);\n            }.bind(navigator)));\n          },\n          shimRTCIceServerUrls: function shimRTCIceServerUrls(window) {\n            var OrigPeerConnection = window.RTCPeerConnection;\n            window.RTCPeerConnection = function (pcConfig, pcConstraints) {\n              if (pcConfig && pcConfig.iceServers) {\n                for (var newIceServers = [], i = 0; i < pcConfig.iceServers.length; i++) {\n                  var server = pcConfig.iceServers[i];\n                  !server.hasOwnProperty(\"urls\") && server.hasOwnProperty(\"url\") ? (utils.deprecated(\"RTCIceServer.url\", \"RTCIceServer.urls\"), server = JSON.parse(JSON.stringify(server)), server.urls = server.url, delete server.url, newIceServers.push(server)) : newIceServers.push(pcConfig.iceServers[i]);\n                }\n\n                pcConfig.iceServers = newIceServers;\n              }\n\n              return new OrigPeerConnection(pcConfig, pcConstraints);\n            }, window.RTCPeerConnection.prototype = OrigPeerConnection.prototype, \"generateCertificate\" in window.RTCPeerConnection && Object.defineProperty(window.RTCPeerConnection, \"generateCertificate\", {\n              get: function get() {\n                return OrigPeerConnection.generateCertificate;\n              }\n            });\n          },\n          shimTrackEventTransceiver: function shimTrackEventTransceiver(window) {\n            \"object\" == typeof window && window.RTCPeerConnection && \"receiver\" in window.RTCTrackEvent.prototype && !window.RTCTransceiver && Object.defineProperty(window.RTCTrackEvent.prototype, \"transceiver\", {\n              get: function get() {\n                return {\n                  receiver: this.receiver\n                };\n              }\n            });\n          },\n          shimCreateOfferLegacy: function shimCreateOfferLegacy(window) {\n            var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n\n            window.RTCPeerConnection.prototype.createOffer = function (offerOptions) {\n              var pc = this;\n\n              if (offerOptions) {\n                void 0 !== offerOptions.offerToReceiveAudio && (offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio);\n                var audioTransceiver = pc.getTransceivers().find(function (transceiver) {\n                  return transceiver.sender.track && \"audio\" === transceiver.sender.track.kind;\n                });\n                !1 === offerOptions.offerToReceiveAudio && audioTransceiver ? \"sendrecv\" === audioTransceiver.direction ? audioTransceiver.setDirection ? audioTransceiver.setDirection(\"sendonly\") : audioTransceiver.direction = \"sendonly\" : \"recvonly\" === audioTransceiver.direction && (audioTransceiver.setDirection ? audioTransceiver.setDirection(\"inactive\") : audioTransceiver.direction = \"inactive\") : !0 !== offerOptions.offerToReceiveAudio || audioTransceiver || pc.addTransceiver(\"audio\"), void 0 !== offerOptions.offerToReceiveVideo && (offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo);\n                var videoTransceiver = pc.getTransceivers().find(function (transceiver) {\n                  return transceiver.sender.track && \"video\" === transceiver.sender.track.kind;\n                });\n                !1 === offerOptions.offerToReceiveVideo && videoTransceiver ? \"sendrecv\" === videoTransceiver.direction ? videoTransceiver.setDirection(\"sendonly\") : \"recvonly\" === videoTransceiver.direction && videoTransceiver.setDirection(\"inactive\") : !0 !== offerOptions.offerToReceiveVideo || videoTransceiver || pc.addTransceiver(\"video\");\n              }\n\n              return origCreateOffer.apply(pc, arguments);\n            };\n          }\n        };\n      }, {\n        \"../utils\": 14\n      }],\n      14: [function (requirecopy, module, exports) {\n        \"use strict\";\n\n        function extractVersion(uastring, expr, pos) {\n          var match = uastring.match(expr);\n          return match && match.length >= pos && parseInt(match[pos], 10);\n        }\n\n        function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {\n          if (window.RTCPeerConnection) {\n            var proto = window.RTCPeerConnection.prototype,\n                nativeAddEventListener = proto.addEventListener;\n\n            proto.addEventListener = function (nativeEventName, cb) {\n              if (nativeEventName !== eventNameToWrap) return nativeAddEventListener.apply(this, arguments);\n\n              var wrappedCallback = function wrappedCallback(e) {\n                var modifiedEvent = wrapper(e);\n                modifiedEvent && cb(modifiedEvent);\n              };\n\n              return this._eventMap = this._eventMap || {}, this._eventMap[cb] = wrappedCallback, nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);\n            };\n\n            var nativeRemoveEventListener = proto.removeEventListener;\n            proto.removeEventListener = function (nativeEventName, cb) {\n              if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[cb]) return nativeRemoveEventListener.apply(this, arguments);\n              var unwrappedCb = this._eventMap[cb];\n              return delete this._eventMap[cb], nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);\n            }, Object.defineProperty(proto, \"on\" + eventNameToWrap, {\n              get: function get() {\n                return this[\"_on\" + eventNameToWrap];\n              },\n              set: function set(cb) {\n                this[\"_on\" + eventNameToWrap] && (this.removeEventListener(eventNameToWrap, this[\"_on\" + eventNameToWrap]), delete this[\"_on\" + eventNameToWrap]), cb && this.addEventListener(eventNameToWrap, this[\"_on\" + eventNameToWrap] = cb);\n              },\n              enumerable: !0,\n              configurable: !0\n            });\n          }\n        }\n\n        var logDisabled_ = !0,\n            deprecationWarnings_ = !0;\n        module.exports = {\n          extractVersion: extractVersion,\n          wrapPeerConnectionEvent: wrapPeerConnectionEvent,\n          disableLog: function disableLog(bool) {\n            return \"boolean\" != typeof bool ? new Error(\"Argument type: \" + typeof bool + \". Please use a boolean.\") : (logDisabled_ = bool, bool ? \"adapter.js logging disabled\" : \"adapter.js logging enabled\");\n          },\n          disableWarnings: function disableWarnings(bool) {\n            return \"boolean\" != typeof bool ? new Error(\"Argument type: \" + typeof bool + \". Please use a boolean.\") : (deprecationWarnings_ = !bool, \"adapter.js deprecation warnings \" + (bool ? \"disabled\" : \"enabled\"));\n          },\n          log: function log() {\n            if (\"object\" == typeof window) {\n              if (logDisabled_) return;\n              \"undefined\" != typeof console && \"function\" == typeof console.log && console.log.apply(console, arguments);\n            }\n          },\n          deprecated: function deprecated(oldMethod, newMethod) {\n            deprecationWarnings_ && console.warn(oldMethod + \" is deprecated, please use \" + newMethod + \" instead.\");\n          },\n          detectBrowser: function detectBrowser(window) {\n            var navigator = window && window.navigator,\n                result = {};\n            if (result.browser = null, result.version = null, void 0 === window || !window.navigator) return result.browser = \"Not a browser.\", result;\n            if (navigator.mozGetUserMedia) result.browser = \"firefox\", result.version = extractVersion(navigator.userAgent, /Firefox\\/(\\d+)\\./, 1);else if (navigator.webkitGetUserMedia) result.browser = \"chrome\", result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) result.browser = \"edge\", result.version = extractVersion(navigator.userAgent, /Edge\\/(\\d+).(\\d+)$/, 2);else {\n              if (!window.RTCPeerConnection || !navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) return result.browser = \"Not a supported browser.\", result;\n              result.browser = \"safari\", result.version = extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1);\n            }\n            return result;\n          }\n        };\n      }, {}]\n    }, {}, [3])(3);\n  }), navigator.mozGetUserMedia ? (MediaStreamTrack.getSources = function (successCb) {\n    setTimeout(function () {\n      successCb([{\n        kind: \"audio\",\n        id: \"default\",\n        label: \"\",\n        facing: \"\"\n      }, {\n        kind: \"video\",\n        id: \"default\",\n        label: \"\",\n        facing: \"\"\n      }]);\n    }, 0);\n  }, attachMediaStream = function attachMediaStream(element, stream) {\n    return element.srcObject = stream, element;\n  }, reattachMediaStream = function reattachMediaStream(to, from) {\n    return to.srcObject = from.srcObject, to;\n  }) : navigator.webkitGetUserMedia ? (attachMediaStream = function attachMediaStream(element, stream) {\n    return AdapterJS.webrtcDetectedVersion >= 43 ? element.srcObject = stream : void 0 !== element.src ? element.src = URL.createObjectURL(stream) : console.error(\"Error attaching stream to element.\"), element;\n  }, reattachMediaStream = function reattachMediaStream(to, from) {\n    return AdapterJS.webrtcDetectedVersion >= 43 ? to.srcObject = from.srcObject : to.src = from.src, to;\n  }) : \"AppleWebKit\" === AdapterJS.webrtcDetectedType ? (attachMediaStream = function attachMediaStream(element, stream) {\n    return element.srcObject = stream, element;\n  }, reattachMediaStream = function reattachMediaStream(to, from) {\n    return to.srcObject = from.srcObject, to;\n  }, navigator.mediaDevices && navigator.mediaDevices.getUserMedia && (navigator.getUserMedia = getUserMedia = function getUserMedia(constraints, successCb, errorCb) {\n    navigator.mediaDevices.getUserMedia(constraints).then(successCb).catch(errorCb);\n  })) : navigator.mediaDevices && navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/) && (attachMediaStream = function attachMediaStream(element, stream) {\n    return element.srcObject = stream, element;\n  }, reattachMediaStream = function reattachMediaStream(to, from) {\n    return to.srcObject = from.srcObject, to;\n  });\n  var attachMediaStream_base = attachMediaStream;\n  \"opera\" === AdapterJS.webrtcDetectedBrowser && (attachMediaStream_base = function attachMediaStream_base(element, stream) {\n    AdapterJS.webrtcDetectedVersion > 38 ? element.srcObject = stream : void 0 !== element.src && (element.src = URL.createObjectURL(stream));\n  }), attachMediaStream = function attachMediaStream(element, stream) {\n    return \"chrome\" !== AdapterJS.webrtcDetectedBrowser && \"opera\" !== AdapterJS.webrtcDetectedBrowser || stream ? attachMediaStream_base(element, stream) : element.src = \"\", element;\n  };\n  var reattachMediaStream_base = reattachMediaStream;\n  reattachMediaStream = function reattachMediaStream(to, from) {\n    return reattachMediaStream_base(to, from), to;\n  }, window.attachMediaStream = attachMediaStream, window.reattachMediaStream = reattachMediaStream, window.getUserMedia = function (constraints, onSuccess, onFailure) {\n    navigator.getUserMedia(constraints, onSuccess, onFailure);\n  }, AdapterJS.attachMediaStream = attachMediaStream, AdapterJS.reattachMediaStream = reattachMediaStream, AdapterJS.getUserMedia = getUserMedia, \"undefined\" == typeof Promise && (requestUserMedia = null), AdapterJS.maybeThroughWebRTCReady();\n} else \"object\" == typeof console && \"function\" == typeof console.log || (console = {} || console, console.log = function (arg) {}, console.info = function (arg) {}, console.error = function (arg) {}, console.dir = function (arg) {}, console.exception = function (arg) {}, console.trace = function (arg) {}, console.warn = function (arg) {}, console.count = function (arg) {}, console.debug = function (arg) {}, console.count = function (arg) {}, console.time = function (arg) {}, console.timeEnd = function (arg) {}, console.group = function (arg) {}, console.groupCollapsed = function (arg) {}, console.groupEnd = function (arg) {}), AdapterJS.WebRTCPlugin.WaitForPluginReady = function () {\n  for (; AdapterJS.WebRTCPlugin.pluginState !== AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY;) {\n    ;\n  }\n}, AdapterJS.WebRTCPlugin.callWhenPluginReady = function (callback) {\n  if (AdapterJS.WebRTCPlugin.pluginState === AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) callback();else var checkPluginReadyState = setInterval(function () {\n    AdapterJS.WebRTCPlugin.pluginState === AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY && (clearInterval(checkPluginReadyState), callback());\n  }, 100);\n}, AdapterJS.WebRTCPlugin.setLogLevel = function (logLevel) {\n  AdapterJS.WebRTCPlugin.callWhenPluginReady(function () {\n    AdapterJS.WebRTCPlugin.plugin.setLogLevel(logLevel);\n  });\n}, AdapterJS.WebRTCPlugin.injectPlugin = function () {\n  if (AdapterJS.documentReady() && AdapterJS.WebRTCPlugin.pluginState === AdapterJS.WebRTCPlugin.PLUGIN_STATES.INITIALIZING) {\n    AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INJECTING;\n    var existing = document.getElementById(AdapterJS.WebRTCPlugin.pluginInfo.pluginId);\n    if (existing) {\n      if (AdapterJS.WebRTCPlugin.plugin = existing, AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INJECTED, AdapterJS.WebRTCPlugin.plugin.valid) window[AdapterJS.WebRTCPlugin.pluginInfo.onload]();else var pluginValidInterval = setInterval(function () {\n        AdapterJS.WebRTCPlugin.plugin.valid && (clearInterval(pluginValidInterval), window[AdapterJS.WebRTCPlugin.pluginInfo.onload]());\n      }, 100);\n    } else {\n      if (\"IE\" === AdapterJS.webrtcDetectedBrowser && AdapterJS.webrtcDetectedVersion <= 10) {\n        var frag = document.createDocumentFragment();\n\n        for (AdapterJS.WebRTCPlugin.plugin = document.createElement(\"div\"), AdapterJS.WebRTCPlugin.plugin.innerHTML = '<object id=\"' + AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '\" type=\"' + AdapterJS.WebRTCPlugin.pluginInfo.type + '\" width=\"1\" height=\"1\"><param name=\"pluginId\" value=\"' + AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '\" /> <param name=\"windowless\" value=\"false\" /> <param name=\"pageId\" value=\"' + AdapterJS.WebRTCPlugin.pageId + '\" /> <param name=\"onload\" value=\"' + AdapterJS.WebRTCPlugin.pluginInfo.onload + '\" /><param name=\"tag\" value=\"' + AdapterJS.WebRTCPlugin.TAGS.NONE + '\" />' + (AdapterJS.options.getAllCams ? '<param name=\"forceGetAllCams\" value=\"True\" />' : \"\") + \"</object>\"; AdapterJS.WebRTCPlugin.plugin.firstChild;) {\n          frag.appendChild(AdapterJS.WebRTCPlugin.plugin.firstChild);\n        }\n\n        document.body.appendChild(frag), AdapterJS.WebRTCPlugin.plugin = document.getElementById(AdapterJS.WebRTCPlugin.pluginInfo.pluginId);\n      } else AdapterJS.WebRTCPlugin.plugin = document.createElement(\"object\"), AdapterJS.WebRTCPlugin.plugin.id = AdapterJS.WebRTCPlugin.pluginInfo.pluginId, \"IE\" === AdapterJS.webrtcDetectedBrowser ? (AdapterJS.WebRTCPlugin.plugin.width = \"1px\", AdapterJS.WebRTCPlugin.plugin.height = \"1px\") : (AdapterJS.WebRTCPlugin.plugin.width = \"0px\", AdapterJS.WebRTCPlugin.plugin.height = \"0px\"), AdapterJS.WebRTCPlugin.plugin.type = AdapterJS.WebRTCPlugin.pluginInfo.type, AdapterJS.WebRTCPlugin.plugin.innerHTML = '<param name=\"onload\" value=\"' + AdapterJS.WebRTCPlugin.pluginInfo.onload + '\"><param name=\"pluginId\" value=\"' + AdapterJS.WebRTCPlugin.pluginInfo.pluginId + '\"><param name=\"windowless\" value=\"false\" /> ' + (AdapterJS.options.getAllCams ? '<param name=\"forceGetAllCams\" value=\"True\" />' : \"\") + '<param name=\"pageId\" value=\"' + AdapterJS.WebRTCPlugin.pageId + '\"><param name=\"tag\" value=\"' + AdapterJS.WebRTCPlugin.TAGS.NONE + '\" />', document.body.appendChild(AdapterJS.WebRTCPlugin.plugin);\n\n      AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INJECTED;\n    }\n  }\n}, AdapterJS.WebRTCPlugin.isPluginInstalled = function (comName, plugName, plugType, installedCb, notInstalledCb) {\n  if (\"IE\" !== AdapterJS.webrtcDetectedBrowser) {\n    var pluginArray = navigator.mimeTypes;\n\n    if (void 0 !== pluginArray) {\n      for (var i = 0; i < pluginArray.length; i++) {\n        if (pluginArray[i].type.indexOf(plugType) >= 0) return void installedCb();\n      }\n\n      notInstalledCb();\n    } else AdapterJS.renderNotificationBar(AdapterJS.TEXT.PLUGIN.NOT_SUPPORTED);\n  } else {\n    try {\n      new ActiveXObject(comName + \".\" + plugName);\n    } catch (e) {\n      return void notInstalledCb();\n    }\n\n    installedCb();\n  }\n}, AdapterJS.WebRTCPlugin.defineWebRTCInterface = function () {\n  if (AdapterJS.WebRTCPlugin.pluginState === AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY) return void console.error(\"AdapterJS - WebRTC interface has already been defined\");\n  AdapterJS.WebRTCPlugin.pluginState = AdapterJS.WebRTCPlugin.PLUGIN_STATES.INITIALIZING, AdapterJS.isDefined = function (variable) {\n    return null !== variable && void 0 !== variable;\n  }, RTCSessionDescription = function RTCSessionDescription(info) {\n    return AdapterJS.WebRTCPlugin.WaitForPluginReady(), AdapterJS.WebRTCPlugin.plugin.ConstructSessionDescription(info.type, info.sdp);\n  }, MediaStream = function MediaStream(mediaStreamOrTracks) {\n    return AdapterJS.WebRTCPlugin.WaitForPluginReady(), AdapterJS.WebRTCPlugin.plugin.MediaStream(mediaStreamOrTracks);\n  }, RTCPeerConnection = function RTCPeerConnection(servers, constraints) {\n    if (void 0 !== servers && null !== servers && !Array.isArray(servers.iceServers)) throw new Error(\"Failed to construct 'RTCPeerConnection': Malformed RTCConfiguration\");\n\n    if (void 0 !== constraints && null !== constraints) {\n      var invalidConstraits = !1;\n      if (invalidConstraits |= \"object\" != typeof constraints, invalidConstraits |= constraints.hasOwnProperty(\"mandatory\") && void 0 !== constraints.mandatory && null !== constraints.mandatory && constraints.mandatory.constructor !== Object, invalidConstraits |= constraints.hasOwnProperty(\"optional\") && void 0 !== constraints.optional && null !== constraints.optional && !Array.isArray(constraints.optional)) throw new Error(\"Failed to construct 'RTCPeerConnection': Malformed constraints object\");\n    }\n\n    AdapterJS.WebRTCPlugin.WaitForPluginReady();\n    var iceServers = null;\n\n    if (servers && Array.isArray(servers.iceServers)) {\n      iceServers = servers.iceServers;\n\n      for (var i = 0; i < iceServers.length; i++) {\n        iceServers[i].urls && !iceServers[i].url && (iceServers[i].url = iceServers[i].urls), iceServers[i].hasCredentials = AdapterJS.isDefined(iceServers[i].username) && AdapterJS.isDefined(iceServers[i].credential);\n      }\n    }\n\n    if (AdapterJS.WebRTCPlugin.plugin.PEER_CONNECTION_VERSION && AdapterJS.WebRTCPlugin.plugin.PEER_CONNECTION_VERSION > 1) return iceServers && (servers.iceServers = iceServers), AdapterJS.WebRTCPlugin.plugin.PeerConnection(servers);\n    var mandatory = constraints && constraints.mandatory ? constraints.mandatory : null,\n        optional = constraints && constraints.optional ? constraints.optional : null;\n    return AdapterJS.WebRTCPlugin.plugin.PeerConnection(AdapterJS.WebRTCPlugin.pageId, iceServers, mandatory, optional);\n  };\n\n  var MediaStreamTrack = function MediaStreamTrack() {};\n\n  MediaStreamTrack.getSources = function (callback) {\n    AdapterJS.WebRTCPlugin.callWhenPluginReady(function () {\n      AdapterJS.WebRTCPlugin.plugin.GetSources(callback);\n    });\n  };\n\n  var constraintsToPlugin = function constraintsToPlugin(c) {\n    if (\"object\" != typeof c || c.mandatory || c.optional) return c;\n    var cc = {};\n    return Object.keys(c).forEach(function (key) {\n      if (\"require\" !== key && \"advanced\" !== key) {\n        if (\"string\" == typeof c[key]) return void (cc[key] = c[key]);\n        var r = \"object\" == typeof c[key] ? c[key] : {\n          ideal: c[key]\n        };\n        void 0 !== r.exact && \"number\" == typeof r.exact && (r.min = r.max = r.exact);\n\n        var oldname = function oldname(prefix, name) {\n          return prefix ? prefix + name.charAt(0).toUpperCase() + name.slice(1) : \"deviceId\" === name ? \"sourceId\" : name;\n        };\n\n        if (\"sourceId\" === oldname(\"\", key) && void 0 !== r.exact && (r.ideal = r.exact, r.exact = void 0), void 0 !== r.ideal) {\n          cc.optional = cc.optional || [];\n          var oc = {};\n          \"number\" == typeof r.ideal ? (oc[oldname(\"min\", key)] = r.ideal, cc.optional.push(oc), oc = {}, oc[oldname(\"max\", key)] = r.ideal, cc.optional.push(oc)) : (oc[oldname(\"\", key)] = r.ideal, cc.optional.push(oc));\n        }\n\n        void 0 !== r.exact && \"number\" != typeof r.exact ? (cc.mandatory = cc.mandatory || {}, cc.mandatory[oldname(\"\", key)] = r.exact) : [\"min\", \"max\"].forEach(function (mix) {\n          void 0 !== r[mix] && (cc.mandatory = cc.mandatory || {}, cc.mandatory[oldname(mix, key)] = r[mix]);\n        });\n      }\n    }), c.advanced && (cc.optional = (cc.optional || []).concat(c.advanced)), cc;\n  };\n\n  getUserMedia = function getUserMedia(constraints, successCallback, failureCallback) {\n    var cc = {};\n    cc.audio = !!constraints.audio && constraintsToPlugin(constraints.audio), cc.video = !!constraints.video && constraintsToPlugin(constraints.video), AdapterJS.WebRTCPlugin.callWhenPluginReady(function () {\n      AdapterJS.WebRTCPlugin.plugin.getUserMedia(cc, successCallback, failureCallback);\n    });\n  }, window.navigator.getUserMedia = getUserMedia, \"undefined\" != typeof Promise && (requestUserMedia = function requestUserMedia(constraints) {\n    return new Promise(function (resolve, reject) {\n      try {\n        getUserMedia(constraints, resolve, reject);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }, void 0 === navigator.mediaDevices && (navigator.mediaDevices = {}), navigator.mediaDevices.getUserMedia = requestUserMedia, navigator.mediaDevices.enumerateDevices = function () {\n    return new Promise(function (resolve) {\n      var kinds = {\n        audio: \"audioinput\",\n        video: \"videoinput\"\n      };\n      return MediaStreamTrack.getSources(function (devices) {\n        resolve(devices.map(function (device) {\n          return {\n            label: device.label,\n            kind: kinds[device.kind],\n            id: device.id,\n            deviceId: device.id,\n            groupId: \"\"\n          };\n        }));\n      });\n    });\n  }), attachMediaStream = function attachMediaStream(element, stream) {\n    if (element && element.parentNode) {\n      var streamId;\n      null === stream ? streamId = \"\" : (void 0 !== stream.enableSoundTracks && stream.enableSoundTracks(!0), streamId = stream.id);\n      var elementId = 0 === element.id.length ? Math.random().toString(36).slice(2) : element.id,\n          nodeName = element.nodeName.toLowerCase();\n\n      if (\"object\" !== nodeName) {\n        var tag;\n\n        switch (nodeName) {\n          case \"audio\":\n            tag = AdapterJS.WebRTCPlugin.TAGS.AUDIO;\n            break;\n\n          case \"video\":\n            tag = AdapterJS.WebRTCPlugin.TAGS.VIDEO;\n            break;\n\n          default:\n            tag = AdapterJS.WebRTCPlugin.TAGS.NONE;\n        }\n\n        var frag = document.createDocumentFragment(),\n            temp = document.createElement(\"div\"),\n            classHTML = \"\";\n\n        for (element.className ? classHTML = 'class=\"' + element.className + '\" ' : element.attributes && element.attributes.class && (classHTML = 'class=\"' + element.attributes.class.value + '\" '), temp.innerHTML = '<object id=\"' + elementId + '\" ' + classHTML + 'type=\"' + AdapterJS.WebRTCPlugin.pluginInfo.type + '\"><param name=\"pluginId\" value=\"' + elementId + '\" /> <param name=\"pageId\" value=\"' + AdapterJS.WebRTCPlugin.pageId + '\" /> <param name=\"windowless\" value=\"true\" /> <param name=\"streamId\" value=\"' + streamId + '\" /> <param name=\"tag\" value=\"' + tag + '\" /> </object>'; temp.firstChild;) {\n          frag.appendChild(temp.firstChild);\n        }\n\n        var height = \"\",\n            width = \"\";\n        element.clientWidth || element.clientHeight ? (width = element.clientWidth, height = element.clientHeight) : (element.width || element.height) && (width = element.width, height = element.height), element.parentNode.insertBefore(frag, element), frag = document.getElementById(elementId), frag.width = width, frag.height = height, element.parentNode.removeChild(element);\n      } else {\n        for (var children = element.children, i = 0; i !== children.length; ++i) {\n          if (\"streamId\" === children[i].name) {\n            children[i].value = streamId;\n            break;\n          }\n        }\n\n        element.setStreamId(streamId);\n      }\n\n      var newElement = document.getElementById(elementId);\n      return AdapterJS.forwardEventHandlers(newElement, element, Object.getPrototypeOf(element)), newElement;\n    }\n  }, reattachMediaStream = function reattachMediaStream(to, from) {\n    for (var stream = null, children = from.children, i = 0; i !== children.length; ++i) {\n      if (\"streamId\" === children[i].name) {\n        AdapterJS.WebRTCPlugin.WaitForPluginReady(), stream = AdapterJS.WebRTCPlugin.plugin.getStreamWithId(AdapterJS.WebRTCPlugin.pageId, children[i].value);\n        break;\n      }\n    }\n\n    if (null !== stream) return attachMediaStream(to, stream);\n    console.log(\"Could not find the stream associated with this element\");\n  }, window.attachMediaStream = attachMediaStream, window.reattachMediaStream = reattachMediaStream, window.getUserMedia = getUserMedia, AdapterJS.attachMediaStream = attachMediaStream, AdapterJS.reattachMediaStream = reattachMediaStream, AdapterJS.getUserMedia = getUserMedia, AdapterJS.forwardEventHandlers = function (destElem, srcElem, prototype) {\n    var properties = Object.getOwnPropertyNames(prototype);\n\n    for (var prop in properties) {\n      if (prop) {\n        var propName = properties[prop];\n        \"function\" == typeof propName.slice && \"on\" === propName.slice(0, 2) && \"function\" == typeof srcElem[propName] && AdapterJS.addEvent(destElem, propName.slice(2), srcElem[propName]);\n      }\n    }\n\n    var subPrototype = Object.getPrototypeOf(prototype);\n    subPrototype && AdapterJS.forwardEventHandlers(destElem, srcElem, subPrototype);\n  }, RTCIceCandidate = function RTCIceCandidate(candidate) {\n    return candidate.sdpMid || (candidate.sdpMid = \"\"), AdapterJS.WebRTCPlugin.WaitForPluginReady(), AdapterJS.WebRTCPlugin.plugin.ConstructIceCandidate(candidate.sdpMid, candidate.sdpMLineIndex, candidate.candidate);\n  }, AdapterJS.addEvent(document, \"readystatechange\", AdapterJS.WebRTCPlugin.injectPlugin), AdapterJS.WebRTCPlugin.injectPlugin();\n}, AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb = AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb || function () {\n  AdapterJS.addEvent(document, \"readystatechange\", AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv), AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv();\n}, AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv = function () {\n  if (AdapterJS.documentReady() && (document.removeEventListener(\"readystatechange\", AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv), !AdapterJS.options.hidePluginInstallPrompt)) {\n    var downloadLink = AdapterJS.WebRTCPlugin.pluginInfo.downloadLink;\n\n    if (downloadLink) {\n      var popupString;\n      AdapterJS.WebRTCPlugin.pluginInfo.companyName ? (popupString = \"This website requires you to install the \", AdapterJS.WebRTCPlugin.pluginInfo.portalLink ? popupString += ' <a href=\"' + AdapterJS.WebRTCPlugin.pluginInfo.portalLink + '\" target=\"_blank\">' + AdapterJS.WebRTCPlugin.pluginInfo.companyName + \" WebRTC Plugin</a>\" : popupString += AdapterJS.WebRTCPlugin.pluginInfo.companyName + \" WebRTC Plugin\", popupString += \" to work on this browser.\") : popupString = AdapterJS.TEXT.PLUGIN.REQUIRE_INSTALLATION, AdapterJS.renderNotificationBar(popupString, AdapterJS.TEXT.PLUGIN.BUTTON, function () {\n        if (window.open(downloadLink, \"_top\"), \"safari\" === webrtcDetectedBrowser && 11 == webrtcDetectedVersion) AdapterJS.renderNotificationBar(AdapterJS.TEXT.PLUGIN.REQUIRE_RESTART);else var pluginInstallInterval = setInterval(function () {\n          \"IE\" !== AdapterJS.webrtcDetectedBrowser && navigator.plugins.refresh(!1), AdapterJS.WebRTCPlugin.isPluginInstalled(AdapterJS.WebRTCPlugin.pluginInfo.prefix, AdapterJS.WebRTCPlugin.pluginInfo.plugName, AdapterJS.WebRTCPlugin.pluginInfo.type, function () {\n            clearInterval(pluginInstallInterval), AdapterJS.WebRTCPlugin.defineWebRTCInterface();\n          }, function () {});\n        }, 500);\n      });\n    } else AdapterJS.renderNotificationBar(AdapterJS.TEXT.PLUGIN.NOT_SUPPORTED);\n  }\n}, AdapterJS.WebRTCPlugin.isPluginInstalled(AdapterJS.WebRTCPlugin.pluginInfo.prefix, AdapterJS.WebRTCPlugin.pluginInfo.plugName, AdapterJS.WebRTCPlugin.pluginInfo.type, AdapterJS.WebRTCPlugin.defineWebRTCInterface, AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb);\n\n\"undefined\" != typeof exports && (module.exports = AdapterJS), AdapterJS.TEXT.EXTENSION = {\n  REQUIRE_INSTALLATION_FF: \"To enable screensharing you need to install the Skylink WebRTC tools Firefox Add-on.\",\n  REQUIRE_INSTALLATION_CHROME: \"To enable screensharing you need to install the Skylink WebRTC tools Chrome Extension.\",\n  REQUIRE_REFRESH: \"Please refresh this page after the Skylink WebRTC tools extension has been installed.\",\n  BUTTON_FF: \"Install Now\",\n  BUTTON_CHROME: \"Go to Chrome Web Store\"\n}, AdapterJS.extensionInfo = AdapterJS.extensionInfo || {\n  chrome: {\n    extensionId: \"ljckddiekopnnjoeaiofddfhgnbdoafc\",\n    extensionLink: \"https://chrome.google.com/webstore/detail/skylink-webrtc-tools/ljckddiekopnnjoeaiofddfhgnbdoafc\",\n    iframeLink: \"https://cdn.temasys.com.sg/skylink/extensions/detectRTC.html\"\n  },\n  firefox: {\n    extensionLink: \"https://addons.mozilla.org/en-US/firefox/addon/skylink-webrtc-tools/\"\n  },\n  opera: {\n    extensionId: null,\n    extensionLink: null\n  }\n}, AdapterJS._mediaSourcePolyfillIsDefined = !1, AdapterJS._defineMediaSourcePolyfill = function () {\n  if (!AdapterJS._mediaSourcePolyfillIsDefined) {\n    AdapterJS._mediaSourcePolyfillIsDefined = !0;\n\n    var baseGetUserMedia = null,\n        clone = function clone(obj) {\n      if (null === obj || \"object\" != typeof obj) return obj;\n      var copy = obj.constructor();\n\n      for (var attr in obj) {\n        obj.hasOwnProperty(attr) && (copy[attr] = obj[attr]);\n      }\n\n      return copy;\n    },\n        checkIfConstraintsIsValid = function checkIfConstraintsIsValid(constraints, successCb, failureCb) {\n      if (!constraints || \"object\" != typeof constraints) throw new Error(\"GetUserMedia: (constraints, .., ..) argument required\");\n      if (\"function\" != typeof successCb) throw new Error(\"GetUserMedia: (.., successCb, ..) argument required\");\n      if (\"function\" != typeof failureCb) throw new Error(\"GetUserMedia: (.., .., failureCb) argument required\");\n    };\n\n    if (\"moz\" === AdapterJS.webrtcDetectedType) baseGetUserMedia = window.navigator.getUserMedia, navigator.getUserMedia = function (constraints, successCb, failureCb) {\n      if (checkIfConstraintsIsValid(constraints, successCb, failureCb), constraints.video && \"object\" == typeof constraints.video && constraints.video.hasOwnProperty(\"mediaSource\")) {\n        var updatedConstraints = clone(constraints),\n            mediaSourcesList = [\"screen\", \"window\", \"application\", \"browser\", \"camera\"],\n            useExtensionErrors = [\"NotAllowedError\", \"PermissionDeniedError\", \"SecurityError\"];\n\n        if (Array.isArray(updatedConstraints.video.mediaSource)) {\n          for (var i = 0; i < updatedConstraints.video.mediaSource.length;) {\n            if (mediaSourcesList.indexOf(updatedConstraints.video.mediaSource[i]) > -1) {\n              updatedConstraints.video.mediaSource = updatedConstraints.video.mediaSource[i];\n              break;\n            }\n\n            i++;\n          }\n\n          updatedConstraints.video.mediaSource = \"string\" == typeof updatedConstraints.video.mediaSource ? updatedConstraints.video.mediaSource : null;\n        }\n\n        if (-1 === mediaSourcesList.indexOf(updatedConstraints.video.mediaSource)) return void failureCb(new Error('GetUserMedia: Only \"screen\" and \"window\" are supported as mediaSource constraints'));\n        var checkIfReady = setInterval(function () {\n          \"complete\" === document.readyState && (clearInterval(checkIfReady), updatedConstraints.video.mozMediaSource = updatedConstraints.video.mediaSource, baseGetUserMedia(updatedConstraints, successCb, function (error) {\n            useExtensionErrors.indexOf(error.name) > -1 && AdapterJS.webrtcDetectedVersion < 52 && \"https:\" === window.parent.location.protocol ? AdapterJS.renderNotificationBar(AdapterJS.TEXT.EXTENSION.REQUIRE_INSTALLATION_FF, AdapterJS.TEXT.EXTENSION.BUTTON_FF, function (e) {\n              window.open(AdapterJS.extensionInfo.firefox.extensionLink, \"_blank\"), e.target && e.target.parentElement && e.target.nextElementSibling && e.target.nextElementSibling.click && e.target.nextElementSibling.click(), AdapterJS.renderNotificationBar(AdapterJS.TEXT.EXTENSION ? AdapterJS.TEXT.EXTENSION.REQUIRE_REFRESH : AdapterJS.TEXT.REFRESH.REQUIRE_REFRESH, AdapterJS.TEXT.REFRESH.BUTTON, function () {\n                window.open(\"javascript:location.reload()\", \"_top\");\n              });\n            }) : failureCb(error);\n          }));\n        }, 1);\n      } else baseGetUserMedia(constraints, successCb, failureCb);\n    }, AdapterJS.getUserMedia = window.getUserMedia = navigator.getUserMedia;else if (\"webkit\" === AdapterJS.webrtcDetectedType) {\n      baseGetUserMedia = window.navigator.getUserMedia;\n      var iframe = document.createElement(\"iframe\");\n\n      if (navigator.getUserMedia = function (constraints, successCb, failureCb) {\n        if (checkIfConstraintsIsValid(constraints, successCb, failureCb), constraints.video && \"object\" == typeof constraints.video && constraints.video.hasOwnProperty(\"mediaSource\")) {\n          var updatedConstraints = clone(constraints),\n              mediaSourcesList = [\"window\", \"screen\", \"tab\", \"audio\"];\n          if (navigator.userAgent.toLowerCase().indexOf(\"android\") > -1) return void ((Array.isArray(updatedConstraints.video.mediaSource) ? updatedConstraints.video.mediaSource.indexOf(\"screen\") > -1 : \"screen\" === updatedConstraints.video.mediaSource) ? (updatedConstraints.video.mandatory = updatedConstraints.video.mandatory || {}, updatedConstraints.video.mandatory.chromeMediaSource = \"screen\", updatedConstraints.video.mandatory.maxHeight = window.screen.height, updatedConstraints.video.mandatory.maxWidth = window.screen.width, delete updatedConstraints.video.mediaSource, baseGetUserMedia(updatedConstraints, successCb, failureCb)) : failureCb(new Error('GetUserMedia: Only \"screen\" are supported as mediaSource constraints for Android')));\n          if (!(\"opera\" === AdapterJS.webrtcDetectedBrowser ? !!AdapterJS.extensionInfo.opera.extensionId : \"chrome\" === AdapterJS.webrtcDetectedBrowser)) return void failureCb(new Error(\"Current browser does not support screensharing\"));\n          if (\"string\" == typeof updatedConstraints.video.mediaSource && mediaSourcesList.indexOf(updatedConstraints.video.mediaSource) > -1 && \"audio\" !== updatedConstraints.video.mediaSource) updatedConstraints.video.mediaSource = [updatedConstraints.video.mediaSource];else if (Array.isArray(updatedConstraints.video.mediaSource)) {\n            for (var i = 0, outputMediaSource = []; i < mediaSourcesList.length;) {\n              for (var j = 0; j < updatedConstraints.video.mediaSource.length;) {\n                mediaSourcesList[i] === updatedConstraints.video.mediaSource[j] && outputMediaSource.push(updatedConstraints.video.mediaSource[j]), j++;\n              }\n\n              i++;\n            }\n\n            updatedConstraints.video.mediaSource = outputMediaSource;\n          } else updatedConstraints.video.mediaSource = [];\n          if (updatedConstraints.video.mediaSource.indexOf(\"audio\") > -1 && -1 === updatedConstraints.video.mediaSource.indexOf(\"tab\")) return void failureCb(new Error('GetUserMedia: \"audio\" mediaSource must be provided with [\"audio\", \"tab\"]'));\n          if (0 === updatedConstraints.video.mediaSource.length) return void failureCb(new Error('GetUserMedia: Only \"screen\", \"window\", \"tab\" are supported as mediaSource constraints'));\n          updatedConstraints.video.mediaSource.indexOf(\"tab\") > -1 && updatedConstraints.video.mediaSource.indexOf(\"audio\") > -1 && !updatedConstraints.audio && console.warn('Audio must be requested if \"tab\" and \"audio\" mediaSource constraints is requested');\n\n          var fetchStream = function fetchStream(response) {\n            response.success ? (updatedConstraints.video.mandatory = updatedConstraints.video.mandatory || {}, updatedConstraints.video.mandatory.chromeMediaSource = \"desktop\", updatedConstraints.video.mandatory.maxWidth = window.screen.width > 1920 ? window.screen.width : 1920, updatedConstraints.video.mandatory.maxHeight = window.screen.height > 1080 ? window.screen.height : 1080, updatedConstraints.video.mandatory.chromeMediaSourceId = response.sourceId, Array.isArray(updatedConstraints.video.mediaSource) && updatedConstraints.video.mediaSource.indexOf(\"tab\") > -1 && updatedConstraints.video.mediaSource.indexOf(\"audio\") > -1 && updatedConstraints.audio && (updatedConstraints.audio = \"object\" == typeof updatedConstraints.audio ? updatedConstraints.audio : {}, updatedConstraints.audio.mandatory = updatedConstraints.audio.mandatory || {}, updatedConstraints.audio.mandatory.chromeMediaSource = \"desktop\", updatedConstraints.audio.mandatory.chromeMediaSourceId = response.sourceId), delete updatedConstraints.video.mediaSource, baseGetUserMedia(updatedConstraints, successCb, failureCb)) : (response.extensionLink && AdapterJS.renderNotificationBar(AdapterJS.TEXT.EXTENSION.REQUIRE_INSTALLATION_CHROME, AdapterJS.TEXT.EXTENSION.BUTTON_CHROME, function (e) {\n              window.open(response.extensionLink, \"_blank\"), e.target && e.target.parentElement && e.target.nextElementSibling && e.target.nextElementSibling.click && e.target.nextElementSibling.click(), AdapterJS.renderNotificationBar(AdapterJS.TEXT.EXTENSION ? AdapterJS.TEXT.EXTENSION.REQUIRE_REFRESH : AdapterJS.TEXT.REFRESH.REQUIRE_REFRESH, AdapterJS.TEXT.REFRESH.BUTTON, function () {\n                window.open(\"javascript:location.reload()\", \"_top\");\n              });\n            }), failureCb(response.error));\n          };\n\n          if (AdapterJS.extensionInfo.chrome.iframeLink && \"opera\" !== AdapterJS.webrtcDetectedBrowser) iframe.getSourceId(updatedConstraints.video.mediaSource, fetchStream);else {\n            var extensionId = AdapterJS.extensionInfo[\"opera\" === AdapterJS.webrtcDetectedBrowser ? \"opera\" : \"chrome\"].extensionId,\n                extensionLink = AdapterJS.extensionInfo[\"opera\" === AdapterJS.webrtcDetectedBrowser ? \"opera\" : \"chrome\"].extensionLink,\n                icon = document.createElement(\"img\");\n            icon.src = \"chrome-extension://\" + extensionId + \"/icon.png\", icon.onload = function () {\n              chrome.runtime.sendMessage(extensionId, {\n                type: \"get-version\"\n              }, function (versionRes) {\n                if (!versionRes || \"object\" != typeof versionRes || \"send-version\" !== versionRes.type) return void fetchStream({\n                  success: !1,\n                  error: new Error(\"Extension is disabled\")\n                });\n                chrome.runtime.sendMessage(extensionId, {\n                  type: \"get-source\",\n                  sources: updatedConstraints.video.mediaSource\n                }, function (sourceRes) {\n                  fetchStream(sourceRes && \"object\" == typeof sourceRes ? \"send-source-error\" === sourceRes.type ? {\n                    success: !1,\n                    error: new Error(\"Permission denied for screen retrieval\")\n                  } : {\n                    success: !0,\n                    sourceId: sourceRes.sourceId\n                  } : {\n                    success: !1,\n                    error: new Error(\"Retrieval failed\")\n                  });\n                });\n              });\n            }, icon.onerror = function () {\n              fetchStream({\n                success: !1,\n                error: new Error(\"Extension not installed\"),\n                extensionLink: extensionLink\n              });\n            };\n          }\n        } else baseGetUserMedia(constraints, successCb, failureCb);\n      }, AdapterJS.getUserMedia = window.getUserMedia = navigator.getUserMedia, navigator.mediaDevices.getUserMedia = function (constraints) {\n        return new Promise(function (resolve, reject) {\n          try {\n            window.getUserMedia(constraints, resolve, reject);\n          } catch (error) {\n            reject(error);\n          }\n        });\n      }, \"chrome\" === AdapterJS.webrtcDetectedBrowser) {\n        var states = {\n          loaded: !1,\n          error: !1\n        };\n        if (iframe) try {\n          (document.body || document.documentElement).removeChild(iframe);\n        } catch (e) {}\n        if (!AdapterJS.extensionInfo.chrome.iframeLink) return;\n        iframe.onload = function () {\n          states.loaded = !0;\n        }, iframe.onerror = function () {\n          states.error = !0;\n        }, iframe.src = AdapterJS.extensionInfo.chrome.iframeLink, iframe.style.display = \"none\";\n\n        var getSourceIdFromIFrame = function getSourceIdFromIFrame(sources, cb) {\n          window.addEventListener(\"message\", function iframeListener(evt) {\n            evt.data && \"object\" == typeof evt.data && (\"not-installed\" === evt.data.chromeExtensionStatus ? (window.removeEventListener(\"message\", iframeListener), cb({\n              success: !1,\n              error: new Error(\"Extension is not installed\"),\n              extensionLink: evt.data.data || AdapterJS.extensionInfo.chrome.extensionLink\n            })) : \"installed-disabled\" === evt.data.chromeExtensionStatus ? (window.removeEventListener(\"message\", iframeListener), cb({\n              success: !1,\n              error: new Error(\"Extension is disabled\")\n            })) : \"PermissionDeniedError\" === evt.data.chromeMediaSourceId ? (window.removeEventListener(\"message\", iframeListener), cb({\n              success: !1,\n              error: new Error(\"Permission denied for screen retrieval\")\n            })) : evt.data.chromeMediaSourceId && \"string\" == typeof evt.data.chromeMediaSourceId && (window.removeEventListener(\"message\", iframeListener), cb({\n              success: !0,\n              sourceId: evt.data.chromeMediaSourceId\n            })));\n          }), iframe.contentWindow.postMessage({\n            captureSourceId: !0,\n            sources: sources,\n            legacy: !0,\n            extensionId: AdapterJS.extensionInfo.chrome.extensionId,\n            extensionLink: AdapterJS.extensionInfo.chrome.extensionLink\n          }, \"*\");\n        };\n\n        iframe.getSourceId = function (sources, cb) {\n          if (states.error) return void cb({\n            success: !1,\n            error: new Error(\"iframe is not loaded\")\n          });\n          if (states.loaded) getSourceIdFromIFrame(sources, cb);else var endBlocks = 0,\n              intervalChecker = setInterval(function () {\n            states.loaded ? (clearInterval(intervalChecker), getSourceIdFromIFrame(sources, cb)) : 50 === endBlocks ? (clearInterval(intervalChecker), cb({\n              success: !1,\n              error: new Error(\"iframe failed to load\")\n            })) : endBlocks++;\n          }, 100);\n        }, (document.body || document.documentElement).appendChild(iframe);\n      }\n    } else \"edge\" === AdapterJS.webrtcDetectedBrowser ? console.warn(\"Edge does not support screensharing feature in getUserMedia\") : \"AppleWebKit\" === AdapterJS.webrtcDetectedType ? console.warn(\"Safari does not support screensharing feature in getUserMedia\") : \"plugin\" === AdapterJS.webrtcDetectedType && (AdapterJS.WebRTCPlugin.parseVersion = function (version) {\n      var components = version.split(\".\");\n      return {\n        major: parseInt(components[0]),\n        minor: parseInt(components[1]),\n        revision: parseInt(components[2])\n      };\n    }, AdapterJS.WebRTCPlugin.isVersionGreater = function (v1, v2) {\n      var parsedV1 = AdapterJS.WebRTCPlugin.parseVersion(v1),\n          parsedV2 = AdapterJS.WebRTCPlugin.parseVersion(v2);\n      return parsedV1.major > parsedV2.major || parsedV1.major == parsedV2.major && parsedV1.minor > parsedV2.minor || parsedV1.major == parsedV2.major && parsedV1.minor == parsedV2.minor && parsedV1.revision > parsedV2.revision;\n    }, baseGetUserMedia = window.navigator.getUserMedia, navigator.getUserMedia = function (constraints, successCb, failureCb) {\n      if (checkIfConstraintsIsValid(constraints, successCb, failureCb), constraints.video && \"object\" == typeof constraints.video && constraints.video.hasOwnProperty(\"mediaSource\")) {\n        var updatedConstraints = clone(constraints);\n        AdapterJS.WebRTCPlugin.callWhenPluginReady(function () {\n          if (!AdapterJS.WebRTCPlugin.plugin.HasScreensharingFeature || !AdapterJS.WebRTCPlugin.plugin.isScreensharingAvailable) return void failureCb(new Error(\"Your version of the WebRTC plugin does not support screensharing\"));\n          if (AdapterJS.WebRTCPlugin.plugin.screensharingKeys) if (Array.isArray(updatedConstraints.video.mediaSource) && updatedConstraints.video.mediaSource.indexOf(\"screen\") > -1 && updatedConstraints.video.mediaSource.indexOf(\"window\") > -1 || updatedConstraints.video.mediaSource === AdapterJS.WebRTCPlugin.plugin.screensharingKey || updatedConstraints.video.mediaSource === AdapterJS.WebRTCPlugin.plugin.screensharingKeys.screenOrWindow) updatedConstraints.video.mediaSource = AdapterJS.WebRTCPlugin.plugin.screensharingKeys.screenOrWindow;else if (Array.isArray(updatedConstraints.video.mediaSource) && updatedConstraints.video.mediaSource.indexOf(\"screen\") > -1 || \"screen\" === updatedConstraints.video.mediaSource) updatedConstraints.video.mediaSource = AdapterJS.WebRTCPlugin.plugin.screensharingKeys.screen;else {\n            if (!(Array.isArray(updatedConstraints.video.mediaSource) && updatedConstraints.video.mediaSource.indexOf(\"window\") > -1 || \"window\" === updatedConstraints.video.mediaSource)) return void failureCb(new Error('GetUserMedia: Only \"screen\", \"window\", [\"screen\", \"window\"] are supported as mediaSource constraints'));\n            updatedConstraints.video.mediaSource = AdapterJS.WebRTCPlugin.plugin.screensharingKeys.window;\n          }\n          AdapterJS.WebRTCPlugin.isVersionGreater(AdapterJS.WebRTCPlugin.plugin.VERSION, \"0.8.874\") || (updatedConstraints.video.optional = updatedConstraints.video.optional || [], updatedConstraints.video.optional.push({\n            sourceId: updatedConstraints.video.mediaSource\n          })), baseGetUserMedia(updatedConstraints, successCb, failureCb);\n        });\n      } else baseGetUserMedia(constraints, successCb, failureCb);\n    }, AdapterJS.getUserMedia = getUserMedia = window.getUserMedia = navigator.getUserMedia, navigator.mediaDevices && \"undefined\" != typeof Promise && (navigator.mediaDevices.getUserMedia = requestUserMedia));\n  }\n}, \"function\" != typeof window.require && AdapterJS._defineMediaSourcePolyfill(), function (globals) {\n  \"use strict\";\n\n  function Skylink() {\n    this._dataChannels = {}, this._dataTransfers = {}, this._dataStreams = {}, this._peerCandidatesQueue = {}, this._peerEndOfCandidatesCounter = {}, this._gatheredCandidates = {}, this._retryCounters = {}, this._peerConnections = {}, this._peerStats = {}, this._peerBandwidth = {}, this._peerCustomConfigs = {}, this._peerInformations = {}, this._user = null, this._userData = \"\", this._peerPriorityWeight = 0, this._autoIntroduce = !0, this._isPrivileged = !1, this._peerList = null, this._selectedRoom = null, this._roomLocked = !1, this._inRoom = !1, this._EVENTS = {}, this._onceEvents = {}, this._timestamp = {\n      socketMessage: null,\n      shareScreen: null,\n      refreshConnection: null,\n      getUserMedia: null,\n      lastRestart: null\n    }, this._socketSession = {}, this._socketMessageQueue = [], this._socketMessageTimeout = null, this._socketPorts = {\n      \"http:\": [80, 3e3],\n      \"https:\": [443, 3443]\n    }, this._channelOpen = !1, this._signalingServer = null, this._signalingServerProtocol = window.location.protocol, this._signalingServerPort = null, this._socket = null, this._socketUseXDR = !1, this._enableIceRestart = !1, this._hasMCU = !1, this._path = null, this._readyState = null, this._key = null, this._appKeyOwner = null, this._room = null, this._peerMessagesStamps = {}, this._streams = {\n      userMedia: null,\n      screenshare: null\n    }, this._streamsDefaultSettings = {\n      userMedia: {\n        audio: {\n          stereo: !1\n        },\n        video: {\n          resolution: {\n            width: 640,\n            height: 480\n          },\n          frameRate: 50\n        }\n      },\n      screenshare: {\n        video: !0\n      }\n    }, this._streamsMutedSettings = {\n      audioMuted: !1,\n      videoMuted: !1\n    }, this._streamsBandwidthSettings = {\n      googleX: {},\n      bAS: {}\n    }, this._streamsStoppedCbs = {}, this._streamsSession = {}, this._sdpSettings = {\n      connection: {\n        audio: !0,\n        video: !0,\n        data: !0\n      },\n      direction: {\n        audio: {\n          send: !0,\n          receive: !0\n        },\n        video: {\n          send: !0,\n          receive: !0\n        }\n      }\n    }, this._publishOnly = !1, this._parentId = null, this._recordings = {}, this._currentRecordingId = !1, this._recordingStartInterval = null, this._currentCodecSupport = null, this._sdpSessions = {}, this._voiceActivityDetection = !0, this._binaryChunkType = this.DATA_TRANSFER_DATA_TYPE.ARRAY_BUFFER, this._peerConnectionConfig = {}, this._bandwidthAdjuster = null, this._peerConnStatus = {}, this._joinRoomManager = {\n      timestamp: 0,\n      socketsFn: []\n    }, this._initOptions = {}, this._statIdRandom = Date.now() + Math.floor(1e8 * Math.random());\n  }\n\n  !function () {\n    Object.keys || (Object.keys = function () {\n      var t = Object.prototype.hasOwnProperty,\n          r = !{\n        toString: null\n      }.propertyIsEnumerable(\"toString\"),\n          e = [\"toString\", \"toLocaleString\", \"valueOf\", \"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\", \"constructor\"],\n          o = e.length;\n      return function (n) {\n        if (\"object\" != typeof n && \"function\" != typeof n || null === n) throw new TypeError(\"Object.keys called on non-object\");\n        var c = [];\n\n        for (var l in n) {\n          t.call(n, l) && c.push(l);\n        }\n\n        if (r) for (var p = 0; o > p; p++) {\n          t.call(n, e[p]) && c.push(e[p]);\n        }\n        return c;\n      };\n    }());\n  }(), function () {\n    function t(t) {\n      return 10 > t ? \"0\" + t : t;\n    }\n\n    Date.prototype.toISOString = function () {\n      return this.getUTCFullYear() + \"-\" + t(this.getUTCMonth() + 1) + \"-\" + t(this.getUTCDate()) + \"T\" + t(this.getUTCHours()) + \":\" + t(this.getUTCMinutes()) + \":\" + t(this.getUTCSeconds()) + \".\" + (this.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) + \"Z\";\n    };\n  }(), function () {\n    \"function\" != typeof Date.now && (Date.now = function () {\n      return new Date().getTime();\n    });\n  }(), function (e, t) {\n    function n(e) {\n      var n = t[e];\n\n      t[e] = function (e) {\n        return o(n(e));\n      };\n    }\n\n    function a(t, n, a) {\n      return (a = this).attachEvent(\"on\" + t, function (t) {\n        var t = t || e.event;\n        t.preventDefault = t.preventDefault || function () {\n          t.returnValue = !1;\n        }, t.stopPropagation = t.stopPropagation || function () {\n          t.cancelBubble = !0;\n        }, n.call(a, t);\n      });\n    }\n\n    function o(e, t) {\n      if (t = e.length) for (; t--;) {\n        e[t].addEventListener = a;\n      } else e.addEventListener = a;\n      return e;\n    }\n\n    e.addEventListener || (o([t, e]), \"Element\" in e ? e.Element.prototype.addEventListener = a : (t.attachEvent(\"onreadystatechange\", function () {\n      o(t.all);\n    }), n(\"getElementsByTagName\"), n(\"getElementById\"), n(\"createElement\"), o(t.all)));\n  }(window, document), function () {\n    if (\"performance\" in window == 0 && (window.performance = {}), Date.now = Date.now || function () {\n      return new Date().getTime();\n    }, \"now\" in window.performance == 0) {\n      var a = Date.now();\n      performance.timing && performance.timing.navigationStart && (a = performance.timing.navigationStart), window.performance.now = function () {\n        return Date.now() - a;\n      };\n    }\n  }(), window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder, Array.prototype.forEach || (Array.prototype.forEach = function (callback) {\n    var T, k;\n    if (null == this) throw new TypeError(\"this is null or not defined\");\n    var O = Object(this),\n        len = O.length >>> 0;\n    if (\"function\" != typeof callback) throw new TypeError(callback + \" is not a function\");\n\n    for (arguments.length > 1 && (T = arguments[1]), k = 0; k < len;) {\n      var kValue;\n      k in O && (kValue = O[k], callback.call(T, kValue, k, O)), k++;\n    }\n  });\n\n  var clone = function clone(obj) {\n    if (null === obj || \"object\" != typeof obj) return obj;\n\n    var copy = function copy(data) {\n      var copy = data.constructor();\n\n      for (var attr in data) {\n        data.hasOwnProperty(attr) && (copy[attr] = data[attr]);\n      }\n\n      return copy;\n    };\n\n    if (\"object\" == typeof obj && !Array.isArray(obj)) try {\n      return JSON.parse(JSON.stringify(obj));\n    } catch (err) {\n      return copy(obj);\n    }\n    return copy(obj);\n  };\n\n  Skylink.prototype.DATA_CHANNEL_STATE = {\n    CONNECTING: \"connecting\",\n    OPEN: \"open\",\n    CLOSING: \"closing\",\n    CLOSED: \"closed\",\n    ERROR: \"error\",\n    CREATE_ERROR: \"createError\",\n    BUFFERED_AMOUNT_LOW: \"bufferedAmountLow\",\n    SEND_MESSAGE_ERROR: \"sendMessageError\"\n  }, Skylink.prototype.DATA_CHANNEL_TYPE = {\n    MESSAGING: \"messaging\",\n    DATA: \"data\"\n  }, Skylink.prototype.DATA_CHANNEL_MESSAGE_ERROR = {\n    MESSAGE: \"message\",\n    TRANSFER: \"transfer\"\n  }, Skylink.prototype.DATA_TRANSFER_DATA_TYPE = {\n    BINARY_STRING: \"binaryString\",\n    ARRAY_BUFFER: \"arrayBuffer\",\n    BLOB: \"blob\",\n    STRING: \"string\"\n  }, Skylink.prototype.DT_PROTOCOL_VERSION = \"0.1.3\", Skylink.prototype.DATA_TRANSFER_TYPE = {\n    UPLOAD: \"upload\",\n    DOWNLOAD: \"download\"\n  }, Skylink.prototype.DATA_TRANSFER_SESSION_TYPE = {\n    BLOB: \"blob\",\n    DATA_URL: \"dataURL\"\n  }, Skylink.prototype.DATA_TRANSFER_STATE = {\n    UPLOAD_REQUEST: \"request\",\n    UPLOAD_STARTED: \"uploadStarted\",\n    DOWNLOAD_STARTED: \"downloadStarted\",\n    REJECTED: \"rejected\",\n    CANCEL: \"cancel\",\n    ERROR: \"error\",\n    UPLOADING: \"uploading\",\n    DOWNLOADING: \"downloading\",\n    UPLOAD_COMPLETED: \"uploadCompleted\",\n    DOWNLOAD_COMPLETED: \"downloadCompleted\",\n    USER_REJECTED: \"userRejected\",\n    USER_UPLOAD_REQUEST: \"userRequest\",\n    START_ERROR: \"startError\"\n  }, Skylink.prototype.DATA_STREAM_STATE = {\n    SENDING_STARTED: \"sendStart\",\n    SENDING_STOPPED: \"sendStop\",\n    RECEIVING_STARTED: \"receiveStart\",\n    RECEIVING_STOPPED: \"receiveStop\",\n    RECEIVED: \"received\",\n    SENT: \"sent\",\n    ERROR: \"error\",\n    START_ERROR: \"startError\"\n  }, Skylink.prototype.CANDIDATE_GENERATION_STATE = {\n    NEW: \"new\",\n    GATHERING: \"gathering\",\n    COMPLETED: \"completed\"\n  }, Skylink.prototype.CANDIDATE_PROCESSING_STATE = {\n    RECEIVED: \"received\",\n    DROPPED: \"dropped\",\n    BUFFERED: \"buffered\",\n    PROCESSING: \"processing\",\n    PROCESS_SUCCESS: \"processSuccess\",\n    PROCESS_ERROR: \"processError\"\n  }, Skylink.prototype.ICE_CONNECTION_STATE = {\n    STARTING: \"starting\",\n    CHECKING: \"checking\",\n    CONNECTED: \"connected\",\n    COMPLETED: \"completed\",\n    CLOSED: \"closed\",\n    FAILED: \"failed\",\n    TRICKLE_FAILED: \"trickleFailed\",\n    DISCONNECTED: \"disconnected\"\n  }, Skylink.prototype.TURN_TRANSPORT = {\n    UDP: \"udp\",\n    TCP: \"tcp\",\n    ANY: \"any\",\n    NONE: \"none\",\n    ALL: \"all\"\n  }, Skylink.prototype.PEER_CONNECTION_STATE = {\n    STABLE: \"stable\",\n    HAVE_LOCAL_OFFER: \"have-local-offer\",\n    HAVE_REMOTE_OFFER: \"have-remote-offer\",\n    CLOSED: \"closed\"\n  }, Skylink.prototype.GET_CONNECTION_STATUS_STATE = {\n    RETRIEVING: 0,\n    RETRIEVE_SUCCESS: 1,\n    RETRIEVE_ERROR: -1\n  }, Skylink.prototype.SERVER_PEER_TYPE = {\n    MCU: \"mcu\"\n  }, Skylink.prototype.BUNDLE_POLICY = {\n    MAX_COMPAT: \"max-compat\",\n    BALANCED: \"balanced\",\n    MAX_BUNDLE: \"max-bundle\",\n    NONE: \"none\"\n  }, Skylink.prototype.RTCP_MUX_POLICY = {\n    REQUIRE: \"require\",\n    NEGOTIATE: \"negotiate\"\n  }, Skylink.prototype.PEER_CERTIFICATE = {\n    RSA: \"RSA\",\n    ECDSA: \"ECDSA\",\n    AUTO: \"AUTO\"\n  }, Skylink.prototype.HANDSHAKE_PROGRESS = {\n    ENTER: \"enter\",\n    WELCOME: \"welcome\",\n    OFFER: \"offer\",\n    ANSWER: \"answer\",\n    ERROR: \"error\"\n  }, Skylink.prototype.GET_PEERS_STATE = {\n    ENQUIRED: \"enquired\",\n    RECEIVED: \"received\"\n  }, Skylink.prototype.INTRODUCE_STATE = {\n    INTRODUCING: \"introducing\",\n    ERROR: \"error\"\n  }, Skylink.prototype.SYSTEM_ACTION = {\n    WARNING: \"warning\",\n    REJECT: \"reject\"\n  }, Skylink.prototype.SYSTEM_ACTION_REASON = {\n    CREDENTIALS_EXPIRED: \"oldTimeStamp\",\n    CREDENTIALS_ERROR: \"credentialError\",\n    DUPLICATED_LOGIN: \"duplicatedLogin\",\n    ROOM_NOT_STARTED: \"notStart\",\n    EXPIRED: \"expired\",\n    ROOM_LOCKED: \"locked\",\n    FAST_MESSAGE: \"fastmsg\",\n    ROOM_CLOSING: \"toclose\",\n    ROOM_CLOSED: \"roomclose\",\n    SERVER_ERROR: \"serverError\",\n    KEY_ERROR: \"keyFailed\"\n  }, Skylink.prototype.VERSION = \"0.6.37\", Skylink.prototype.READY_STATE_CHANGE = {\n    INIT: 0,\n    LOADING: 1,\n    COMPLETED: 2,\n    ERROR: -1\n  }, Skylink.prototype.READY_STATE_CHANGE_ERROR = {\n    API_INVALID: 4001,\n    API_DOMAIN_NOT_MATCH: 4002,\n    API_CORS_DOMAIN_NOT_MATCH: 4003,\n    API_CREDENTIALS_INVALID: 4004,\n    API_CREDENTIALS_NOT_MATCH: 4005,\n    API_INVALID_PARENT_KEY: 4006,\n    API_NO_MEETING_RECORD_FOUND: 4010,\n    API_OVER_SEAT_LIMIT: 4020,\n    API_RETRIEVAL_FAILED: 4021,\n    API_WRONG_ACCESS_DOMAIN: 5005,\n    XML_HTTP_REQUEST_ERROR: -1,\n    XML_HTTP_NO_REPONSE_ERROR: -2,\n    NO_SOCKET_IO: 1,\n    NO_XMLHTTPREQUEST_SUPPORT: 2,\n    NO_WEBRTC_SUPPORT: 3,\n    NO_PATH: 4,\n    ADAPTER_NO_LOADED: 7,\n    PARSE_CODECS: 8\n  }, Skylink.prototype.REGIONAL_SERVER = {\n    APAC1: \"\",\n    US1: \"\"\n  }, Skylink.prototype.PRIORITY_WEIGHT_SCHEME = {\n    ENFORCE_OFFERER: \"enforceOfferer\",\n    ENFORCE_ANSWERER: \"enforceAnswerer\",\n    AUTO: \"auto\"\n  }, Skylink.prototype.LOG_LEVEL = {\n    DEBUG: 4,\n    LOG: 3,\n    INFO: 2,\n    WARN: 1,\n    ERROR: 0,\n    NONE: -1\n  }, Skylink.prototype.SOCKET_ERROR = {\n    CONNECTION_FAILED: 0,\n    RECONNECTION_FAILED: -1,\n    CONNECTION_ABORTED: -2,\n    RECONNECTION_ABORTED: -3,\n    RECONNECTION_ATTEMPT: -4\n  }, Skylink.prototype.SOCKET_FALLBACK = {\n    NON_FALLBACK: \"nonfallback\",\n    FALLBACK_PORT: \"fallbackPortNonSSL\",\n    FALLBACK_SSL_PORT: \"fallbackPortSSL\",\n    LONG_POLLING: \"fallbackLongPollingNonSSL\",\n    LONG_POLLING_SSL: \"fallbackLongPollingSSL\"\n  }, Skylink.prototype.SM_PROTOCOL_VERSION = \"0.1.2.4\", Skylink.prototype.VIDEO_CODEC = {\n    AUTO: \"auto\",\n    VP8: \"VP8\",\n    H264: \"H264\",\n    VP9: \"VP9\"\n  }, Skylink.prototype.AUDIO_CODEC = {\n    AUTO: \"auto\",\n    ISAC: \"ISAC\",\n    OPUS: \"opus\",\n    ILBC: \"ILBC\",\n    G722: \"G722\",\n    PCMU: \"PCMU\",\n    PCMA: \"PCMA\"\n  }, Skylink.prototype.MEDIA_SOURCE = {\n    SCREEN: \"screen\",\n    WINDOW: \"window\",\n    TAB: \"tab\",\n    TAB_AUDIO: \"audio\",\n    APPLICATION: \"application\",\n    BROWSER: \"browser\",\n    CAMERA: \"camera\"\n  }, Skylink.prototype.VIDEO_RESOLUTION = {\n    QQVGA: {\n      width: 160,\n      height: 120\n    },\n    HQVGA: {\n      width: 240,\n      height: 160\n    },\n    QVGA: {\n      width: 320,\n      height: 240\n    },\n    WQVGA: {\n      width: 384,\n      height: 240\n    },\n    HVGA: {\n      width: 480,\n      height: 320\n    },\n    VGA: {\n      width: 640,\n      height: 480\n    },\n    WVGA: {\n      width: 768,\n      height: 480\n    },\n    FWVGA: {\n      width: 854,\n      height: 480\n    },\n    SVGA: {\n      width: 800,\n      height: 600\n    },\n    DVGA: {\n      width: 960,\n      height: 640\n    },\n    WSVGA: {\n      width: 1024,\n      height: 576\n    },\n    HD: {\n      width: 1280,\n      height: 720\n    },\n    HDPLUS: {\n      width: 1600,\n      height: 900\n    },\n    FHD: {\n      width: 1920,\n      height: 1080\n    },\n    QHD: {\n      width: 2560,\n      height: 1440\n    },\n    WQXGAPLUS: {\n      width: 3200,\n      height: 1800\n    },\n    UHD: {\n      width: 3840,\n      height: 2160\n    },\n    UHDPLUS: {\n      width: 5120,\n      height: 2880\n    },\n    FUHD: {\n      width: 7680,\n      height: 4320\n    },\n    QUHD: {\n      width: 15360,\n      height: 8640\n    }\n  }, Skylink.prototype.MEDIA_ACCESS_FALLBACK_STATE = {\n    FALLBACKING: 0,\n    FALLBACKED: 1,\n    ERROR: -1\n  }, Skylink.prototype.RECORDING_STATE = {\n    START: 0,\n    STOP: 1,\n    LINK: 2,\n    ERROR: -1\n  }, Skylink.prototype._CHUNK_FILE_SIZE = 49152, Skylink.prototype._MOZ_CHUNK_FILE_SIZE = 12288, Skylink.prototype._BINARY_FILE_SIZE = 65456, Skylink.prototype._MOZ_BINARY_FILE_SIZE = 16384, Skylink.prototype._CHUNK_DATAURL_SIZE = 1212, Skylink.prototype._DC_PROTOCOL_TYPE = {\n    WRQ: \"WRQ\",\n    ACK: \"ACK\",\n    ERROR: \"ERROR\",\n    CANCEL: \"CANCEL\",\n    MESSAGE: \"MESSAGE\"\n  }, Skylink.prototype._SIG_MESSAGE_TYPE = {\n    JOIN_ROOM: \"joinRoom\",\n    IN_ROOM: \"inRoom\",\n    ENTER: \"enter\",\n    WELCOME: \"welcome\",\n    RESTART: \"restart\",\n    OFFER: \"offer\",\n    ANSWER: \"answer\",\n    CANDIDATE: \"candidate\",\n    BYE: \"bye\",\n    REDIRECT: \"redirect\",\n    UPDATE_USER: \"updateUserEvent\",\n    ROOM_LOCK: \"roomLockEvent\",\n    MUTE_VIDEO: \"muteVideoEvent\",\n    MUTE_AUDIO: \"muteAudioEvent\",\n    PUBLIC_MESSAGE: \"public\",\n    PRIVATE_MESSAGE: \"private\",\n    STREAM: \"stream\",\n    GROUP: \"group\",\n    GET_PEERS: \"getPeers\",\n    PEER_LIST: \"peerList\",\n    INTRODUCE: \"introduce\",\n    INTRODUCE_ERROR: \"introduceError\",\n    APPROACH: \"approach\",\n    START_RECORDING: \"startRecordingRoom\",\n    STOP_RECORDING: \"stopRecordingRoom\",\n    RECORDING: \"recordingEvent\",\n    END_OF_CANDIDATES: \"endOfCandidates\"\n  }, Skylink.prototype._GROUP_MESSAGE_LIST = [Skylink.prototype._SIG_MESSAGE_TYPE.STREAM, Skylink.prototype._SIG_MESSAGE_TYPE.UPDATE_USER, Skylink.prototype._SIG_MESSAGE_TYPE.MUTE_AUDIO, Skylink.prototype._SIG_MESSAGE_TYPE.MUTE_VIDEO, Skylink.prototype._SIG_MESSAGE_TYPE.PUBLIC_MESSAGE], Skylink.prototype.STATS_API_VERSION = \"1.1\", Skylink.prototype.VIDEO_QUALITY = {\n    HD: {\n      video: 3200,\n      audio: 150\n    },\n    HQ: {\n      video: 1200,\n      audio: 80\n    },\n    SQ: {\n      video: 800,\n      audio: 30\n    },\n    LQ: {\n      video: 400,\n      audio: 20\n    }\n  }, Skylink.prototype._createDataChannel = function (peerId, dataChannel, bufferThreshold, createAsMessagingChannel) {\n    var self = this,\n        channelName = (self._user && self._user.sid ? self._user.sid : \"-\") + \"_\" + peerId,\n        channelType = createAsMessagingChannel ? self.DATA_CHANNEL_TYPE.MESSAGING : self.DATA_CHANNEL_TYPE.DATA,\n        channelProp = channelType === self.DATA_CHANNEL_TYPE.MESSAGING ? \"main\" : channelName;\n    if (!self._user) return void log.error([peerId, \"RTCDataChannel\", channelProp, \"Aborting of creating or initializing Datachannel as User does not have Room session\"]);\n    if (!self._peerConnections[peerId] || self._peerConnections[peerId].signalingState === self.PEER_CONNECTION_STATE.CLOSED) return void log.error([peerId, \"RTCDataChannel\", channelProp, \"Aborting of creating or initializing Datachannel as Peer connection does not exists\"]);\n    if (dataChannel && \"object\" == typeof dataChannel ? channelName = dataChannel.label : \"string\" == typeof dataChannel && (channelName = dataChannel, dataChannel = null), self._dataChannels[peerId] ? self._dataChannels[peerId].main && self._dataChannels[peerId].main.channel.label === channelName && (channelProp = \"main\", channelType = self.DATA_CHANNEL_TYPE.MESSAGING) : (channelProp = \"main\", channelType = self.DATA_CHANNEL_TYPE.MESSAGING, self._dataChannels[peerId] = {}, log.debug([peerId, \"RTCDataChannel\", channelProp, \"initializing main DataChannel\"])), !dataChannel) try {\n      dataChannel = self._peerConnections[peerId].createDataChannel(channelName, {\n        reliable: !0,\n        ordered: !0\n      });\n    } catch (error) {\n      return log.error([peerId, \"RTCDataChannel\", channelProp, \"Failed creating Datachannel ->\"], error), self._handleDatachannelStats(\"error\", peerId, {\n        label: channelName\n      }, channelProp, error), void self._trigger(\"dataChannelState\", self.DATA_CHANNEL_STATE.CREATE_ERROR, peerId, error, channelName, channelType, null, self._getDataChannelBuffer(dataChannel));\n    }\n    dataChannel.onerror = function (evt) {\n      var channelError = evt.error || evt;\n      log.error([peerId, \"RTCDataChannel\", channelProp, \"Datachannel has an exception ->\"], channelError), self._handleDatachannelStats(\"error\", peerId, dataChannel, channelProp, channelError), self._trigger(\"dataChannelState\", self.DATA_CHANNEL_STATE.ERROR, peerId, channelError, channelName, channelType, null, self._getDataChannelBuffer(dataChannel));\n    }, dataChannel.onbufferedamountlow = function () {\n      log.debug([peerId, \"RTCDataChannel\", channelProp, \"Datachannel buffering data transfer low\"]), self._trigger(\"dataChannelState\", self.DATA_CHANNEL_STATE.BUFFERED_AMOUNT_LOW, peerId, null, channelName, channelType, null, self._getDataChannelBuffer(dataChannel));\n    }, dataChannel.onmessage = function (event) {\n      self._processDataChannelData(event.data, peerId, channelName, channelType);\n    };\n\n    var onOpenHandlerFn = function onOpenHandlerFn() {\n      log.debug([peerId, \"RTCDataChannel\", channelProp, \"Datachannel has opened\"]), dataChannel.bufferedAmountLowThreshold = bufferThreshold || 0, self._handleDatachannelStats(\"open\", peerId, dataChannel, channelProp), self._trigger(\"dataChannelState\", self.DATA_CHANNEL_STATE.OPEN, peerId, null, channelName, channelType, null, self._getDataChannelBuffer(dataChannel));\n    };\n\n    dataChannel.readyState === self.DATA_CHANNEL_STATE.OPEN ? setTimeout(onOpenHandlerFn, 1) : (self._handleDatachannelStats(\"connecting\", peerId, dataChannel, channelProp), self._trigger(\"dataChannelState\", dataChannel.readyState, peerId, null, channelName, channelType, null, self._getDataChannelBuffer(dataChannel)), dataChannel.onopen = onOpenHandlerFn);\n\n    var getTransferIDByPeerId = function getTransferIDByPeerId(pid) {\n      for (var transferId in self._dataTransfers) {\n        if (-1 !== transferId.indexOf(pid)) return transferId;\n      }\n\n      return null;\n    },\n        onCloseHandlerFn = function onCloseHandlerFn() {\n      var dcMessageStr = \"Datachannel has closed\",\n          transferId = getTransferIDByPeerId(peerId);\n      log.debug([peerId, \"RTCDataChannel\", channelProp, dcMessageStr]), self._handleDatachannelStats(\"closed\", peerId, dataChannel, channelProp), self._trigger(\"dataChannelState\", self.DATA_CHANNEL_STATE.CLOSED, peerId, null, channelName, channelType, null, self._getDataChannelBuffer(dataChannel)), transferId && self._trigger(\"dataTransferState\", self.DATA_TRANSFER_STATE.ERROR, transferId, peerId, self._getTransferInfo(transferId, peerId, !0, !1, !1), new Error(dcMessageStr)), self._peerConnections[peerId] && self._peerConnections[peerId].remoteDescription && self._peerConnections[peerId].remoteDescription.sdp && (-1 === self._peerConnections[peerId].remoteDescription.sdp.indexOf(\"m=application\") || self._peerConnections[peerId].remoteDescription.sdp.indexOf(\"m=application 0\") > 0) || channelType === self.DATA_CHANNEL_TYPE.MESSAGING && setTimeout(function () {\n        self._peerConnections[peerId] && self._peerConnections[peerId].signalingState !== self.PEER_CONNECTION_STATE.CLOSED && self._peerConnections[peerId].localDescription && self._peerConnections[peerId].localDescription.type === self.HANDSHAKE_PROGRESS.OFFER && (log.debug([peerId, \"RTCDataChannel\", channelProp, \"Reviving Datachannel connection\"]), self._handleDatachannelStats(\"reconnecting\", peerId, {\n          label: channelName\n        }, \"main\"), self._createDataChannel(peerId, channelName, bufferThreshold, !0));\n      }, 100);\n    };\n\n    if (\"firefox\" === AdapterJS.webrtcDetectedBrowser) {\n      var hasTriggeredClose = !1,\n          timeBlockAfterClosing = 0;\n\n      dataChannel.onclose = function () {\n        hasTriggeredClose || (hasTriggeredClose = !0, onCloseHandlerFn());\n      };\n\n      var onFFClosed = setInterval(function () {\n        dataChannel.readyState === self.DATA_CHANNEL_STATE.CLOSED || hasTriggeredClose || 5 === timeBlockAfterClosing ? (clearInterval(onFFClosed), hasTriggeredClose || (hasTriggeredClose = !0, onCloseHandlerFn())) : dataChannel.readyState === self.DATA_CHANNEL_STATE.CLOSING && timeBlockAfterClosing++;\n      }, 1e3);\n    } else dataChannel.onclose = onCloseHandlerFn;\n\n    channelType === self.DATA_CHANNEL_TYPE.MESSAGING ? self._dataChannels[peerId].main = {\n      channelName: channelName,\n      channelType: channelType,\n      transferId: null,\n      streamId: null,\n      channel: dataChannel\n    } : self._dataChannels[peerId][channelName] = {\n      channelName: channelName,\n      channelType: channelType,\n      transferId: null,\n      streamId: null,\n      channel: dataChannel\n    };\n  }, Skylink.prototype.refreshDatachannel = function (peerId) {\n    var self = this;\n\n    if (self._dataChannels[peerId] && self._dataChannels[peerId].main && self._dataChannels[peerId].main.channel) {\n      var channelName = self._dataChannels[peerId].main.channelName,\n          channelType = self._dataChannels[peerId].main.channelType,\n          bufferThreshold = self._dataChannels[peerId].main.channel.bufferedAmountLowThreshold || 0;\n      channelType === self.DATA_CHANNEL_TYPE.MESSAGING && setTimeout(function () {\n        self._peerConnections[peerId] && self._peerConnections[peerId].signalingState !== self.PEER_CONNECTION_STATE.CLOSED && self._peerConnections[peerId].localDescription && self._peerConnections[peerId].localDescription.type === self.HANDSHAKE_PROGRESS.OFFER && (self._closeDataChannel(peerId, \"main\", !0), log.debug([peerId, \"RTCDataChannel\", \"main\", \"Reviving Datachannel connection\"]), self._createDataChannel(peerId, channelName, bufferThreshold, !0));\n      }, 100);\n    } else log.debug([peerId, \"RTCDataChannel\", \"Not a valid Datachannel connection\"]);\n  }, Skylink.prototype._getDataChannelBuffer = function (peerId, channelProp) {\n    if (\"object\" == typeof peerId) return {\n      bufferedAmountLow: \"number\" == typeof peerId.bufferedAmountLow ? peerId.bufferedAmountLow : parseInt(peerId.bufferedAmountLow, 10) || 0,\n      bufferedAmountLowThreshold: \"number\" == typeof peerId.bufferedAmountLowThreshold ? peerId.bufferedAmountLowThreshold : parseInt(peerId.bufferedAmountLowThreshold, 10) || 0\n    };\n    if (!(this._dataChannels[peerId] && this._dataChannels[peerId][channelProp] && this._dataChannels[peerId][channelProp].channel)) return {\n      bufferedAmountLow: 0,\n      bufferedAmountLowThreshold: 0\n    };\n    var channel = this._dataChannels[peerId][channelProp].channel;\n    return {\n      bufferedAmountLow: \"number\" == typeof channel.bufferedAmountLow ? channel.bufferedAmountLow : parseInt(channel.bufferedAmountLow, 10) || 0,\n      bufferedAmountLowThreshold: \"number\" == typeof channel.bufferedAmountLowThreshold ? channel.bufferedAmountLowThreshold : parseInt(channel.bufferedAmountLowThreshold, 10) || 0\n    };\n  }, Skylink.prototype._sendMessageToDataChannel = function (peerId, data, channelProp, doNotConvert) {\n    var self = this;\n    if (channelProp && channelProp !== peerId || (channelProp = \"main\"), !(\"object\" == typeof data && data || data && \"string\" == typeof data)) return void log.warn([peerId, \"RTCDataChannel\", channelProp, \"Dropping invalid data ->\"], data);\n    if (!self._peerConnections[peerId] || self._peerConnections[peerId].signalingState === self.PEER_CONNECTION_STATE.CLOSED) return void log.warn([peerId, \"RTCDataChannel\", channelProp, \"Dropping for sending message as Peer connection does not exists or is closed ->\"], data);\n    if (!self._dataChannels[peerId] || !self._dataChannels[peerId][channelProp]) return void log.warn([peerId, \"RTCDataChannel\", channelProp, \"Dropping for sending message as Datachannel connection does not exists ->\"], data);\n    var channelName = self._dataChannels[peerId][channelProp].channelName,\n        channelType = self._dataChannels[peerId][channelProp].channelType,\n        readyState = self._dataChannels[peerId][channelProp].channel.readyState,\n        messageType = \"object\" == typeof data && data.type === self._DC_PROTOCOL_TYPE.MESSAGE ? self.DATA_CHANNEL_MESSAGE_ERROR.MESSAGE : self.DATA_CHANNEL_MESSAGE_ERROR.TRANSFER;\n\n    if (readyState !== self.DATA_CHANNEL_STATE.OPEN) {\n      var notOpenError = 'Failed sending message as Datachannel connection state is not opened. Current readyState is \"' + readyState + '\"';\n      throw log.error([peerId, \"RTCDataChannel\", channelProp, notOpenError + \" ->\"], data), self._trigger(\"dataChannelState\", self.DATA_CHANNEL_STATE.SEND_MESSAGE_ERROR, peerId, new Error(notOpenError), channelName, channelType, messageType, self._getDataChannelBuffer(peerId, channelProp)), new Error(notOpenError);\n    }\n\n    try {\n      doNotConvert || \"object\" != typeof data ? (log.debug([peerId, \"RTCDataChannel\", channelProp, \"Sending data with size ->\"], data.size || data.length || data.byteLength), self._dataChannels[peerId][channelProp].channel.send(data)) : (log.debug([peerId, \"RTCDataChannel\", channelProp, 'Sending \"' + data.type + '\" protocol message ->'], data), self._dataChannels[peerId][channelProp].channel.send(JSON.stringify(data)));\n    } catch (error) {\n      throw log.error([peerId, \"RTCDataChannel\", channelProp, \"Failed sending \" + (doNotConvert || \"object\" != typeof data ? \"data\" : '\"' + data.type + '\" protocol message') + \" ->\"], error), self._trigger(\"dataChannelState\", self.DATA_CHANNEL_STATE.SEND_MESSAGE_ERROR, peerId, error, channelName, channelType, messageType, self._getDataChannelBuffer(peerId, channelProp)), error;\n    }\n  }, Skylink.prototype._closeDataChannel = function (peerId, channelProp, isCloseMainChannel) {\n    var self = this;\n    if (!self._dataChannels[peerId]) return void log.warn([peerId, \"RTCDataChannel\", channelProp || null, \"Aborting closing Datachannels as Peer connection does not have Datachannel sessions\"]);\n\n    var closeFn = function closeFn(rChannelProp) {\n      var channelName = self._dataChannels[peerId][rChannelProp].channelName,\n          channelType = self._dataChannels[peerId][rChannelProp].channelType;\n      self._dataChannels[peerId][rChannelProp].readyState !== self.DATA_CHANNEL_STATE.CLOSED && (log.debug([peerId, \"RTCDataChannel\", channelProp, \"Closing Datachannel\"]), self._handleDatachannelStats(\"closing\", peerId, self._dataChannels[peerId][rChannelProp].channel, rChannelProp), self._trigger(\"dataChannelState\", self.DATA_CHANNEL_STATE.CLOSING, peerId, null, channelName, channelType, null, self._getDataChannelBuffer(peerId, rChannelProp)), self._dataChannels[peerId][rChannelProp].channel.close(), delete self._dataChannels[peerId][rChannelProp]);\n    };\n\n    if (isCloseMainChannel) closeFn(channelProp);else if (channelProp && \"main\" !== channelProp) {\n      if (!self._dataChannels[peerId][channelProp]) return void log.warn([peerId, \"RTCDataChannel\", channelProp, \"Aborting closing Datachannel as it does not exists\"]);\n      closeFn(channelProp);\n    } else {\n      for (var channelNameProp in self._dataChannels[peerId]) {\n        self._dataChannels[peerId].hasOwnProperty(channelNameProp) && self._dataChannels[peerId][channelNameProp] && closeFn(channelNameProp);\n      }\n\n      delete self._dataChannels[peerId];\n    }\n  }, Skylink.prototype._base64ToBlob = function (dataURL) {\n    for (var byteString = atob(dataURL), ab = new ArrayBuffer(byteString.length), ia = new Uint8Array(ab), j = 0; j < byteString.length; j++) {\n      ia[j] = byteString.charCodeAt(j);\n    }\n\n    return new Blob([ab]);\n  }, Skylink.prototype._blobToBase64 = function (data, callback) {\n    var fileReader = new FileReader();\n    fileReader.onload = function () {\n      var base64BinaryString = fileReader.result.split(\",\")[1];\n      callback(base64BinaryString);\n    }, fileReader.readAsDataURL(data);\n  }, Skylink.prototype._blobToArrayBuffer = function (data, callback) {\n    var fileReader = new FileReader();\n    fileReader.onload = function () {\n      callback(\"plugin\" === AdapterJS.webrtcDetectedType ? new Int8Array(fileReader.result) : fileReader.result);\n    }, fileReader.readAsArrayBuffer(data);\n  }, Skylink.prototype._chunkBlobData = function (blob, chunkSize) {\n    var chunksArray = [],\n        startCount = 0,\n        endCount = 0,\n        blobByteSize = blob.size;\n\n    if (blobByteSize > chunkSize) {\n      for (; blobByteSize - 1 > endCount;) {\n        endCount = startCount + chunkSize, chunksArray.push(blob.slice(startCount, endCount)), startCount += chunkSize;\n      }\n\n      blobByteSize - (startCount + 1) > 0 && chunksArray.push(blob.slice(startCount, blobByteSize - 1));\n    } else chunksArray.push(blob);\n\n    return chunksArray;\n  }, Skylink.prototype._chunkDataURL = function (dataURL, chunkSize) {\n    var outputStr = dataURL,\n        dataURLArray = [],\n        startCount = 0,\n        endCount = 0,\n        dataByteSize = dataURL.size || dataURL.length;\n\n    if (dataByteSize > chunkSize) {\n      for (; dataByteSize - 1 > endCount;) {\n        endCount = startCount + chunkSize, dataURLArray.push(outputStr.slice(startCount, endCount)), startCount += chunkSize;\n      }\n\n      dataByteSize - (startCount + 1) > 0 && chunksArray.push(outputStr.slice(startCount, dataByteSize - 1));\n    } else dataURLArray.push(outputStr);\n\n    return dataURLArray;\n  }, Skylink.prototype.sendBlobData = function (data, timeout, targetPeerId, sendChunksAsBinary, callback) {\n    this._startDataTransfer(data, timeout, targetPeerId, sendChunksAsBinary, callback, \"blob\");\n  }, Skylink.prototype.sendURLData = function (data, timeout, targetPeerId, callback) {\n    this._startDataTransfer(data, timeout, targetPeerId, callback, null, \"data\");\n  }, Skylink.prototype.respondBlobRequest = Skylink.prototype.acceptDataTransfer = function (peerId, transferId, accept) {\n    var self = this;\n    if (\"string\" != typeof transferId && \"string\" != typeof peerId) return void log.error([peerId, \"RTCDataChannel\", transferId, \"Aborting accept data transfer as data transfer ID or peer ID is not provided\"]);\n    if (!self._dataChannels[peerId]) return void log.error([peerId, \"RTCDataChannel\", transferId, \"Aborting accept data transfer as Peer does not have any Datachannel connections\"]);\n    if (!self._dataTransfers[transferId]) return void log.error([peerId, \"RTCDataChannel\", transferId, \"Aborting accept data transfer as invalid transfer ID is provided\"]);\n    var channelProp = \"main\",\n        dataChannelStateCbFn = null;\n    self._dataChannels[peerId][transferId] && (channelProp = transferId), self.once(\"dataTransferState\", function () {\n      dataChannelStateCbFn && self.off(\"dataChannelState\", dataChannelStateCbFn), delete self._dataTransfers[transferId], self._dataChannels[peerId] && (\"main\" === channelProp && self._dataChannels[peerId].main && (self._dataChannels[peerId].main.transferId = null), channelProp === transferId && self._closeDataChannel(peerId, transferId));\n    }, function (state, evtTransferId, evtPeerId) {\n      return evtTransferId === transferId && evtPeerId === peerId && [self.DATA_TRANSFER_STATE.ERROR, self.DATA_TRANSFER_STATE.CANCEL, self.DATA_TRANSFER_STATE.DOWNLOAD_COMPLETED, self.DATA_TRANSFER_STATE.USER_REJECTED].indexOf(state) > -1;\n    }), accept ? (log.debug([peerId, \"RTCDataChannel\", transferId, \"Accepted data transfer and starting ...\"]), dataChannelStateCbFn = function dataChannelStateCbFn(state, evtPeerId, error, cN, cT) {\n      log.error([peerId, \"RTCDataChannel\", channelProp, 'Data transfer \"' + transferId + '\" has been terminated due to connection.']), self._trigger(\"dataTransferState\", self.DATA_TRANSFER_STATE.ERROR, transferId, peerId, self._getTransferInfo(transferId, peerId, !0, !1, !1), {\n        transferType: self.DATA_TRANSFER_TYPE.DOWNLOAD,\n        message: new Error(\"Data transfer terminated as Peer Datachannel connection closed abruptly.\")\n      });\n    }, self.once(\"dataChannelState\", dataChannelStateCbFn, function (state, evtPeerId, error, channelName, channelType) {\n      return self._dataTransfers[transferId] && self._dataTransfers[transferId].sessions[peerId] ? evtPeerId === peerId && (\"main\" === channelProp ? channelType === self.DATA_CHANNEL_STATE.MESSAGING : channelName === transferId) && [self.DATA_CHANNEL_STATE.CLOSING, self.DATA_CHANNEL_STATE.CLOSED, self.DATA_CHANNEL_STATE.ERROR].indexOf(state) > -1 : void self.off(\"dataChannelState\", dataChannelStateCbFn);\n    }), self._sendMessageToDataChannel(peerId, {\n      type: self._DC_PROTOCOL_TYPE.ACK,\n      sender: self._user.sid,\n      ackN: 0\n    }, channelProp), self._trigger(\"dataTransferState\", self.DATA_TRANSFER_STATE.DOWNLOAD_STARTED, transferId, peerId, self._getTransferInfo(transferId, peerId, !0, !1, !1), null)) : (log.warn([peerId, \"RTCDataChannel\", transferId, \"Rejected data transfer and data transfer request has been aborted\"]), self._sendMessageToDataChannel(peerId, {\n      type: self._DC_PROTOCOL_TYPE.ACK,\n      sender: self._user.sid,\n      ackN: -1\n    }, channelProp), self._trigger(\"dataTransferState\", self.DATA_TRANSFER_STATE.USER_REJECTED, transferId, peerId, self._getTransferInfo(transferId, peerId, !0, !1, !1), {\n      message: new Error(\"Data transfer terminated as User has rejected data transfer request.\"),\n      transferType: self.DATA_TRANSFER_TYPE.DOWNLOAD\n    }));\n  }, Skylink.prototype.cancelBlobTransfer = Skylink.prototype.cancelDataTransfer = function (peerId, transferId) {\n    var self = this;\n    if (!transferId || \"string\" != typeof transferId) return void log.error([peerId, \"RTCDataChannel\", transferId, \"Aborting cancel data transfer as data transfer ID is not provided\"]);\n    if (!peerId || \"string\" != typeof peerId) return void log.error([peerId, \"RTCDataChannel\", transferId, \"Aborting cancel data transfer as peer ID is not provided\"]);\n    if (!self._dataTransfers[transferId]) return void log.error([peerId, \"RTCDataChannel\", transferId, \"Aborting cancel data transfer as data transfer session does not exists.\"]);\n    log.debug([peerId, \"RTCDataChannel\", transferId, \"Canceling data transfer ...\"]);\n\n    var emitEventFn = function emitEventFn(peers, transferInfoPeerId) {\n      for (var i = 0; i < peers.length; i++) {\n        self._trigger(\"dataTransferState\", self.DATA_TRANSFER_STATE.CANCEL, transferId, peers[i], self._getTransferInfo(transferId, transferInfoPeerId, !1, !1, !1), {\n          transferType: self._dataTransfers[transferId].direction,\n          message: new Error(\"User cancelled download transfer\")\n        });\n      }\n    };\n\n    if (self._hasMCU && self._dataTransfers[transferId].direction === self.DATA_TRANSFER_TYPE.UPLOAD) {\n      if (!self._dataChannels.MCU) return void log.error([peerId, \"RTCDataChannel\", transferId, \"Aborting cancel data transfer as Peer does not have any Datachannel connections\"]);\n      log.warn([peerId, \"RTCDataChannel\", transferId, \"Aborting all data transfers to Peers\"]), Object.keys(self._dataTransfers[transferId].peers.main).length > 0 && self._sendMessageToDataChannel(\"MCU\", {\n        type: self._DC_PROTOCOL_TYPE.CANCEL,\n        sender: self._user.sid,\n        content: \"Peer cancelled download transfer\",\n        name: self._dataTransfers[transferId].name,\n        ackN: 0\n      }, \"main\"), Object.keys(self._dataTransfers[transferId].peers[transferId]).length > 0 && self._sendMessageToDataChannel(\"MCU\", {\n        type: self._DC_PROTOCOL_TYPE.CANCEL,\n        sender: self._user.sid,\n        content: \"Peer cancelled download transfer\",\n        name: self._dataTransfers[transferId].name,\n        ackN: 0\n      }, transferId), emitEventFn(Object.keys(self._dataTransfers[transferId].peers.main).concat(Object.keys(self._dataTransfers[transferId].peers[transferId])));\n    } else {\n      var channelProp = \"main\";\n      if (!self._dataChannels[peerId]) return void log.error([peerId, \"RTCDataChannel\", transferId, \"Aborting cancel data transfer as Peer does not have any Datachannel connections\"]);\n      self._dataChannels[peerId][transferId] && (channelProp = transferId), self._sendMessageToDataChannel(peerId, {\n        type: self._DC_PROTOCOL_TYPE.CANCEL,\n        sender: self._user.sid,\n        content: \"Peer cancelled download transfer\",\n        name: self._dataTransfers[transferId].name,\n        ackN: 0\n      }, channelProp), emitEventFn([peerId], peerId);\n    }\n  }, Skylink.prototype.sendP2PMessage = function (message, targetPeerId) {\n    var listOfPeers = Object.keys(this._dataChannels),\n        isPrivate = !1;\n    if (Array.isArray(targetPeerId) ? (listOfPeers = targetPeerId, isPrivate = !0) : targetPeerId && \"string\" == typeof targetPeerId && (listOfPeers = [targetPeerId], isPrivate = !0), !this._inRoom || !this._user || !this._user.sid) return void log.error(\"Unable to send message as User is not in Room. ->\", message);\n    if (!this._initOptions.enableDataChannel) return void log.error(\"Unable to send message as User does not have Datachannel enabled. ->\", message);\n\n    for (var i = 0; i < listOfPeers.length; i++) {\n      var peerId = listOfPeers[i];\n      this._dataChannels[peerId] ? \"MCU\" === peerId ? (listOfPeers.splice(i, 1), i--) : this._hasMCU || (log.debug([peerId, \"RTCDataChannel\", null, \"Sending \" + (isPrivate ? \"private\" : \"\") + \" P2P message to Peer\"]), this._sendMessageToDataChannel(peerId, {\n        type: this._DC_PROTOCOL_TYPE.MESSAGE,\n        isPrivate: isPrivate,\n        sender: this._user.sid,\n        target: peerId,\n        data: message\n      }, \"main\")) : (log.error([peerId, \"RTCDataChannel\", null, \"Dropping of sending message to Peer as Datachannel connection does not exists\"]), listOfPeers.splice(i, 1), i--);\n    }\n\n    0 === listOfPeers.length && log.warn(\"Currently there are no Peers to send P2P message to (unless the message is queued and there are Peer connected by then).\"), this._hasMCU && (log.debug([\"MCU\", \"RTCDataChannel\", null, \"Broadcasting \" + (isPrivate ? \"private\" : \"\") + \" P2P message to Peers\"]), this._sendMessageToDataChannel(\"MCU\", {\n      type: this._DC_PROTOCOL_TYPE.MESSAGE,\n      isPrivate: isPrivate,\n      sender: this._user.sid,\n      target: listOfPeers,\n      data: message\n    }, \"main\")), this._trigger(\"incomingMessage\", {\n      content: message,\n      isPrivate: isPrivate,\n      targetPeerId: targetPeerId || null,\n      listOfPeers: listOfPeers,\n      isDataChannel: !0,\n      senderPeerId: this._user.sid\n    }, this._user.sid, this.getPeerInfo(), !0);\n  }, Skylink.prototype.startStreamingData = function (isStringStream, targetPeerId) {\n    var self = this,\n        listOfPeers = Object.keys(self._dataChannels),\n        isPrivate = !1,\n        sessionChunkType = \"binary\";\n    Array.isArray(targetPeerId) ? (listOfPeers = targetPeerId, isPrivate = !0) : targetPeerId && \"string\" == typeof targetPeerId && (listOfPeers = [targetPeerId], isPrivate = !0), Array.isArray(isStringStream) ? (listOfPeers = isStringStream, targetPeerId = isStringStream, isPrivate = !0) : isStringStream && \"string\" == typeof isStringStream ? (listOfPeers = [isStringStream], targetPeerId = isStringStream, isPrivate = !0) : isStringStream && \"boolean\" == typeof isStringStream && (sessionChunkType = \"string\");\n    var sessionInfo = {\n      chunk: null,\n      chunkSize: 0,\n      chunkType: \"string\" === sessionChunkType ? self.DATA_TRANSFER_DATA_TYPE.STRING : self._binaryChunkType,\n      isPrivate: isPrivate,\n      isStringStream: \"string\" === sessionChunkType,\n      senderPeerId: self._user && self._user.sid ? self._user.sid : null\n    };\n    listOfPeers.indexOf(\"MCU\") > -1 && listOfPeers.splice(listOfPeers.indexOf(\"MCU\"), 1);\n\n    var emitErrorBeforeStreamingFn = function emitErrorBeforeStreamingFn(error) {\n      log.error(error);\n    };\n\n    if (!this._inRoom || !this._user || !this._user.sid) return emitErrorBeforeStreamingFn(\"Unable to start data streaming as User is not in Room.\");\n    if (!this._initOptions.enableDataChannel) return emitErrorBeforeStreamingFn(\"Unable to start data streaming as User does not have Datachannel enabled.\");\n    if (0 === listOfPeers.length) return emitErrorBeforeStreamingFn(\"Unable to start data streaming as there are no Peers to start session with.\");\n    if (self._hasMCU) return emitErrorBeforeStreamingFn(\"Unable to start data streaming as this feature is current not supported by MCU yet.\");\n    if (!self._initOptions.enableSimultaneousTransfers) return emitErrorBeforeStreamingFn(\"Unable to start data streaming as this feature requires simultaneous data transfers to be enabled\");\n\n    for (var transferId = \"stream_\" + (self._user && self._user.sid ? self._user.sid : \"-\") + \"_\" + new Date().getTime(), peersInterop = [], peersNonInterop = [], sessions = {}, listenToPeerFn = function listenToPeerFn(peerId, channelProp) {\n      var hasStarted = !1;\n      sessions[peerId] = channelProp, self.once(\"dataStreamState\", function () {}, function (state, evtTransferId, evtPeerId, evtSessionInfo) {\n        if (evtTransferId === transferId && evtPeerId === peerId) {\n          evtSessionInfo.chunk;\n          return delete clone(evtSessionInfo).chunk, state === self.DATA_STREAM_STATE.SENDING_STARTED ? void (hasStarted = !0) : hasStarted && [self.DATA_STREAM_STATE.ERROR, self.DATA_STREAM_STATE.SENDING_STOPPED].indexOf(state) > -1 ? (channelProp === transferId && self._closeDataChannel(peerId, transferId), self._dataStreams[transferId] && self._dataStreams[transferId].sessions[peerId] && (delete self._dataStreams[transferId].sessions[peerId], 0 === Object.keys(self._dataStreams[transferId].sessions).length && delete self._dataStreams[transferId]), !0) : void 0;\n        }\n      });\n    }, i = 0; i < listOfPeers.length; i++) {\n      var peerId = listOfPeers[i],\n          error = null,\n          dtProtocolVersion = ((self._peerInformations[peerId] || {}).agent || {}).DTProtocolVersion || \"\",\n          channelProp = self._isLowerThanVersion(dtProtocolVersion, \"0.1.2\") || !self._initOptions.enableSimultaneousTransfers ? \"main\" : transferId;\n      if (self._dataChannels[peerId] && self._dataChannels[peerId].main) {\n        if (!self._hasMCU || self._dataChannels.MCU && self._dataChannels.MCU.main) {\n          if (self._isLowerThanVersion(dtProtocolVersion, \"0.1.3\")) error = 'Peer DTProtocolVersion does not support data streaming. (received: \"' + dtProtocolVersion + '\", expected: \"0.1.3\")';else if (\"main\" === channelProp) {\n            var dataTransferId = self._hasMCU ? self._dataChannels.MCU.main.transferId : self._dataChannels[peerId].main.transferId;\n            self._dataChannels[peerId].main.streamId ? error = \"Peer Datachannel currently has an active data transfer session.\" : self._hasMCU && self._dataChannels.MCU.main.streamId ? error = \"MCU Peer Datachannel currently has an active data transfer session.\" : self._dataTransfers[dataTransferId] && self._dataTransfers[dataTransferId].sessionChunkType === sessionChunkType ? error = (self._hasMCU ? \"MCU \" : \"\") + \"Peer Datachannel currently has an active \" + sessionChunkType + \" data transfer.\" : peersInterop.push(peerId);\n          } else peersNonInterop.push(peerId);\n        } else error = \"MCU Datachannel connection does not exists\";\n      } else error = \"Datachannel connection does not exists\";\n      error ? (self._trigger(\"dataStreamState\", self.DATA_STREAM_STATE.START_ERROR, transferId, peerId, sessionInfo, new Error(error)), listOfPeers.splice(i, 1), i--) : listenToPeerFn(peerId, channelProp);\n    }\n\n    if (0 === listOfPeers.length) return void log.warn(\"There are no Peers to start data session with.\");\n    self._dataStreams[transferId] = {\n      sessions: sessions,\n      chunkType: \"string\" === sessionChunkType ? self.DATA_TRANSFER_DATA_TYPE.STRING : self._binaryChunkType,\n      sessionChunkType: sessionChunkType,\n      isPrivate: isPrivate,\n      isStringStream: \"string\" === sessionChunkType,\n      senderPeerId: self._user && self._user.sid ? self._user.sid : null,\n      isUpload: !0\n    };\n\n    var startDataSessionFn = function startDataSessionFn(peerId, channelProp, targetPeers) {\n      if (self.once(\"dataChannelState\", function () {}, function (state, evtPeerId, channelName, channelType, error) {\n        if (!self._dataStreams[transferId]) return !0;\n\n        if (evtPeerId === peerId && (\"main\" === channelProp ? channelType === self.DATA_CHANNEL_TYPE.MESSAGING : channelName === transferId && channelType === self.DATA_CHANNEL_TYPE.DATA) && [self.DATA_CHANNEL_STATE.ERROR, self.DATA_CHANNEL_STATE.CLOSED].indexOf(state) > -1) {\n          var updatedError = new Error(error && error.message ? error.message : 'Failed data transfer as datachannel state is \"' + state + '\".');\n          if (\"MCU\" === peerId) for (var mp = 0; mp < targetPeers.length; mp++) {\n            self._trigger(\"dataStreamState\", self.DATA_STREAM_STATE.ERROR, transferId, targetPeers[mp], sessionInfo, updatedError);\n          } else self._trigger(\"dataStreamState\", self.DATA_STREAM_STATE.ERROR, transferId, peerId, sessionInfo, updatedError);\n          return !0;\n        }\n      }), !self._dataChannels[peerId][channelProp] || self._dataChannels[peerId][channelProp].channel.readyState !== self.DATA_CHANNEL_STATE.OPEN) {\n        var notOpenError = new Error(\"Failed starting data streaming session as channel is not opened.\");\n        if (\"MCU\" === peerId) for (i = 0; i < targetPeers.length; i++) {\n          self._trigger(\"dataStreamState\", self.DATA_STREAM_STATE.START_ERROR, transferId, targetPeers[i], sessionInfo, notOpenError);\n        } else self._trigger(\"dataStreamState\", self.DATA_STREAM_STATE.START_ERROR, transferId, peerId, sessionInfo, notOpenError);\n      }\n\n      self._sendMessageToDataChannel(peerId, {\n        type: self._DC_PROTOCOL_TYPE.WRQ,\n        transferId: transferId,\n        name: transferId,\n        size: 0,\n        originalSize: 0,\n        dataType: \"fastBinaryStart\",\n        mimeType: null,\n        chunkType: sessionChunkType,\n        chunkSize: 0,\n        timeout: 0,\n        isPrivate: isPrivate,\n        sender: self._user.sid,\n        agent: AdapterJS.webrtcDetectedBrowser,\n        version: AdapterJS.webrtcDetectedVersion,\n        target: \"MCU\" === peerId ? targetPeers : peerId\n      }, channelProp), self._dataChannels[peerId][channelProp].streamId = transferId;\n      var updatedSessionInfo = clone(sessionInfo);\n      if (delete updatedSessionInfo.chunk, \"MCU\" === peerId) for (var tp = 0; tp < targetPeers.length; tp++) {\n        self._trigger(\"dataStreamState\", self.DATA_STREAM_STATE.SENDING_STARTED, transferId, targetPeers[tp], sessionInfo, null), self._trigger(\"incomingDataStreamStarted\", transferId, targetPeers[tp], updatedSessionInfo, !0);\n      } else self._trigger(\"dataStreamState\", self.DATA_STREAM_STATE.SENDING_STARTED, transferId, peerId, sessionInfo, null), self._trigger(\"incomingDataStreamStarted\", transferId, peerId, updatedSessionInfo, !0);\n    },\n        waitForChannelOpenFn = function waitForChannelOpenFn(peerId, targetPeers) {\n      self.once(\"dataChannelState\", function (state, evtPeerId, error) {\n        if (state !== self.DATA_CHANNEL_STATE.CREATE_ERROR) startDataSessionFn(peerId, transferId, targetPeers);else if (\"MCU\" === peerId) for (var mp = 0; mp < targetPeers.length; mp++) {\n          self._trigger(\"dataStreamState\", self.DATA_STREAM_STATE.START_ERROR, transferId, targetPeers[mp], sessionInfo, error);\n        } else self._trigger(\"dataStreamState\", self.DATA_STREAM_STATE.START_ERROR, transferId, peerId, sessionInfo, error);\n      }, function (state, evtPeerId, error, channelName, channelType) {\n        if (evtPeerId === peerId && channelName === transferId && channelType === self.DATA_CHANNEL_TYPE.DATA) return [self.DATA_CHANNEL_STATE.CREATE_ERROR, self.DATA_CHANNEL_STATE.OPEN].indexOf(state) > -1;\n      }), self._createDataChannel(peerId, transferId, \"string\" === sessionChunkType ? self._CHUNK_DATAURL_SIZE : \"firefox\" === AdapterJS.webrtcDetectedBrowser ? self._MOZ_BINARY_FILE_SIZE : self._BINARY_FILE_SIZE);\n    };\n\n    if (peersNonInterop.length > 0) if (self._hasMCU) waitForChannelOpenFn(\"MCU\", peersNonInterop);else for (var pni = 0; pni < peersNonInterop.length; pni++) {\n      waitForChannelOpenFn(peersNonInterop[pni], null);\n    }\n    if (peersInterop.length > 0) if (self._hasMCU) startDataSessionFn(\"MCU\", \"main\", peersInterop);else for (var pi = 0; pi < peersInterop.length; pi++) {\n      startDataSessionFn(peersInterop[pi], \"main\", null);\n    }\n  }, Skylink.prototype.streamData = function (transferId, dataChunk) {\n    var self = this;\n    if (!transferId || \"string\" != typeof transferId) return void log.error(\"Failed streaming data chunk as stream session ID is not provided.\");\n    if (!dataChunk || \"object\" != typeof dataChunk || !(dataChunk instanceof Blob || dataChunk instanceof ArrayBuffer)) return void log.error(\"Failed streaming data chunk as it is not provided.\");\n    if (!(self._inRoom && self._user && self._user.sid)) return void log.error(\"Failed streaming data chunk as User is not in the Room.\");\n    if (!self._dataStreams[transferId]) return void log.error(\"Failed streaming data chunk as session does not exists.\");\n    if (!self._dataStreams[transferId].isUpload) return void log.error(\"Failed streaming data chunk as session is not sending.\");\n    if (\"string\" === self._dataStreams[transferId].sessionChunkType ? \"string\" != typeof dataChunk : \"object\" != typeof dataChunk) return void log.error(\"Failed streaming data chunk as data chunk does not match expected data type.\");\n    if (self._hasMCU) return void log.error(\"Failed streaming data chunk as MCU does not support this feature yet.\");\n    var updatedDataChunk = dataChunk instanceof ArrayBuffer ? new Blob(dataChunk) : dataChunk;\n    if (\"string\" === self._dataStreams[transferId].sessionChunkType ? updatedDataChunk.length > self._CHUNK_DATAURL_SIZE : updatedDataChunk.length > self._BINARY_FILE_SIZE) return void log.error(\"Failed streaming data chunk as data chunk exceeds maximum chunk limit.\");\n\n    var sessionInfo = {\n      chunk: updatedDataChunk,\n      chunkSize: updatedDataChunk.size || updatedDataChunk.length || updatedDataChunk.byteLength,\n      chunkType: \"string\" === self._dataStreams[transferId].sessionChunkType ? self.DATA_TRANSFER_DATA_TYPE.STRING : self._binaryChunkType,\n      isPrivate: self._dataStreams[transferId].sessionChunkType.isPrivate,\n      isStringStream: \"string\" === self._dataStreams[transferId].sessionChunkType,\n      senderPeerId: self._user && self._user.sid ? self._user.sid : null\n    },\n        peersInterop = [],\n        peersNonInterop = [],\n        sendDataFn = function sendDataFn(peerId, channelProp, targetPeers) {\n      var onSendDataFn = function onSendDataFn(buffer) {\n        self._sendMessageToDataChannel(peerId, buffer, channelProp, !0);\n\n        var updatedSessionInfo = clone(sessionInfo);\n        if (delete updatedSessionInfo.chunk, targetPeers) for (var i = 0; i < targetPeers.length; i++) {\n          self._trigger(\"dataStreamState\", self.DATA_STREAM_STATE.SENT, transferId, targetPeers[i], sessionInfo, null), self._trigger(\"incomingDataStream\", dataChunk, transferId, targetPeers[i], updatedSessionInfo, !0);\n        } else self._trigger(\"dataStreamState\", self.DATA_STREAM_STATE.SENT, transferId, peerId, sessionInfo, null), self._trigger(\"incomingDataStream\", dataChunk, transferId, peerId, updatedSessionInfo, !0);\n      };\n\n      dataChunk instanceof Blob && sessionInfo.chunkType === self.DATA_TRANSFER_DATA_TYPE.ARRAY_BUFFER ? self._blobToArrayBuffer(dataChunk, onSendDataFn) : onSendDataFn(dataChunk instanceof Blob || sessionInfo.chunkType !== self.DATA_TRANSFER_DATA_TYPE.BLOB ? \"plugin\" === AdapterJS.webrtcDetectedType && \"string\" != typeof dataChunk ? new Int8Array(dataChunk) : dataChunk : new Blob([dataChunk]));\n    };\n\n    for (var peerId in self._dataStreams[transferId].sessions) {\n      if (self._dataStreams[transferId].sessions.hasOwnProperty(peerId) && self._dataStreams[transferId].sessions[peerId]) {\n        var channelProp = self._dataStreams[transferId].sessions[peerId];\n        if (!self._dataChannels[self._hasMCU ? \"MCU\" : peerId] || !self._dataChannels[self._hasMCU ? \"MCU\" : peerId][channelProp] || self._dataChannels[self._hasMCU ? \"MCU\" : peerId][channelProp].channel.readyState !== self.DATA_CHANNEL_STATE.OPEN || self._dataChannels[self._hasMCU ? \"MCU\" : peerId][channelProp].streamId !== transferId) return log.error([peerId, \"RTCDataChannel\", transferId, \"Failed streaming data as it has not started or is ready.\"]), void self._trigger(\"dataStreamState\", self.DATA_STREAM_STATE.ERROR, transferId, peerId, sessionInfo, new Error(\"Streaming as it has not started or Datachannel connection is not open.\"));\n        self._hasMCU ? \"main\" === channelProp ? peersInterop.push(peerId) : peersNonInterop.push(peerId) : sendDataFn(peerId, channelProp);\n      }\n    }\n\n    self._hasMCU && (peersInterop.length > 0 && sendDataFn(peerId, \"main\", peersInterop), peersNonInterop.length > 0 && sendDataFn(peerId, transferId, peersNonInterop));\n  }, Skylink.prototype.stopStreamingData = function (transferId) {\n    var self = this;\n    if (!transferId || \"string\" != typeof transferId) return void log.error(\"Failed streaming data chunk as stream session ID is not provided.\");\n    if (!(self._inRoom && self._user && self._user.sid)) return void log.error(\"Failed streaming data chunk as User is not in the Room.\");\n    if (!self._dataStreams[transferId]) return void log.error(\"Failed stopping data streaming session as it does not exists.\");\n    if (!self._dataStreams[transferId].isUpload) return void log.error(\"Failed stopping data streaming session as it is not sending.\");\n    if (self._hasMCU) return void log.error(\"Failed stopping data streaming session as MCU does not support this feature yet.\");\n\n    var sessionInfo = {\n      chunk: null,\n      chunkSize: 0,\n      chunkType: \"string\" === self._dataStreams[transferId].sessionChunkType ? self.DATA_TRANSFER_DATA_TYPE.STRING : self._binaryChunkType,\n      isPrivate: self._dataStreams[transferId].sessionChunkType.isPrivate,\n      isStringStream: \"string\" === self._dataStreams[transferId].sessionChunkType,\n      senderPeerId: self._user && self._user.sid ? self._user.sid : null\n    },\n        peersInterop = [],\n        peersNonInterop = [],\n        sendDataFn = function sendDataFn(peerId, channelProp, targetPeers) {\n      self._sendMessageToDataChannel(peerId, {\n        type: self._DC_PROTOCOL_TYPE.WRQ,\n        transferId: transferId,\n        name: transferId,\n        size: 0,\n        originalSize: 0,\n        dataType: \"fastBinaryStop\",\n        mimeType: null,\n        chunkType: self._dataStreams[transferId].sessionChunkType,\n        chunkSize: 0,\n        timeout: 0,\n        isPrivate: self._dataStreams[transferId].isPrivate,\n        sender: self._user.sid,\n        agent: AdapterJS.webrtcDetectedBrowser,\n        version: AdapterJS.webrtcDetectedVersion,\n        target: targetPeers || peerId\n      }, channelProp);\n\n      var updatedSessionInfo = clone(sessionInfo);\n      if (delete updatedSessionInfo.chunk, targetPeers) for (var i = 0; i < targetPeers.length; i++) {\n        self._trigger(\"dataStreamState\", self.DATA_STREAM_STATE.SENDING_STOPPED, transferId, targetPeers[i], sessionInfo, null), self._trigger(\"incomingDataStreamStopped\", transferId, targetPeers[i], updatedSessionInfo, !0);\n      } else self._trigger(\"dataStreamState\", self.DATA_STREAM_STATE.SENDING_STOPPED, transferId, peerId, sessionInfo, null), self._trigger(\"incomingDataStreamStopped\", transferId, peerId, updatedSessionInfo, !0);\n    };\n\n    for (var peerId in self._dataStreams[transferId].sessions) {\n      if (self._dataStreams[transferId].sessions.hasOwnProperty(peerId) && self._dataStreams[transferId].sessions[peerId]) {\n        var channelProp = self._dataStreams[transferId].sessions[peerId];\n        if (!self._dataChannels[self._hasMCU ? \"MCU\" : peerId] || !self._dataChannels[self._hasMCU ? \"MCU\" : peerId][channelProp] || self._dataChannels[self._hasMCU ? \"MCU\" : peerId][channelProp].channel.readyState !== self.DATA_CHANNEL_STATE.OPEN || self._dataChannels[self._hasMCU ? \"MCU\" : peerId][channelProp].streamId !== transferId) return log.error([peerId, \"RTCDataChannel\", transferId, \"Failed stopping data streaming session as channel is closed.\"]), void self._trigger(\"dataStreamState\", self.DATA_STREAM_STATE.ERROR, transferId, peerId, sessionInfo, new Error(\"Failed stopping data streaming session as Datachannel connection is not open or is active.\"));\n        self._hasMCU ? \"main\" === self._dataStreams[transferId].sessions[peerId] ? peersInterop.push(peerId) : peersNonInterop.push(peerId) : sendDataFn(peerId, channelProp);\n      }\n    }\n\n    self._hasMCU && (peersInterop.length > 0 && sendDataFn(peerId, \"main\", peersInterop), peersNonInterop.length > 0 && sendDataFn(peerId, transferId, peersNonInterop));\n  }, Skylink.prototype._startDataTransfer = function (data, timeout, targetPeerId, sendChunksAsBinary, callback, sessionType) {\n    var self = this,\n        transferId = (self._user ? self._user.sid : \"\") + \"_\" + new Date().getTime(),\n        transferErrors = {},\n        transferCompleted = [],\n        chunks = [],\n        listOfPeers = Object.keys(self._peerConnections),\n        sessionChunkType = \"string\",\n        transferInfo = {\n      name: null,\n      size: null,\n      chunkSize: null,\n      chunkType: null,\n      dataType: null,\n      mimeType: null,\n      direction: self.DATA_TRANSFER_TYPE.UPLOAD,\n      timeout: 60,\n      isPrivate: !1,\n      percentage: 0\n    };\n    \"number\" == typeof timeout ? transferInfo.timeout = timeout : Array.isArray(timeout) ? listOfPeers = timeout : timeout && \"string\" == typeof timeout ? listOfPeers = [timeout] : timeout && \"boolean\" == typeof timeout ? sessionChunkType = \"binary\" : \"function\" == typeof timeout && (callback = timeout), Array.isArray(targetPeerId) ? listOfPeers = targetPeerId : targetPeerId && \"string\" == typeof targetPeerId ? listOfPeers = [targetPeerId] : targetPeerId && \"boolean\" == typeof targetPeerId ? sessionChunkType = \"binary\" : \"function\" == typeof targetPeerId && (callback = targetPeerId), sendChunksAsBinary && \"boolean\" == typeof sendChunksAsBinary ? sessionChunkType = \"binary\" : \"function\" == typeof sendChunksAsBinary && (callback = sendChunksAsBinary), listOfPeers.indexOf(\"MCU\") > -1 && listOfPeers.splice(listOfPeers.indexOf(\"MCU\"), 1);\n\n    var emitErrorBeforeDataTransferFn = function emitErrorBeforeDataTransferFn(error) {\n      if (log.error(error), \"function\" == typeof callback) {\n        var transferErrors = {};\n        if (0 === listOfPeers.length) transferErrors.self = new Error(error);else for (var i = 0; i < listOfPeers.length; i++) {\n          transferErrors[listOfPeers[i]] = new Error(error);\n        }\n        callback({\n          transferId: null,\n          transferInfo: transferInfo,\n          listOfPeers: listOfPeers,\n          transferErrors: transferErrors\n        }, null);\n      }\n    };\n\n    if (\"blob\" === sessionType) {\n      self._hasMCU && \"binary\" === sessionChunkType && (log.warn(\"Binary data chunks transfer is not yet supported with MCU environment. Fallbacking to binary string data chunks transfer.\"), sessionChunkType = \"string\");\n      var chunkSize = \"string\" === sessionChunkType ? \"firefox\" === AdapterJS.webrtcDetectedBrowser ? self._MOZ_CHUNK_FILE_SIZE : self._CHUNK_FILE_SIZE : \"firefox\" === AdapterJS.webrtcDetectedBrowser ? self._MOZ_BINARY_FILE_SIZE : self._BINARY_FILE_SIZE;\n      if (transferInfo.dataType = self.DATA_TRANSFER_SESSION_TYPE.BLOB, transferInfo.chunkSize = \"string\" === sessionChunkType ? 4 * Math.ceil(chunkSize / 3) : chunkSize, transferInfo.chunkType = \"binary\" === sessionChunkType ? self._binaryChunkType : self.DATA_TRANSFER_DATA_TYPE.BINARY_STRING, !(data && \"object\" == typeof data && data instanceof Blob)) return void emitErrorBeforeDataTransferFn(\"Provided data is not a Blob data\");\n      if (transferInfo.name = data.name || transferId, transferInfo.mimeType = data.type || null, data.size < 1) return void emitErrorBeforeDataTransferFn(\"Provided data is not a valid Blob data.\");\n      transferInfo.originalSize = data.size, transferInfo.size = \"string\" === sessionChunkType ? 4 * Math.ceil(data.size / 3) : data.size, chunks = self._chunkBlobData(data, chunkSize);\n    } else {\n      if (transferInfo.dataType = self.DATA_TRANSFER_SESSION_TYPE.DATA_URL, transferInfo.chunkSize = self._CHUNK_DATAURL_SIZE, transferInfo.chunkType = self.DATA_TRANSFER_DATA_TYPE.STRING, !data || \"string\" != typeof data) return void emitErrorBeforeDataTransferFn(\"Provided data is not a dataURL\");\n      transferInfo.originalSize = transferInfo.size = data.length || data.size, chunks = self._chunkDataURL(data, transferInfo.chunkSize);\n    }\n\n    if (!self._user || !self._user.sid) return void emitErrorBeforeDataTransferFn(\"Unable to send any \" + sessionType.replace(\"data\", \"dataURL\") + \" data. User is not in Room.\");\n    if (!self._initOptions.enableDataChannel) return void emitErrorBeforeDataTransferFn(\"Unable to send any \" + sessionType.replace(\"data\", \"dataURL\") + \" data. Datachannel is disabled\");\n    if (0 === listOfPeers.length) return void emitErrorBeforeDataTransferFn(\"Unable to send any \" + sessionType.replace(\"data\", \"dataURL\") + \" data. There are no Peers to start data transfer with\");\n\n    if (self._dataTransfers[transferId] = clone(transferInfo), self._dataTransfers[transferId].peers = {}, self._dataTransfers[transferId].peers.main = {}, self._dataTransfers[transferId].peers[transferId] = {}, self._dataTransfers[transferId].sessions = {}, self._dataTransfers[transferId].chunks = chunks, self._dataTransfers[transferId].enforceBSPeers = [], self._dataTransfers[transferId].enforcedBSInfo = {}, self._dataTransfers[transferId].sessionType = sessionType, self._dataTransfers[transferId].sessionChunkType = sessionChunkType, self._dataTransfers[transferId].senderPeerId = self._user.sid, \"blob\" === sessionType && \"binary\" === sessionChunkType) {\n      for (var p = 0; p < listOfPeers.length; p++) {\n        var protocolVer = ((self._peerInformations[listOfPeers[p]] || {}).agent || {}).DTProtocolVersion || \"0.1.0\";\n        self._isLowerThanVersion(protocolVer, \"0.1.3\") && self._dataTransfers[transferId].enforceBSPeers.push(listOfPeers[p]);\n      }\n\n      if (self._dataTransfers[transferId].enforceBSPeers.length > 0) {\n        var bsChunkSize = \"firefox\" === AdapterJS.webrtcDetectedBrowser ? self._MOZ_CHUNK_FILE_SIZE : self._CHUNK_FILE_SIZE,\n            bsChunks = self._chunkBlobData(new Blob(chunks), bsChunkSize);\n\n        self._dataTransfers[transferId].enforceBSInfo = {\n          chunkSize: 4 * Math.ceil(bsChunkSize / 3),\n          chunkType: self.DATA_TRANSFER_DATA_TYPE.BINARY_STRING,\n          size: 4 * Math.ceil(transferInfo.originalSize / 3),\n          chunks: bsChunks\n        };\n      }\n    }\n\n    for (var completeFn = function completeFn(peerId, error) {\n      transferCompleted.indexOf(peerId) > -1 || (log.debug([peerId, \"RTCDataChannel\", transferId, \"Data transfer result. Is errors present? ->\"], error), transferCompleted.push(peerId), error && (transferErrors[peerId] = new Error(error)), listOfPeers.length === transferCompleted.length && (log.log([null, \"RTCDataChannel\", transferId, \"Data transfer request completed\"]), \"function\" == typeof callback && (Object.keys(transferErrors).length > 0 ? callback({\n        transferId: transferId,\n        transferInfo: self._getTransferInfo(transferId, peerId, !1, !0, !1),\n        transferErrors: transferErrors,\n        listOfPeers: listOfPeers\n      }, null) : callback(null, {\n        transferId: transferId,\n        transferInfo: self._getTransferInfo(transferId, peerId, !1, !0, !1),\n        listOfPeers: listOfPeers\n      }))));\n    }, i = 0; i < listOfPeers.length; i++) {\n      var MCUInteropStatus = self._startDataTransferToPeer(transferId, listOfPeers[i], completeFn, null, null);\n\n      \"boolean\" == typeof MCUInteropStatus && (!0 === MCUInteropStatus ? self._dataTransfers[transferId].peers.main[listOfPeers[i]] = !0 : self._dataTransfers[transferId].peers[transferId][listOfPeers[i]] = !0);\n    }\n\n    self._hasMCU && (Object.keys(self._dataTransfers[transferId].peers.main).length > 0 && self._startDataTransferToPeer(transferId, \"MCU\", completeFn, \"main\", Object.keys(self._dataTransfers[transferId].peers.main)), Object.keys(self._dataTransfers[transferId].peers[transferId]).length > 0 && self._startDataTransferToPeer(transferId, \"MCU\", completeFn, transferId, Object.keys(self._dataTransfers[transferId].peers[transferId])));\n  }, Skylink.prototype._startDataTransferToPeer = function (transferId, peerId, callback, channelProp, targetPeers) {\n    var self = this,\n        peerConnectionStateCbFn = null,\n        dataChannelStateCbFn = null,\n        emitEventFn = function emitEventFn(cb) {\n      for (var peers = targetPeers || [peerId], i = 0; i < peers.length; i++) {\n        cb(peers[i]);\n      }\n    },\n        returnErrorBeforeTransferFn = function returnErrorBeforeTransferFn(error) {\n      var updatedError = \"MCU\" === peerId ? error.replace(/Peer/g, \"MCU Peer\") : error;\n      emitEventFn(function (evtPeerId) {\n        self._trigger(\"dataTransferState\", self.DATA_TRANSFER_STATE.ERROR, transferId, evtPeerId, self._getTransferInfo(transferId, peerId, !0, !0, !1), {\n          message: new Error(updatedError),\n          transferType: self.DATA_TRANSFER_TYPE.UPLOAD\n        });\n      });\n    },\n        sendWRQFn = function sendWRQFn() {\n      var size = self._dataTransfers[transferId].size,\n          chunkSize = self._dataTransfers[transferId].chunkSize,\n          chunkType = self._dataTransfers[transferId].sessionChunkType;\n      self._dataTransfers[transferId].enforceBSPeers.indexOf(peerId) > -1 && (log.warn([peerId, \"RTCDataChannel\", transferId, \"Binary data chunks transfer is not yet supported with Peer connecting from Android, iOS and C++ SDK. Fallbacking to binary string data chunks transfer.\"]), size = self._dataTransfers[transferId].enforceBSInfo.size, chunkSize = self._dataTransfers[transferId].enforceBSInfo.chunkSize, chunkType = \"string\"), self._sendMessageToDataChannel(peerId, {\n        type: self._DC_PROTOCOL_TYPE.WRQ,\n        transferId: transferId,\n        name: self._dataTransfers[transferId].name,\n        size: size,\n        originalSize: self._dataTransfers[transferId].originalSize,\n        dataType: self._dataTransfers[transferId].sessionType,\n        mimeType: self._dataTransfers[transferId].mimeType,\n        chunkType: chunkType,\n        chunkSize: chunkSize,\n        timeout: self._dataTransfers[transferId].timeout,\n        isPrivate: self._dataTransfers[transferId].isPrivate,\n        sender: self._user.sid,\n        agent: AdapterJS.webrtcDetectedBrowser,\n        version: AdapterJS.webrtcDetectedVersion,\n        target: targetPeers || peerId\n      }, channelProp), emitEventFn(function (evtPeerId) {\n        self._trigger(\"incomingDataRequest\", transferId, evtPeerId, self._getTransferInfo(transferId, peerId, !1, !1, !1), !0), self._trigger(\"dataTransferState\", self.DATA_TRANSFER_STATE.USER_UPLOAD_REQUEST, transferId, evtPeerId, self._getTransferInfo(transferId, peerId, !0, !1, !1), null);\n      });\n    };\n\n    if (\"MCU\" !== peerId) {\n      var dataTransferStateCbFn = function dataTransferStateCbFn(state, evtTransferId, evtPeerId, transferInfo, error) {\n        peerConnectionStateCbFn && self.off(\"peerConnectionState\", peerConnectionStateCbFn), dataChannelStateCbFn && self.off(\"dataChannelState\", dataChannelStateCbFn), channelProp && delete self._dataTransfers[transferId].peers[channelProp][peerId], callback(peerId, state === self.DATA_TRANSFER_STATE.UPLOAD_COMPLETED ? null : error.message.message || error.message.toString()), delete self._dataTransfers[transferId].sessions[peerId], self._hasMCU && 0 === Object.keys(self._dataTransfers[transferId].peers.main).length && self._dataChannels.MCU && self._dataChannels.MCU.main ? self._dataChannels.MCU.main.transferId = null : \"main\" === channelProp && self._dataChannels[peerId] && self._dataChannels[peerId].main && (self._dataChannels[peerId].main.transferId = null), 0 === Object.keys(self._dataTransfers[transferId].sessions).length && delete self._dataTransfers[transferId];\n      };\n\n      self.once(\"dataTransferState\", dataTransferStateCbFn, function (state, evtTransferId, evtPeerId) {\n        return self._dataTransfers[transferId] && (self._hasMCU ? self._dataTransfers[transferId].peers.main[peerId] || self._dataTransfers[transferId].peers[transferId][peerId] : self._dataTransfers[transferId].sessions[peerId]) ? evtTransferId === transferId && evtPeerId === peerId && [self.DATA_TRANSFER_STATE.UPLOAD_COMPLETED, self.DATA_TRANSFER_STATE.ERROR, self.DATA_TRANSFER_STATE.CANCEL, self.DATA_TRANSFER_STATE.REJECTED].indexOf(state) > -1 : (dataTransferStateCbFn && self.off(\"dataTransferState\", dataTransferStateCbFn), peerConnectionStateCbFn && self.off(\"peerConnectionState\", peerConnectionStateCbFn), void (dataChannelStateCbFn && self.off(\"dataChannelState\", dataChannelStateCbFn)));\n      });\n    }\n\n    if (!self._peerConnections[peerId]) return void returnErrorBeforeTransferFn(\"Unable to start data transfer as Peer connection does not exists.\");\n    if (!self._peerInformations[peerId]) return void returnErrorBeforeTransferFn(\"Unable to start data transfer as Peer connection does not exists.\");\n    if (self._peerConnections[peerId].signalingState !== self.PEER_CONNECTION_STATE.STABLE) return void returnErrorBeforeTransferFn(\"Unable to start data transfer as Peer connection is not stable.\");\n    if (!self._dataTransfers[transferId]) return void returnErrorBeforeTransferFn(\"Unable to start data transfer as data transfer session is not in order.\");\n    if (!self._dataChannels[peerId] || !self._dataChannels[peerId].main) return void returnErrorBeforeTransferFn(\"Unable to start data transfer as Peer Datachannel connection does not exists.\");\n    if (self._dataChannels[peerId].main.channel.readyState !== self.DATA_CHANNEL_STATE.OPEN) return void returnErrorBeforeTransferFn(\"Unable to start data transfer as Peer Datachannel connection is not opened.\");\n    var streamId = self._dataChannels[peerId].main.streamId;\n    if (streamId && \"main\" === channelProp && self._dataStreams[streamId] && (\"string\" === self._dataStreams[streamId].sessionChunkType && (\"string\" === self._dataTransfers[transferId].sessionChunkType || self._dataTransfers[transferId].enforceBSPeers.indexOf(peerId) > -1) || \"binary\" === self._dataStreams[streamId].sessionChunkType && \"binary\" === self._dataStreams[streamId].sessionChunkType && -1 === self._dataTransfers[transferId].enforceBSPeers.indexOf(peerId))) return void returnErrorBeforeTransferFn(\"Unable to start data transfer as Peer Datachannel currently has an active \" + self._dataStreams[streamId].sessionChunkType + \" data streaming session.\");\n    var protocolVer = (self._peerInformations[peerId].agent || {}).DTProtocolVersion || \"0.1.0\",\n        requireInterop = self._isLowerThanVersion(protocolVer, \"0.1.2\") || !self._initOptions.enableSimultaneousTransfers;\n    return self._isLowerThanVersion(protocolVer, \"0.1.2\") && \"data\" === self._dataTransfers[transferId].sessionType && \"string\" === self._dataTransfers[transferId].sessionChunkType ? void returnErrorBeforeTransferFn(\"Unable to start data transfer as Peer do not support DATA_URL type of data transfers\") : \"MCU\" !== peerId && self._hasMCU ? (channelProp = requireInterop ? \"main\" : transferId, peerConnectionStateCbFn = function peerConnectionStateCbFn() {\n      returnErrorBeforeTransferFn(\"Data transfer terminated as Peer connection is not stable.\");\n    }, self.once(\"peerConnectionState\", peerConnectionStateCbFn, function (state, evtPeerId) {\n      return self._dataTransfers[transferId] ? state !== self.PEER_CONNECTION_STATE.STABLE && evtPeerId === peerId : void self.off(\"peerConnectionState\", peerConnectionStateCbFn);\n    }), requireInterop) : (requireInterop || \"main\" === channelProp) && self._dataChannels[peerId].main.transferId ? void returnErrorBeforeTransferFn(\"Unable to start data transfer as Peer Datachannel has a data transfer in-progress.\") : (self._dataTransfers[transferId].sessions[peerId] = {\n      timer: null,\n      ackN: 0\n    }, dataChannelStateCbFn = function dataChannelStateCbFn(state, evtPeerId, error) {\n      self._dataTransfers[transferId].sessions[peerId].ackN >= self._dataTransfers[transferId].chunks.length - 1 || returnErrorBeforeTransferFn(error ? error.message || error.toString() : \"Data transfer terminated as Peer Datachannel connection closed abruptly.\");\n    }, self.once(\"dataChannelState\", dataChannelStateCbFn, function (state, evtPeerId, error, channelName, channelType) {\n      if (!self._dataTransfers[transferId] || !self._dataTransfers[transferId].sessions[peerId]) return void self.off(\"dataChannelState\", dataChannelStateCbFn);\n      if (evtPeerId === peerId && (\"main\" === channelProp ? channelType === self.DATA_CHANNEL_TYPE.MESSAGING : channelName === transferId)) return state === self.DATA_CHANNEL_STATE.OPEN && \"main\" !== channelProp && channelName === transferId ? (self._dataChannels[peerId][channelProp].transferId = transferId, sendWRQFn(), !1) : [self.DATA_CHANNEL_STATE.CREATE_ERROR, self.DATA_CHANNEL_STATE.ERROR, self.DATA_CHANNEL_STATE.CLOSING, self.DATA_CHANNEL_STATE.CLOSED].indexOf(state) > -1;\n    }), void (requireInterop && \"MCU\" !== peerId || \"main\" === channelProp ? (channelProp = \"main\", self._dataChannels[peerId].main.transferId = transferId, sendWRQFn()) : (channelProp = transferId, self._createDataChannel(peerId, transferId, \"data\" === self._dataTransfers[transferId].sessionType ? self._CHUNK_DATAURL_SIZE : \"string\" === self._dataTransfers[transferId].sessionChunkType ? \"firefox\" === AdapterJS.webrtcDetectedBrowser ? 16384 : 65546 : \"firefox\" === AdapterJS.webrtcDetectedBrowser ? self._MOZ_BINARY_FILE_SIZE : self._BINARY_FILE_SIZE))));\n  }, Skylink.prototype._getTransferInfo = function (transferId, peerId, returnDataProp, hidePercentage, returnDataAtStart) {\n    if (!this._dataTransfers[transferId]) return {};\n    var transferInfo = {\n      name: this._dataTransfers[transferId].name,\n      size: this._dataTransfers[transferId].size,\n      dataType: this._dataTransfers[transferId].dataType || this.DATA_TRANSFER_SESSION_TYPE.BLOB,\n      mimeType: this._dataTransfers[transferId].mimeType || null,\n      chunkSize: this._dataTransfers[transferId].chunkSize,\n      chunkType: this._dataTransfers[transferId].chunkType,\n      timeout: this._dataTransfers[transferId].timeout,\n      isPrivate: this._dataTransfers[transferId].isPrivate,\n      direction: this._dataTransfers[transferId].direction\n    };\n\n    if (this._dataTransfers[transferId].originalSize ? transferInfo.size = this._dataTransfers[transferId].originalSize : this._dataTransfers[transferId].chunkType === this.DATA_TRANSFER_DATA_TYPE.BINARY_STRING && (transferInfo.size = Math.ceil(3 * transferInfo.size / 4)), !hidePercentage) {\n      if (transferInfo.percentage = 0, !this._dataTransfers[transferId].sessions[peerId]) return returnDataProp && (transferInfo.data = null), transferInfo;\n      if (this._dataTransfers[transferId].direction === this.DATA_TRANSFER_TYPE.DOWNLOAD) this._dataTransfers[transferId].sessions[peerId].receivedSize === this._dataTransfers[transferId].sessions[peerId].size ? transferInfo.percentage = 100 : transferInfo.percentage = parseFloat((this._dataTransfers[transferId].sessions[peerId].receivedSize / this._dataTransfers[transferId].size * 100).toFixed(2), 10);else {\n        var chunksLength = this._dataTransfers[transferId].enforceBSPeers.indexOf(peerId) > -1 ? this._dataTransfers[transferId].enforceBSInfo.chunks.length : this._dataTransfers[transferId].chunks.length;\n        this._dataTransfers[transferId].sessions[peerId].ackN === chunksLength ? transferInfo.percentage = 100 : transferInfo.percentage = parseFloat((this._dataTransfers[transferId].sessions[peerId].ackN / chunksLength * 100).toFixed(2), 10);\n      }\n      returnDataProp && (\"number\" != typeof returnDataAtStart ? 100 === transferInfo.percentage ? transferInfo.data = this._getTransferData(transferId) : transferInfo.data = null : (transferInfo.percentage = returnDataAtStart, 0 === returnDataAtStart && (transferInfo.data = this._getTransferData(transferId))));\n    }\n\n    return transferInfo;\n  }, Skylink.prototype._getTransferData = function (transferId) {\n    if (!this._dataTransfers[transferId]) return null;\n\n    if (this._dataTransfers[transferId].dataType === this.DATA_TRANSFER_SESSION_TYPE.BLOB) {\n      var mimeType = {\n        name: this._dataTransfers[transferId].name\n      };\n      return this._dataTransfers[transferId].mimeType && (mimeType.type = this._dataTransfers[transferId].mimeType), new Blob(this._dataTransfers[transferId].chunks, mimeType);\n    }\n\n    return this._dataTransfers[transferId].chunks.join(\"\");\n  }, Skylink.prototype._handleDataTransferTimeoutForPeer = function (transferId, peerId, setPeerTO) {\n    var self = this;\n    if (!self._dataTransfers[transferId] || !self._dataTransfers[transferId].sessions[peerId]) return void log.debug([peerId, \"RTCDataChannel\", transferId, \"Data transfer does not exists for Peer. Ignoring timeout.\"]);\n    log.debug([peerId, \"RTCDataChannel\", transferId, \"Clearing data transfer timer for Peer.\"]), self._dataTransfers[transferId].sessions[peerId].timer && clearTimeout(self._dataTransfers[transferId].sessions[peerId].timer), self._dataTransfers[transferId].sessions[peerId].timer = null, setPeerTO && (log.debug([peerId, \"RTCDataChannel\", transferId, \"Setting data transfer timer for Peer.\"]), self._dataTransfers[transferId].sessions[peerId].timer = setTimeout(function () {\n      if (!self._dataTransfers[transferId] || !self._dataTransfers[transferId].sessions[peerId]) return void log.debug([peerId, \"RTCDataChannel\", transferId, \"Data transfer already ended for Peer. Ignoring expired timeout.\"]);\n      if (!self._user || !self._user.sid) return void log.debug([peerId, \"RTCDataChannel\", transferId, \"User is not in Room. Ignoring expired timeout.\"]);\n      if (!self._dataChannels[peerId]) return void log.debug([peerId, \"RTCDataChannel\", transferId, \"Datachannel connection does not exists. Ignoring expired timeout.\"]);\n      log.error([peerId, \"RTCDataChannel\", transferId, \"Data transfer response has timed out.\"]);\n\n      var emitEventFn = function emitEventFn(cb) {\n        if (\"MCU\" === peerId) {\n          for (var broadcastedPeers = [self._dataTransfers[transferId].peers.main, self._dataTransfers[transferId].peers[transferId]], i = 0; i < broadcastedPeers.length; i++) {\n            if (broadcastedPeers[i]) for (var bcPeerId in broadcastedPeers[i]) {\n              broadcastedPeers[i].hasOwnProperty(bcPeerId) && broadcastedPeers[i][bcPeerId] && cb(bcPeerId);\n            }\n          }\n        } else cb(peerId);\n      },\n          errorMsg = \"Connection Timeout. Longer than \" + self._dataTransfers[transferId].timeout + \" seconds. Connection is abolished.\";\n\n      self._sendMessageToDataChannel(peerId, {\n        type: self._DC_PROTOCOL_TYPE.ERROR,\n        content: errorMsg,\n        isUploadError: self._dataTransfers[transferId].direction === self.DATA_TRANSFER_TYPE.UPLOAD,\n        sender: self._user.sid,\n        name: self._dataTransfers[transferId].name\n      }, self._dataChannels[peerId][transferId] ? transferId : \"main\"), emitEventFn(function (evtPeerId) {\n        self._trigger(\"dataTransferState\", self.DATA_TRANSFER_STATE.ERROR, transferId, peerId, self._getTransferInfo(transferId, peerId, !0, !1, !1), {\n          transferType: self.DATA_TRANSFER_TYPE.DOWNLOAD,\n          message: new Error(errorMsg)\n        });\n      });\n    }, 1e3 * self._dataTransfers[transferId].timeout));\n  }, Skylink.prototype._processDataChannelData = function (rawData, peerId, channelName, channelType) {\n    var self = this,\n        transferId = null,\n        streamId = null,\n        isStreamChunk = !1,\n        channelProp = channelType === self.DATA_CHANNEL_TYPE.MESSAGING ? \"main\" : channelName,\n        objPeerDataChannel = self._dataChannels[peerId] || {};\n\n    if (objPeerDataChannel.hasOwnProperty(channelProp) && \"object\" == typeof objPeerDataChannel[channelProp]) {\n      if (transferId = objPeerDataChannel[channelProp].transferId, streamId = objPeerDataChannel[channelProp].streamId, streamId && self._dataStreams[streamId] && (isStreamChunk = \"string\" === self._dataStreams[streamId].sessionChunkType ? \"string\" == typeof rawData : \"object\" == typeof rawData), !self._peerConnections[peerId]) return void log.warn([peerId, \"RTCDataChannel\", channelProp, \"Dropping data received from Peer as connection is not present ->\"], rawData);\n      if (!self._dataChannels[peerId] || !self._dataChannels[peerId][channelProp]) return void log.warn([peerId, \"RTCDataChannel\", channelProp, \"Dropping data received from Peer as Datachannel connection is not present ->\"], rawData);\n      if (\"string\" == typeof rawData) try {\n        var protocolData = JSON.parse(rawData);\n        if (isStreamChunk = !1, log.debug([peerId, \"RTCDataChannel\", channelProp, 'Received protocol \"' + protocolData.type + '\" message ->'], protocolData), [self._DC_PROTOCOL_TYPE.ACK, self._DC_PROTOCOL_TYPE.ERROR, self._DC_PROTOCOL_TYPE.CANCEL].indexOf(protocolData.type) > -1 && !(transferId && self._dataTransfers[transferId] && self._dataTransfers[transferId].sessions[peerId])) return void log.warn([peerId, \"RTCDataChannel\", channelProp, \"Discarded protocol message as data transfer session is not present ->\"], protocolData);\n\n        switch (protocolData.type) {\n          case self._DC_PROTOCOL_TYPE.WRQ:\n            if (transferId && self._dataTransfers[transferId] && self._dataTransfers[transferId].sessions[peerId]) return log.warn([peerId, \"RTCDataChannel\", channelProp, \"Rejecting bidirectional data transfer request as it is currently not supported in the SDK ->\"], protocolData), void self._sendMessageToDataChannel(peerId, {\n              type: self._DC_PROTOCOL_TYPE.ACK,\n              ackN: -1,\n              sender: self._user.sid\n            }, channelProp);\n\n            self._WRQProtocolHandler(peerId, protocolData, channelProp);\n\n            break;\n\n          case self._DC_PROTOCOL_TYPE.ACK:\n            self._ACKProtocolHandler(peerId, protocolData, channelProp);\n\n            break;\n\n          case self._DC_PROTOCOL_TYPE.ERROR:\n            self._ERRORProtocolHandler(peerId, protocolData, channelProp);\n\n            break;\n\n          case self._DC_PROTOCOL_TYPE.CANCEL:\n            self._CANCELProtocolHandler(peerId, protocolData, channelProp);\n\n            break;\n\n          case self._DC_PROTOCOL_TYPE.MESSAGE:\n            self._MESSAGEProtocolHandler(peerId, protocolData, channelProp);\n\n            break;\n\n          default:\n            log.warn([peerId, \"RTCDataChannel\", channelProp, 'Discarded unknown \"' + protocolData.type + '\" message ->'], protocolData);\n        }\n      } catch (error) {\n        if (rawData.indexOf(\"{\") > -1 && rawData.indexOf(\"}\") > 0) throw log.error([peerId, \"RTCDataChannel\", channelProp, \"Failed parsing protocol step data error ->\"], {\n          data: rawData,\n          error: error\n        }), self._trigger(\"dataChannelState\", self.DATA_CHANNEL_STATE.ERROR, peerId, error, channelName, channelType, null, self._getDataChannelBuffer(peerId, channelProp)), error;\n        if (!(isStreamChunk || transferId && self._dataTransfers[transferId] && self._dataTransfers[transferId].sessions[peerId])) return void log.warn([peerId, \"RTCDataChannel\", channelProp, \"Discarded data chunk without session ->\"], rawData);\n        if (!isStreamChunk && transferId && self._dataTransfers[transferId].chunks[self._dataTransfers[transferId].sessions[peerId].ackN]) return void log.warn([peerId, \"RTCDataChannel\", transferId, \"Dropping data chunk \" + (isStreamChunk ? \"\" : \"@\" + self._dataTransfers[transferId].sessions[peerId].ackN) + \" as it has already been added ->\"], rawData);\n        self.DATA_TRANSFER_DATA_TYPE.BINARY_STRING;\n        if (isStreamChunk || self._dataTransfers[transferId].dataType === self.DATA_TRANSFER_SESSION_TYPE.DATA_URL) log.debug([peerId, \"RTCDataChannel\", channelProp, \"Received string data chunk \" + (isStreamChunk ? \"\" : \"@\" + self._dataTransfers[transferId].sessions[peerId].ackN) + \" with size ->\"], rawData.length || rawData.size), self._DATAProtocolHandler(peerId, rawData, self.DATA_TRANSFER_DATA_TYPE.STRING, rawData.length || rawData.size || 0, channelProp);else {\n          var removeSpaceData = rawData.replace(/\\s|\\r|\\n/g, \"\");\n          log.debug([peerId, \"RTCDataChannel\", channelProp, \"Received binary string data chunk @\" + self._dataTransfers[transferId].sessions[peerId].ackN + \" with size ->\"], removeSpaceData.length || removeSpaceData.size), self._DATAProtocolHandler(peerId, self._base64ToBlob(removeSpaceData), self.DATA_TRANSFER_DATA_TYPE.BINARY_STRING, removeSpaceData.length || removeSpaceData.size || 0, channelProp);\n        }\n      } else {\n        if (!(isStreamChunk || transferId && self._dataTransfers[transferId] && self._dataTransfers[transferId].sessions[peerId])) return void log.warn([peerId, \"RTCDataChannel\", channelProp, \"Discarded data chunk without session ->\"], rawData);\n        if (!isStreamChunk && transferId && self._dataTransfers[transferId].chunks[self._dataTransfers[transferId].sessions[peerId].ackN]) return void log.warn([peerId, \"RTCDataChannel\", transferId, \"Dropping data chunk \" + (isStreamChunk ? \"\" : \"@\" + self._dataTransfers[transferId].sessions[peerId].ackN) + \" as it has already been added ->\"], rawData);\n        if (rawData instanceof Blob) log.debug([peerId, \"RTCDataChannel\", channelProp, \"Received blob data chunk \" + (isStreamChunk ? \"\" : \"@\" + self._dataTransfers[transferId].sessions[peerId].ackN) + \" with size ->\"], rawData.size), self._DATAProtocolHandler(peerId, rawData, self.DATA_TRANSFER_DATA_TYPE.BLOB, rawData.size, channelProp);else {\n          var byteArray = rawData,\n              blob = null;\n\n          if (rawData.constructor && \"Array\" === rawData.constructor.name && (byteArray = new Int8Array(rawData)), \"IE\" === AdapterJS.webrtcDetectedBrowser) {\n            if (window.BlobBuilder) {\n              var bb = new BlobBuilder();\n              bb.append(rawData.constructor && \"ArrayBuffer\" === rawData.constructor.name ? byteArray : new Uint8Array(byteArray).buffer), blob = bb.getBlob();\n            }\n          } else blob = new Blob([byteArray]);\n\n          log.debug([peerId, \"RTCDataChannel\", channelProp, \"Received arraybuffer data chunk \" + (isStreamChunk ? \"\" : \"@\" + self._dataTransfers[transferId].sessions[peerId].ackN) + \" with size ->\"], blob.size), self._DATAProtocolHandler(peerId, blob, self.DATA_TRANSFER_DATA_TYPE.ARRAY_BUFFER, blob.size, channelProp);\n        }\n      }\n    }\n  }, Skylink.prototype._WRQProtocolHandler = function (peerId, data, channelProp) {\n    var self = this,\n        transferId = \"main\" === channelProp ? data.transferId || null : channelProp,\n        senderPeerId = data.sender || peerId;\n    if ([\"fastBinaryStart\", \"fastBinaryStop\"].indexOf(data.dataType) > -1) {\n      if (\"fastBinaryStart\" === data.dataType) {\n        transferId || (transferId = \"stream_\" + peerId + \"_\" + new Date().getTime()), self._dataStreams[transferId] = {\n          chunkSize: 0,\n          chunkType: \"string\" === data.chunkType ? self.DATA_TRANSFER_DATA_TYPE.STRING : self._binaryChunkType,\n          sessionChunkType: data.chunkType,\n          isPrivate: !!data.isPrivate,\n          isStringStream: \"string\" === data.chunkType,\n          senderPeerId: senderPeerId,\n          isUpload: !1\n        }, self._dataChannels[peerId][channelProp].streamId = transferId;\n        self.once(\"dataChannelState\", function () {}, function (state, evtPeerId, channelName, channelType, error) {\n          if (!self._dataStreams[transferId]) return !0;\n\n          if (evtPeerId === peerId && (\"main\" === channelProp ? channelType === self.DATA_CHANNEL_TYPE.MESSAGING : channelName === transferId && channelType === self.DATA_CHANNEL_TYPE.DATA) && [self.DATA_CHANNEL_STATE.ERROR, self.DATA_CHANNEL_STATE.CLOSED].indexOf(state) > -1) {\n            var updatedError = new Error(error && error.message ? error.message : 'Failed data transfer as datachannel state is \"' + state + '\".');\n            return self._trigger(\"dataStreamState\", self.DATA_STREAM_STATE.ERROR, transferId, senderPeerId, {\n              chunk: null,\n              chunkSize: 0,\n              chunkType: self._dataStreams[transferId].chunkType,\n              isPrivate: self._dataStreams[transferId].isPrivate,\n              isStringStream: \"string\" === self._dataStreams[transferId].sessionChunkType,\n              senderPeerId: senderPeerId\n            }, updatedError), !0;\n          }\n        }), self._trigger(\"dataStreamState\", self.DATA_STREAM_STATE.RECEIVING_STARTED, transferId, senderPeerId, {\n          chunk: null,\n          chunkSize: 0,\n          chunkType: self._dataStreams[transferId].chunkType,\n          isPrivate: self._dataStreams[transferId].isPrivate,\n          isStringStream: \"string\" === self._dataStreams[transferId].sessionChunkType,\n          senderPeerId: senderPeerId\n        }, null), self._trigger(\"incomingDataStreamStarted\", transferId, senderPeerId, {\n          chunkSize: 0,\n          chunkType: self._dataStreams[transferId].chunkType,\n          isPrivate: self._dataStreams[transferId].isPrivate,\n          isStringStream: \"string\" === self._dataStreams[transferId].sessionChunkType,\n          senderPeerId: senderPeerId\n        }, !1);\n      } else transferId = self._dataChannels[peerId][channelProp].streamId, self._dataStreams[transferId] && !self._dataStreams[transferId].isUpload && (self._trigger(\"dataStreamState\", self.DATA_STREAM_STATE.RECEIVING_STOPPED, transferId, senderPeerId, {\n        chunk: null,\n        chunkSize: 0,\n        chunkType: self._dataStreams[transferId].chunkType,\n        isPrivate: self._dataStreams[transferId].isPrivate,\n        isStringStream: \"string\" === self._dataStreams[transferId].sessionChunkType,\n        senderPeerId: senderPeerId\n      }, null), self._trigger(\"incomingDataStreamStopped\", transferId, senderPeerId, {\n        chunkSize: 0,\n        chunkType: self._dataStreams[transferId].chunkType,\n        isPrivate: self._dataStreams[transferId].isPrivate,\n        isStringStream: \"string\" === self._dataStreams[transferId].sessionChunkType,\n        senderPeerId: senderPeerId\n      }, !1), self._dataChannels[peerId][channelProp].streamId = null, \"main\" !== channelProp && self._closeDataChannel(peerId, channelProp), delete self._dataStreams[transferId]);\n    } else transferId || (transferId = \"transfer_\" + peerId + \"_\" + new Date().getTime()), self._dataTransfers[transferId] = {\n      name: data.name || transferId,\n      size: data.size || 0,\n      chunkSize: data.chunkSize,\n      originalSize: data.originalSize || 0,\n      timeout: data.timeout || 60,\n      isPrivate: !!data.isPrivate,\n      senderPeerId: data.sender || peerId,\n      dataType: self.DATA_TRANSFER_SESSION_TYPE.BLOB,\n      mimeType: data.mimeType || null,\n      chunkType: self.DATA_TRANSFER_DATA_TYPE.BINARY_STRING,\n      direction: self.DATA_TRANSFER_TYPE.DOWNLOAD,\n      chunks: [],\n      sessions: {},\n      sessionType: data.dataType || \"blob\",\n      sessionChunkType: data.chunkType || \"string\"\n    }, \"data\" === self._dataTransfers[transferId].sessionType && \"string\" === self._dataTransfers[transferId].sessionChunkType ? (self._dataTransfers[transferId].dataType = self.DATA_TRANSFER_SESSION_TYPE.DATA_URL, self._dataTransfers[transferId].chunkType = self.DATA_TRANSFER_DATA_TYPE.STRING) : \"blob\" === self._dataTransfers[transferId].sessionType && \"binary\" === self._dataTransfers[transferId].sessionChunkType && (self._dataTransfers[transferId].chunkType = self._binaryChunkType), self._dataChannels[peerId][channelProp].transferId = transferId, self._dataTransfers[transferId].sessions[peerId] = {\n      timer: null,\n      ackN: 0,\n      receivedSize: 0\n    }, self._trigger(\"incomingDataRequest\", transferId, senderPeerId, self._getTransferInfo(transferId, peerId, !1, !1, !1), !1), self._trigger(\"dataTransferState\", self.DATA_TRANSFER_STATE.UPLOAD_REQUEST, transferId, senderPeerId, self._getTransferInfo(transferId, peerId, !0, !1, !1), null);\n  }, Skylink.prototype._ACKProtocolHandler = function (peerId, data, channelProp) {\n    var self = this,\n        transferId = channelProp,\n        senderPeerId = data.sender || peerId;\n    \"main\" === channelProp && (transferId = self._dataChannels[peerId].main.transferId), self._handleDataTransferTimeoutForPeer(transferId, peerId, !1);\n\n    var emitEventFn = function emitEventFn(cb) {\n      if (\"MCU\" === peerId) {\n        if (!self._dataTransfers[transferId].peers[channelProp]) return void log.warn([peerId, \"RTCDataChannel\", channelProp, \"Dropping triggering of ACK event as Peers list does not exists\"]);\n\n        for (var evtPeerId in self._dataTransfers[transferId].peers[channelProp]) {\n          self._dataTransfers[transferId].peers[channelProp].hasOwnProperty(evtPeerId) && self._dataTransfers[transferId].peers[channelProp][evtPeerId] && cb(evtPeerId);\n        }\n      } else cb(senderPeerId);\n    };\n\n    if (data.ackN > -1) {\n      if (0 === data.ackN) emitEventFn(function (evtPeerId) {\n        self._trigger(\"dataTransferState\", self.DATA_TRANSFER_STATE.UPLOAD_STARTED, transferId, evtPeerId, self._getTransferInfo(transferId, peerId, !0, !1, 0), null);\n      });else if (self._dataTransfers[transferId].enforceBSPeers.indexOf(peerId) > -1 ? data.ackN === self._dataTransfers[transferId].enforceBSInfo.chunks.length : data.ackN === self._dataTransfers[transferId].chunks.length) return self._dataTransfers[transferId].sessions[peerId].ackN = data.ackN, emitEventFn(function (evtPeerId) {\n        self._trigger(\"incomingData\", self._getTransferData(transferId), transferId, evtPeerId, self._getTransferInfo(transferId, peerId, !1, !1, !1), !0), self._trigger(\"dataTransferState\", self.DATA_TRANSFER_STATE.UPLOAD_COMPLETED, transferId, evtPeerId, self._getTransferInfo(transferId, peerId, !0, !1, 100), null);\n      }), void (self._dataChannels[peerId][channelProp] && (self._dataChannels[peerId][channelProp].transferId = null, \"main\" !== channelProp && self._closeDataChannel(peerId, channelProp)));\n\n      var uploadFn = function uploadFn(chunk) {\n        self._sendMessageToDataChannel(peerId, chunk, channelProp, !0), data.ackN < self._dataTransfers[transferId].chunks.length && emitEventFn(function (evtPeerId) {\n          self._trigger(\"dataTransferState\", self.DATA_TRANSFER_STATE.UPLOADING, transferId, evtPeerId, self._getTransferInfo(transferId, peerId, !0, !1, !1), null);\n        }), self._handleDataTransferTimeoutForPeer(transferId, peerId, !0);\n      };\n\n      self._dataTransfers[transferId].sessions[peerId].ackN = data.ackN, self._dataTransfers[transferId].enforceBSPeers.indexOf(peerId) > -1 ? self._blobToBase64(self._dataTransfers[transferId].enforceBSInfo.chunks[data.ackN], uploadFn) : self._dataTransfers[transferId].chunkType === self.DATA_TRANSFER_DATA_TYPE.BINARY_STRING ? self._blobToBase64(self._dataTransfers[transferId].chunks[data.ackN], uploadFn) : self._dataTransfers[transferId].chunkType === self.DATA_TRANSFER_DATA_TYPE.ARRAY_BUFFER ? self._blobToArrayBuffer(self._dataTransfers[transferId].chunks[data.ackN], uploadFn) : uploadFn(self._dataTransfers[transferId].chunks[data.ackN]);\n    } else self._trigger(\"dataTransferState\", self.DATA_TRANSFER_STATE.REJECTED, transferId, senderPeerId, self._getTransferInfo(transferId, peerId, !0, !1, !1), {\n      message: new Error(\"Data transfer terminated as Peer has rejected data transfer request\"),\n      transferType: self.DATA_TRANSFER_TYPE.UPLOAD\n    });\n  }, Skylink.prototype._MESSAGEProtocolHandler = function (peerId, data, channelProp) {\n    var senderPeerId = data.sender || peerId;\n    log.log([senderPeerId, \"RTCDataChannel\", channelProp, \"Received P2P message from peer:\"], data), this._trigger(\"incomingMessage\", {\n      content: data.data,\n      isPrivate: data.isPrivate,\n      isDataChannel: !0,\n      targetPeerId: this._user.sid,\n      senderPeerId: senderPeerId\n    }, senderPeerId, this.getPeerInfo(senderPeerId), !1);\n  }, Skylink.prototype._ERRORProtocolHandler = function (peerId, data, channelProp) {\n    var self = this,\n        transferId = channelProp,\n        senderPeerId = data.sender || peerId;\n    \"main\" === channelProp && (transferId = self._dataChannels[peerId].main.transferId), self._handleDataTransferTimeoutForPeer(transferId, peerId, !1);\n\n    var emitEventFn = function emitEventFn(cb) {\n      if (\"MCU\" === peerId) {\n        if (!self._dataTransfers[transferId].peers[channelProp]) return void log.warn([peerId, \"RTCDataChannel\", channelProp, \"Dropping triggering of ERROR event as Peers list does not exists\"]);\n\n        for (var evtPeerId in self._dataTransfers[transferId].peers[channelProp]) {\n          self._dataTransfers[transferId].peers[channelProp].hasOwnProperty(evtPeerId) && self._dataTransfers[transferId].peers[channelProp][evtPeerId] && cb(evtPeerId);\n        }\n      } else cb(senderPeerId);\n    };\n\n    log.error([peerId, \"RTCDataChannel\", channelProp, \"Received an error from peer ->\"], data), emitEventFn(function (evtPeerId) {\n      self._trigger(\"dataTransferState\", self.DATA_TRANSFER_STATE.ERROR, transferId, evtPeerId, self._getTransferInfo(transferId, peerID, !0, !1, !1), {\n        message: new Error(data.content),\n        transferType: self._dataTransfers[transferId].direction\n      });\n    });\n  }, Skylink.prototype._CANCELProtocolHandler = function (peerId, data, channelProp) {\n    var self = this,\n        transferId = channelProp;\n    \"main\" === channelProp && (transferId = self._dataChannels[peerId].main.transferId), self._handleDataTransferTimeoutForPeer(transferId, peerId, !1);\n\n    var emitEventFn = function emitEventFn(cb) {\n      if (\"MCU\" === peerId) {\n        if (!self._dataTransfers[transferId].peers[channelProp]) return void log.warn([peerId, \"RTCDataChannel\", channelProp, \"Dropping triggering of CANCEL event as Peers list does not exists\"]);\n\n        for (var evtPeerId in self._dataTransfers[transferId].peers[channelProp]) {\n          self._dataTransfers[transferId].peers[channelProp].hasOwnProperty(evtPeerId) && self._dataTransfers[transferId].peers[channelProp][evtPeerId] && cb(evtPeerId);\n        }\n      } else cb(peerId);\n    };\n\n    log.error([peerId, \"RTCDataChannel\", channelProp, \"Received data transfer termination from peer ->\"], data), emitEventFn(function (evtPeerId) {\n      self._trigger(\"dataTransferState\", self.DATA_TRANSFER_STATE.CANCEL, transferId, evtPeerId, self._getTransferInfo(transferId, peerId, !0, !1, !1), {\n        message: new Error(data.content || \"Peer has terminated data transfer.\"),\n        transferType: self._dataTransfers[transferId].direction\n      });\n    });\n  }, Skylink.prototype._DATAProtocolHandler = function (peerId, chunk, chunkType, chunkSize, channelProp) {\n    var self = this,\n        transferId = channelProp,\n        senderPeerId = peerId;\n\n    if (self._dataChannels[peerId] && self._dataChannels[peerId][channelProp]) {\n      var streamId = self._dataChannels[peerId][channelProp].streamId;\n      if (streamId && self._dataStreams[streamId] && (\"string\" == typeof chunk && \"string\" === self._dataStreams[streamId].sessionChunkType || chunk instanceof Blob && \"binary\" === self._dataStreams[streamId].sessionChunkType)) return senderPeerId = self._dataStreams[streamId].senderPeerId || peerId, self._trigger(\"dataStreamState\", self.DATA_STREAM_STATE.RECEIVED, streamId, senderPeerId, {\n        chunk: chunk,\n        chunkSize: chunkSize,\n        chunkType: chunkType,\n        isPrivate: self._dataStreams[streamId].sessionChunkType.isPrivate,\n        isStringStream: \"string\" === self._dataStreams[streamId].sessionChunkType,\n        senderPeerId: senderPeerId\n      }, null), void self._trigger(\"incomingDataStream\", chunk, transferId, senderPeerId, {\n        chunkSize: chunkSize,\n        chunkType: chunkType,\n        isPrivate: self._dataStreams[streamId].sessionChunkType.isPrivate,\n        isStringStream: \"string\" === self._dataStreams[streamId].sessionChunkType,\n        senderPeerId: senderPeerId\n      }, !1);\n      if (\"main\" === channelProp && (transferId = self._dataChannels[peerId].main.transferId), self._dataTransfers[transferId].senderPeerId && (senderPeerId = self._dataTransfers[transferId].senderPeerId), self._handleDataTransferTimeoutForPeer(transferId, peerId, !1), self._dataTransfers[transferId].chunkType = chunkType, self._dataTransfers[transferId].sessions[peerId].receivedSize += chunkSize, self._dataTransfers[transferId].chunks[self._dataTransfers[transferId].sessions[peerId].ackN] = chunk, self._dataTransfers[transferId].sessions[peerId].receivedSize >= self._dataTransfers[transferId].size) return log.log([peerId, \"RTCDataChannel\", channelProp, \"Data transfer has been completed. Computed size ->\"], self._dataTransfers[transferId].sessions[peerId].receivedSize), self._sendMessageToDataChannel(peerId, {\n        type: self._DC_PROTOCOL_TYPE.ACK,\n        sender: self._user.sid,\n        ackN: self._dataTransfers[transferId].sessions[peerId].ackN + 1\n      }, channelProp), self._trigger(\"incomingData\", self._getTransferData(transferId), transferId, senderPeerId, self._getTransferInfo(transferId, peerId, !1, !1, !1), null), void self._trigger(\"dataTransferState\", self.DATA_TRANSFER_STATE.DOWNLOAD_COMPLETED, transferId, senderPeerId, self._getTransferInfo(transferId, peerId, !0, !1, !1), null);\n      self._dataTransfers[transferId].sessions[peerId].ackN += 1, self._sendMessageToDataChannel(peerId, {\n        type: self._DC_PROTOCOL_TYPE.ACK,\n        sender: self._user.sid,\n        ackN: self._dataTransfers[transferId].sessions[peerId].ackN\n      }, channelProp), self._handleDataTransferTimeoutForPeer(transferId, peerId, !0), self._trigger(\"dataTransferState\", self.DATA_TRANSFER_STATE.DOWNLOADING, transferId, senderPeerId, self._getTransferInfo(transferId, peerId, !0, !1, !1), null);\n    }\n  }, Skylink.prototype._onIceCandidate = function (targetMid, candidate) {\n    var self = this,\n        pc = self._peerConnections[targetMid];\n    if (!pc) return void log.warn([targetMid, \"RTCIceCandidate\", null, \"Ignoring of ICE candidate event as Peer connection does not exists ->\"], candidate);\n\n    if (candidate.candidate) {\n      pc.gathering || (log.log([targetMid, \"RTCIceCandidate\", null, \"ICE gathering has started.\"]), pc.gathering = !0, pc.gathered = !1, self._handleIceGatheringStats(\"gathering\", targetMid, !1), self._trigger(\"candidateGenerationState\", self.CANDIDATE_GENERATION_STATE.GATHERING, targetMid));\n      var candidateType = candidate.candidate.split(\" \")[7];\n      if (log.debug([targetMid, \"RTCIceCandidate\", candidateType, \"Generated ICE candidate ->\"], candidate), \"endOfCandidates\" === candidateType || !(self._peerConnections[targetMid] && self._peerConnections[targetMid].localDescription && self._peerConnections[targetMid].localDescription.sdp && self._peerConnections[targetMid].localDescription.sdp.indexOf(\"\\r\\na=mid:\" + candidate.sdpMid + \"\\r\\n\") > -1)) return log.warn([targetMid, \"RTCIceCandidate\", candidateType, \"Dropping of sending ICE candidate end-of-candidates signal or unused ICE candidates to prevent errors ->\"], candidate), void self._handleIceCandidateStats(\"dropped\", targetMid, null, candidate);\n\n      if (self._initOptions.filterCandidatesType[candidateType]) {\n        if (!self._hasMCU || !self._initOptions.forceTURN) return log.warn([targetMid, \"RTCIceCandidate\", candidateType, \"Dropping of sending ICE candidate as it matches ICE candidate filtering flag ->\"], candidate), void self._handleIceCandidateStats(\"dropped\", targetMid, null, candidate);\n        log.warn([targetMid, \"RTCIceCandidate\", candidateType, \"Not dropping of sending ICE candidate as TURN connections are enforced as MCU is present (and act as a TURN itself) so filtering of ICE candidate flags are not honoured ->\"], candidate);\n      }\n\n      if (self._gatheredCandidates[targetMid] || (self._gatheredCandidates[targetMid] = {\n        sending: {\n          host: [],\n          srflx: [],\n          relay: []\n        },\n        receiving: {\n          host: [],\n          srflx: [],\n          relay: []\n        }\n      }), self._gatheredCandidates[targetMid].sending[candidateType].push({\n        sdpMid: candidate.sdpMid,\n        sdpMLineIndex: candidate.sdpMLineIndex,\n        candidate: candidate.candidate\n      }), !self._initOptions.enableIceTrickle) return log.warn([targetMid, \"RTCIceCandidate\", candidateType, \"Dropping of sending ICE candidate as trickle ICE is disabled ->\"], candidate), void self._handleIceCandidateStats(\"non_trickle\", targetMid, null, candidate);\n      log.debug([targetMid, \"RTCIceCandidate\", candidateType, \"Sending ICE candidate ->\"], candidate), self._sendChannelMessage({\n        type: self._SIG_MESSAGE_TYPE.CANDIDATE,\n        label: candidate.sdpMLineIndex,\n        id: candidate.sdpMid,\n        candidate: candidate.candidate,\n        mid: self._user.sid,\n        target: targetMid,\n        rid: self._room.id\n      }), self._handleIceCandidateStats(\"received\", targetMid, null, candidate);\n    } else {\n      if (log.log([targetMid, \"RTCIceCandidate\", null, \"ICE gathering has completed.\"]), pc.gathered) return;\n\n      if (pc.gathering = !1, pc.gathered = !0, self._handleIceGatheringStats(\"complete\", targetMid, !1), self._trigger(\"candidateGenerationState\", self.CANDIDATE_GENERATION_STATE.COMPLETED, targetMid), self._initOptions.enableIceTrickle) {\n        if (self._gatheredCandidates[targetMid]) {\n          var sendEndOfCandidates = function sendEndOfCandidates() {\n            self._gatheredCandidates[targetMid] && self._gatheredCandidates[targetMid].sending && self._sendChannelMessage({\n              type: self._SIG_MESSAGE_TYPE.END_OF_CANDIDATES,\n              noOfExpectedCandidates: self._gatheredCandidates[targetMid].sending.srflx.length + self._gatheredCandidates[targetMid].sending.host.length + self._gatheredCandidates[targetMid].sending.relay.length,\n              mid: self._user.sid,\n              target: targetMid,\n              rid: self._room.id\n            });\n          };\n\n          setTimeout(sendEndOfCandidates, 6e3);\n        }\n      } else {\n        var sessionDescription = self._peerConnections[targetMid].localDescription;\n        if (!(sessionDescription && sessionDescription.type && sessionDescription.sdp)) return void log.warn([targetMid, \"RTCSessionDescription\", null, \"Not sending any session description after ICE gathering completed as it is not present.\"]);\n\n        self._sendChannelMessage({\n          type: sessionDescription.type,\n          sdp: self._renderSDPOutput(targetMid, sessionDescription),\n          mid: self._user.sid,\n          userInfo: self._getUserInfo(targetMid),\n          target: targetMid,\n          rid: self._room.id\n        });\n      }\n    }\n  }, Skylink.prototype._addIceCandidateToQueue = function (targetMid, canId, candidate) {\n    var candidateType = candidate.candidate.split(\" \")[7];\n    log.debug([targetMid, \"RTCIceCandidate\", canId + \":\" + candidateType, \"Buffering ICE candidate.\"]), this._handleIceCandidateStats(\"buffered\", targetMid, canId, candidate), this._trigger(\"candidateProcessingState\", this.CANDIDATE_PROCESSING_STATE.BUFFERED, targetMid, canId, candidateType, {\n      candidate: candidate.candidate,\n      sdpMid: candidate.sdpMid,\n      sdpMLineIndex: candidate.sdpMLineIndex\n    }, null), this._peerCandidatesQueue[targetMid] = this._peerCandidatesQueue[targetMid] || [], this._peerCandidatesQueue[targetMid].push([canId, candidate]);\n  }, Skylink.prototype._addIceCandidateFromQueue = function (targetMid) {\n    this._peerCandidatesQueue[targetMid] = this._peerCandidatesQueue[targetMid] || [];\n\n    for (var i = 0; i < this._peerCandidatesQueue[targetMid].length; i++) {\n      var canArray = this._peerCandidatesQueue[targetMid][i];\n\n      if (canArray) {\n        var candidateType = canArray[1].candidate.split(\" \")[7];\n        log.debug([targetMid, \"RTCIceCandidate\", canArray[0] + \":\" + candidateType, \"Adding buffered ICE candidate.\"]), this._addIceCandidate(targetMid, canArray[0], canArray[1]);\n      } else if (this._peerConnections[targetMid] && this._peerConnections[targetMid].signalingState !== this.PEER_CONNECTION_STATE.CLOSED && AdapterJS && !this._isLowerThanVersion(AdapterJS.VERSION, \"0.14.0\")) try {\n        this._peerConnections[targetMid].addIceCandidate(null), log.debug([targetMid, \"RTCPeerConnection\", null, \"Signaling of end-of-candidates remote ICE gathering.\"]);\n      } catch (error) {\n        log.error([targetMid, \"RTCPeerConnection\", null, \"Failed signaling of end-of-candidates remote ICE gathering.\"]);\n      }\n    }\n\n    delete this._peerCandidatesQueue[targetMid], this._signalingEndOfCandidates(targetMid);\n  }, Skylink.prototype._addIceCandidate = function (targetMid, canId, candidate) {\n    var self = this,\n        candidateType = candidate.candidate.split(\" \")[7],\n        onSuccessCbFn = function onSuccessCbFn() {\n      log.log([targetMid, \"RTCIceCandidate\", canId + \":\" + candidateType, \"Added ICE candidate successfully.\"]), self._handleIceCandidateStats(\"process_success\", targetMid, canId, candidate), self._trigger(\"candidateProcessingState\", self.CANDIDATE_PROCESSING_STATE.PROCESS_SUCCESS, targetMid, canId, candidateType, {\n        candidate: candidate.candidate,\n        sdpMid: candidate.sdpMid,\n        sdpMLineIndex: candidate.sdpMLineIndex\n      }, null);\n    },\n        onErrorCbFn = function onErrorCbFn(error) {\n      log.error([targetMid, \"RTCIceCandidate\", canId + \":\" + candidateType, \"Failed adding ICE candidate ->\"], error), self._handleIceCandidateStats(\"process_failed\", targetMid, canId, candidate, error), self._trigger(\"candidateProcessingState\", self.CANDIDATE_PROCESSING_STATE.PROCESS_ERROR, targetMid, canId, candidateType, {\n        candidate: candidate.candidate,\n        sdpMid: candidate.sdpMid,\n        sdpMLineIndex: candidate.sdpMLineIndex\n      }, error);\n    };\n\n    if (log.debug([targetMid, \"RTCIceCandidate\", canId + \":\" + candidateType, \"Adding ICE candidate.\"]), self._handleIceCandidateStats(\"processing\", targetMid, canId, candidate), self._trigger(\"candidateProcessingState\", self.CANDIDATE_PROCESSING_STATE.PROCESSING, targetMid, canId, candidateType, {\n      candidate: candidate.candidate,\n      sdpMid: candidate.sdpMid,\n      sdpMLineIndex: candidate.sdpMLineIndex\n    }, null), !(self._peerConnections[targetMid] && self._peerConnections[targetMid].signalingState !== self.PEER_CONNECTION_STATE.CLOSED && self._peerConnections[targetMid].remoteDescription && self._peerConnections[targetMid].remoteDescription.sdp && self._peerConnections[targetMid].remoteDescription.sdp.indexOf(\"\\r\\na=mid:\" + candidate.sdpMid + \"\\r\\n\") > -1)) return log.warn([targetMid, \"RTCIceCandidate\", canId + \":\" + candidateType, \"Dropping ICE candidate as Peer connection does not exists or is closed\"]), self._handleIceCandidateStats(\"process_failed\", targetMid, canId, candidate, \"Peer connection does not exist\"), void self._trigger(\"candidateProcessingState\", self.CANDIDATE_PROCESSING_STATE.DROPPED, targetMid, canId, candidateType, {\n      candidate: candidate.candidate,\n      sdpMid: candidate.sdpMid,\n      sdpMLineIndex: candidate.sdpMLineIndex\n    }, new Error(\"Failed processing ICE candidate as Peer connection does not exists or is closed.\"));\n\n    try {\n      self._peerConnections[targetMid].addIceCandidate(candidate, onSuccessCbFn, onErrorCbFn);\n    } catch (error) {\n      onErrorCbFn(error);\n    }\n  }, Skylink.prototype._setIceServers = function (passedIceServers) {\n    var self = this,\n        iceServerName = null,\n        iceServerProtocol = \"stun\",\n        iceServerPorts = {\n      udp: [3478, 19302, 19303, 19304],\n      tcp: [80, 443],\n      both: [19305, 19306, 19307, 19308]\n    },\n        iceServers = [{\n      urls: []\n    }, {\n      urls: []\n    }];\n    return passedIceServers.forEach(function (server) {\n      if (0 === server.url.indexOf(\"stun:\")) server.url.indexOf(\"temasys\") > 0 ? iceServerName = (server.url.split(\":\")[1] || \"\").split(\"?\")[0] || null : iceServers[0].urls.push(server.url);else if (0 === server.url.indexOf(\"turn:\") && server.url.indexOf(\"@\") > 0 && server.credential && !iceServers[1].username && !iceServers[1].credential) {\n        var parts = server.url.split(\":\"),\n            urlParts = (parts[1] || \"\").split(\"@\");\n        iceServerName = (urlParts[1] || \"\").split(\"?\")[0], iceServers[1].username = urlParts[0], iceServers[1].credential = server.credential, iceServerProtocol = \"turn\";\n      }\n    }), self._initOptions.iceServer ? iceServers = [{\n      urls: self._initOptions.iceServer.urls,\n      username: iceServers[1].username || null,\n      credential: iceServers[1].credential || null\n    }] : (iceServerName = iceServerName || \"turn.temasys.io\", \"turn\" !== iceServerProtocol || self._initOptions.enableTURNServer || self._initOptions.forceTURNSSL ? \"edge\" === AdapterJS.webrtcDetectedBrowser ? (iceServerPorts.udp = [3478], iceServerPorts.tcp = [], iceServerPorts.both = [], iceServerProtocol = \"turn\") : self._initOptions.forceTURNSSL ? \"firefox\" === AdapterJS.webrtcDetectedBrowser && AdapterJS.webrtcDetectedVersion < 53 ? (iceServerPorts.udp = [], iceServerPorts.tcp = [443], iceServerPorts.both = [], iceServerProtocol = \"turn\") : (iceServerPorts.udp = [], iceServerProtocol = \"turns\") : \"firefox\" === AdapterJS.webrtcDetectedBrowser && (iceServerPorts.udp = [3478], iceServerPorts.tcp = [443, 80]) : iceServerProtocol = \"stun\", self._initOptions.TURNServerTransport !== self.TURN_TRANSPORT.UDP || self._initOptions.forceTURNSSL ? self._initOptions.TURNServerTransport === self.TURN_TRANSPORT.TCP ? (iceServerPorts.tcp = iceServerPorts.tcp.concat(iceServerPorts.both), iceServerPorts.udp = [], iceServerPorts.both = []) : self._initOptions.TURNServerTransport === self.TURN_TRANSPORT.NONE && (iceServerPorts.tcp = [], iceServerPorts.udp = []) : (iceServerPorts.udp = iceServerPorts.udp.concat(iceServerPorts.both), iceServerPorts.tcp = [], iceServerPorts.both = []), \"stun\" === iceServerProtocol && (iceServerPorts.tcp = []), \"stun\" !== iceServerProtocol || self._initOptions.enableSTUNServer ? (iceServerPorts.tcp.forEach(function (tcpPort) {\n      iceServers[1].urls.push(iceServerProtocol + \":\" + iceServerName + \":\" + tcpPort + \"?transport=tcp\");\n    }), iceServerPorts.udp.forEach(function (udpPort) {\n      iceServers[1].urls.push(iceServerProtocol + \":\" + iceServerName + \":\" + udpPort + \"?transport=udp\");\n    }), iceServerPorts.both.forEach(function (bothPort) {\n      iceServers[1].urls.push(iceServerProtocol + \":\" + iceServerName + \":\" + bothPort);\n    }), self._initOptions.usePublicSTUN || iceServers.splice(0, 1)) : iceServers = []), log.log(\"Output iceServers configuration:\", iceServers), {\n      iceServers: iceServers\n    };\n  }, Skylink.prototype.refreshConnection = function (targetPeerId, iceRestart, options, callback) {\n    var self = this,\n        listOfPeers = Object.keys(self._peerConnections),\n        doIceRestart = !1,\n        bwOptions = {};\n    Array.isArray(targetPeerId) ? listOfPeers = targetPeerId : \"string\" == typeof targetPeerId ? listOfPeers = [targetPeerId] : \"boolean\" == typeof targetPeerId ? doIceRestart = targetPeerId : targetPeerId && \"object\" == typeof targetPeerId ? bwOptions = targetPeerId : \"function\" == typeof targetPeerId && (callback = targetPeerId), \"boolean\" == typeof iceRestart ? doIceRestart = iceRestart : iceRestart && \"object\" == typeof iceRestart ? bwOptions = iceRestart : \"function\" == typeof iceRestart && (callback = iceRestart), options && \"object\" == typeof options ? bwOptions = options : \"function\" == typeof options && (callback = options);\n\n    var emitErrorForPeersFn = function emitErrorForPeersFn(error) {\n      if (log.error(error), \"function\" == typeof callback) {\n        var listOfPeerErrors = {};\n        if (0 === listOfPeers.length) listOfPeerErrors.self = new Error(error);else for (var i = 0; i < listOfPeers.length; i++) {\n          listOfPeerErrors[listOfPeers[i]] = new Error(error);\n        }\n        callback({\n          refreshErrors: listOfPeerRestartErrors,\n          listOfPeers: listOfPeers\n        }, null);\n      }\n    };\n\n    return 0 !== listOfPeers.length || self._hasMCU && !self._initOptions.mcuUseRenegoRestart ? \"edge\" === AdapterJS.webrtcDetectedBrowser ? void emitErrorForPeersFn(\"Edge browser currently does not support renegotiation.\") : void self._throttle(function (runFn) {\n      if (!runFn && self._hasMCU && !self._initOptions.mcuUseRenegoRestart) return void (self._initOptions.throttlingShouldThrowError && emitErrorForPeersFn(\"Unable to run as throttle interval has not reached (\" + self._initOptions.throttleIntervals.refreshConnection + \"ms).\"));\n\n      self._refreshPeerConnection(listOfPeers, doIceRestart, bwOptions, callback);\n    }, \"refreshConnection\", self._initOptions.throttleIntervals.refreshConnection) : void emitErrorForPeersFn(\"There is currently no peer connections to restart\");\n  }, Skylink.prototype._refreshPeerConnection = function (listOfPeers, doIceRestart, bwOptions, callback) {\n    var self = this,\n        listOfPeerRestarts = [],\n        error = \"\",\n        listOfPeerRestartErrors = {},\n        listOfPeersSettings = {},\n        refreshSinglePeerCallback = function refreshSinglePeerCallback(peerId) {\n      return function (error) {\n        -1 === listOfPeerRestarts.indexOf(peerId) && (error ? (log.error([peerId, \"RTCPeerConnection\", null, \"Failed restarting for peer\"], error), listOfPeerRestartErrors[peerId] = error) : listOfPeersSettings[peerId] = {\n          iceRestart: !self._hasMCU && self._peerInformations[peerId] && self._peerInformations[peerId].config && self._peerInformations[peerId].config.enableIceRestart && self._enableIceRestart && doIceRestart,\n          customSettings: self.getPeersCustomSettings()[peerId] || {}\n        }, listOfPeerRestarts.push(peerId)), listOfPeerRestarts.length === listOfPeers.length && \"function\" == typeof callback && (log.log([null, \"PeerConnection\", null, \"Invoked all peers to restart. Firing callback\"]), Object.keys(listOfPeerRestartErrors).length > 0 ? callback({\n          refreshErrors: listOfPeerRestartErrors,\n          listOfPeers: listOfPeers,\n          refreshSettings: listOfPeersSettings\n        }, null) : callback(null, {\n          listOfPeers: listOfPeers,\n          refreshSettings: listOfPeersSettings\n        }));\n      };\n    },\n        refreshSinglePeer = function refreshSinglePeer(peerId, peerCallback) {\n      if (!self._peerConnections[peerId]) return error = \"There is currently no existing peer connection made with the peer. Unable to restart connection\", log.error([peerId, null, null, error]), void peerCallback(error);\n      log.log([peerId, \"PeerConnection\", null, \"Restarting peer connection\"]), self._restartPeerConnection(peerId, doIceRestart, bwOptions, peerCallback);\n    };\n\n    if (self._hasMCU) self._restartMCUConnection(callback, doIceRestart, bwOptions);else {\n      var i;\n\n      for (i = 0; i < listOfPeers.length; i++) {\n        var peerId = listOfPeers[i];\n        Object.keys(self._peerConnections).indexOf(peerId) > -1 ? refreshSinglePeer(peerId, refreshSinglePeerCallback(peerId)) : (error = \"Peer connection with peer does not exists. Unable to restart\", log.error([peerId, \"PeerConnection\", null, error]), refreshSinglePeerCallback(peerId)(error));\n      }\n    }\n  }, Skylink.prototype.getConnectionStatus = function (targetPeerId, callback) {\n    var self = this,\n        listOfPeers = Object.keys(self._peerConnections),\n        listOfPeerStats = {},\n        listOfPeerErrors = {};\n    if (Array.isArray(targetPeerId) ? listOfPeers = targetPeerId : \"string\" == typeof targetPeerId && targetPeerId ? listOfPeers = [targetPeerId] : \"function\" == typeof targetPeerId && (callback = targetPeerId, targetPeerId = void 0), 0 === listOfPeers.length) return listOfPeerErrors.self = new Error(\"There is currently no peer connections to retrieve connection status\"), log.error([null, \"RTCStatsReport\", null, \"Retrieving request failure ->\"], listOfPeerErrors.self), void (\"function\" == typeof callback && callback({\n      listOfPeers: listOfPeers,\n      retrievalErrors: listOfPeerErrors,\n      connectionStats: listOfPeerStats\n    }, null));\n    \"edge\" === AdapterJS.webrtcDetectedBrowser && log.warn(\"Edge browser does not have well support for stats.\");\n\n    for (var completedTaskCounter = [], checkCompletedFn = function checkCompletedFn(peerId) {\n      -1 === completedTaskCounter.indexOf(peerId) && completedTaskCounter.push(peerId), completedTaskCounter.length === listOfPeers.length && \"function\" == typeof callback && (Object.keys(listOfPeerErrors).length > 0 ? callback({\n        listOfPeers: listOfPeers,\n        retrievalErrors: listOfPeerErrors,\n        connectionStats: listOfPeerStats\n      }, null) : callback(null, {\n        listOfPeers: listOfPeers,\n        connectionStats: listOfPeerStats\n      }));\n    }, statsFn = function statsFn(peerId) {\n      var retrieveFn = function retrieveFn(firstRetrieval, nextCb) {\n        return function (error, result) {\n          if (error) return log.error([peerId, \"RTCStatsReport\", null, \"Retrieval failure ->\"], error), listOfPeerErrors[peerId] = error, self._trigger(\"getConnectionStatusStateChange\", self.GET_CONNECTION_STATUS_STATE.RETRIEVE_ERROR, peerId, null, error), checkCompletedFn(peerId), void (firstRetrieval && delete self._peerStats[peerId]);\n          firstRetrieval ? nextCb() : (listOfPeerStats[peerId] = result, self._trigger(\"getConnectionStatusStateChange\", self.GET_CONNECTION_STATUS_STATE.RETRIEVE_SUCCESS, peerId, listOfPeerStats[peerId], null), checkCompletedFn(peerId));\n        };\n      };\n\n      if (!self._peerStats[peerId]) return self._peerStats[peerId] = {}, log.debug([peerId, \"RTCStatsReport\", null, \"Retrieving first report to tabulate results\"]), void self._retrieveStats(peerId, retrieveFn(!0, function () {\n        self._retrieveStats(peerId, retrieveFn());\n      }), !0);\n\n      self._retrieveStats(peerId, retrieveFn());\n    }, i = 0; i < listOfPeers.length; i++) {\n      var peerId = listOfPeers[i];\n      self._trigger(\"getConnectionStatusStateChange\", self.GET_CONNECTION_STATUS_STATE.RETRIEVING, peerId, null, null), self._peerConnections.hasOwnProperty(peerId) && self._peerConnections[peerId] ? statsFn(peerId) : (listOfPeerErrors[peerId] = new Error(\"The peer connection object does not exists\"), log.error([peerId, \"RTCStatsReport\", null, \"Retrieval failure ->\"], listOfPeerErrors[peerId]), self._trigger(\"getConnectionStatusStateChange\", self.GET_CONNECTION_STATUS_STATE.RETRIEVE_ERROR, peerId, null, listOfPeerErrors[peerId]), checkCompletedFn(peerId));\n    }\n  }, Skylink.prototype._retrieveStats = function (peerId, callback, beSilentOnLogs, isAutoBwStats) {\n    var self = this,\n        pc = self._peerConnections[peerId],\n        output = {\n      raw: {},\n      connection: {},\n      audio: {\n        sending: {},\n        receiving: {}\n      },\n      video: {\n        sending: {},\n        receiving: {}\n      },\n      selectedCandidate: {\n        local: {},\n        remote: {},\n        consentResponses: {},\n        consentRequests: {},\n        responses: {},\n        requests: {}\n      },\n      certificate: {}\n    };\n    if (!self._peerStats[peerId] && !isAutoBwStats) return callback(new Error(\"No stats initiated yet.\"));\n    if (!pc) return callback(new Error(\"Peer connection is not initialised\"));\n    \"edge\" !== AdapterJS.webrtcDetectedBrowser && \"AppleWebKit\" !== AdapterJS.webrtcDetectedType || log.warn(\"Current connection stats may not be complete as it is in beta\"), output.connection.iceConnectionState = pc.iceConnectionState, output.connection.iceGatheringState = pc.iceGatheringState, output.connection.signalingState = pc.signalingState, output.connection.remoteDescription = {\n      type: pc.remoteDescription && pc.remoteDescription.type || \"\",\n      sdp: pc.remoteDescription && pc.remoteDescription.sdp || \"\"\n    }, output.connection.localDescription = {\n      type: pc.localDescription && pc.localDescription.type || \"\",\n      sdp: pc.localDescription && pc.localDescription.sdp || \"\"\n    }, output.connection.candidates = {\n      sending: self._getSDPICECandidates(peerId, pc.localDescription, beSilentOnLogs),\n      receiving: self._getSDPICECandidates(peerId, pc.remoteDescription, beSilentOnLogs)\n    }, output.connection.dataChannels = {}, output.connection.constraints = self._peerConnStatus[peerId] ? self._peerConnStatus[peerId].constraints : null, output.connection.optional = self._peerConnStatus[peerId] ? self._peerConnStatus[peerId].optional : null, output.connection.sdpConstraints = self._peerConnStatus[peerId] ? self._peerConnStatus[peerId].sdpConstraints : null, output.audio.sending.codec = self._getSDPSelectedCodec(peerId, pc.remoteDescription, \"audio\", beSilentOnLogs), output.video.sending.codec = self._getSDPSelectedCodec(peerId, pc.remoteDescription, \"video\", beSilentOnLogs), output.audio.receiving.codec = self._getSDPSelectedCodec(peerId, pc.localDescription, \"audio\", beSilentOnLogs), output.video.receiving.codec = self._getSDPSelectedCodec(peerId, pc.localDescription, \"video\", beSilentOnLogs), output.certificate.local = self._getSDPFingerprint(peerId, pc.localDescription, beSilentOnLogs), output.certificate.remote = self._getSDPFingerprint(peerId, pc.remoteDescription, beSilentOnLogs);\n\n    var inboundSSRCs = self._getSDPMediaSSRC(peerId, pc.remoteDescription, beSilentOnLogs);\n\n    output.audio.receiving.ssrc = inboundSSRCs.audio, output.video.receiving.ssrc = inboundSSRCs.video;\n\n    var outboundSSRCs = self._getSDPMediaSSRC(peerId, pc.localDescription, beSilentOnLogs);\n\n    output.audio.sending.ssrc = outboundSSRCs.audio, output.video.sending.ssrc = outboundSSRCs.video, Object.keys(self._dataChannels[peerId] || {}).forEach(function (prop) {\n      var channel = self._dataChannels[peerId][prop];\n      output.connection.dataChannels[channel.channel.label] = {\n        label: channel.channel.label,\n        readyState: channel.channel.readyState,\n        channelType: self.DATA_CHANNEL_TYPE[\"main\" === prop ? \"MESSAGING\" : \"DATA\"],\n        currentTransferId: channel.transferId || null,\n        currentStreamId: channel.streamId || null\n      };\n    });\n\n    var certificateFn = function certificateFn(item, prop) {\n      if (0 === prop.indexOf(\"RTCCertificate_\")) item.fingerprint === output.certificate.local.fingerprint ? (output.certificate.local.derBase64 = item.base64Certificate, output.certificate.local.fingerprintAlgorithm = item.fingerprintAlgorithm) : item.fingerprint === output.certificate.remote.fingerprint && (output.certificate.remote.derBase64 = item.base64Certificate, output.certificate.remote.fingerprintAlgorithm = item.fingerprintAlgorithm);else if (0 === prop.indexOf(\"ssrc_\") && item.transportId) {\n        var pairItem = output.raw[item.transportId] || {};\n        output.certificate.srtpCipher = pairItem.srtpCipher, output.certificate.dtlsCipher = pairItem.dtlsCipher;\n        var localCertItem = output.raw[pairItem.localCertificateId || \"\"] || {};\n        output.certificate.local.fingerprint = localCertItem.googFingerprint, output.certificate.local.fingerprintAlgorithm = localCertItem.googFingerprintAlgorithm, output.certificate.local.derBase64 = localCertItem.googDerBase64;\n        var remoteCertItem = output.raw[pairItem.remoteCertificateId || \"\"] || {};\n        output.certificate.remote.fingerprint = remoteCertItem.googFingerprint, output.certificate.remote.fingerprintAlgorithm = remoteCertItem.googFingerprintAlgorithm, output.certificate.remote.derBase64 = remoteCertItem.googDerBase64;\n      }\n    },\n        candidatePairFn = function candidatePairFn(item, prop) {\n      if (0 === prop.indexOf(\"RTCIceCandidatePair_\")) {\n        if (\"succeeded\" !== item.state || output.selectedCandidate.nominated || item.prioirty < (output.selectedCandidate.priority || 0)) return;\n\n        for (var prevStats = isAutoBwStats ? self._peerBandwidth[peerId][prop] : self._peerStats[peerId][prop], sending = pc.localDescription && pc.localDescription.sdp && pc.localDescription.sdp.match(/a=candidate:.*\\r\\n/gi) || [], receiving = pc.remoteDescription && pc.remoteDescription && pc.remoteDescription.sdp.match(/a=candidate:.*\\r\\n/gi) || [], computePrioirtyFn = function computePrioirtyFn(controller, controlled) {\n          return Math.pow(2, 32) * Math.min(controller, controlled) + 2 * Math.max(controller, controlled) + (controller > controlled ? 1 : 0);\n        }, computeCanTypeFn = function computeCanTypeFn(type) {\n          return \"relay\" === type ? \"relayed\" : \"host\" === type ? \"local\" : \"srflx\" === type ? \"serverreflexive\" : type;\n        }, s = 0; s < sending.length; s++) {\n          for (var sendCanParts = sending[s].split(\" \"), r = 0; r < receiving.length; r++) {\n            var recvCanParts = receiving[r].split(\" \");\n\n            if ((item.writable ? computePrioirtyFn(parseInt(sendCanParts[3], 10), parseInt(recvCanParts[3], 10)) : computePrioirtyFn(parseInt(recvCanParts[3], 10), parseInt(sendCanParts[3], 10))) === item.priority) {\n              output.selectedCandidate.local.ipAddress = sendCanParts[4], output.selectedCandidate.local.candidateType = sendCanParts[7], output.selectedCandidate.local.portNumber = parseInt(sendCanParts[5], 10), output.selectedCandidate.local.transport = sendCanParts[2], output.selectedCandidate.local.priority = parseInt(sendCanParts[3], 10), output.selectedCandidate.local.candidateType = computeCanTypeFn(sendCanParts[7]), output.selectedCandidate.remote.ipAddress = recvCanParts[4], output.selectedCandidate.remote.candidateType = recvCanParts[7], output.selectedCandidate.remote.portNumber = parseInt(recvCanParts[5], 10), output.selectedCandidate.remote.transport = recvCanParts[2], output.selectedCandidate.remote.priority = parseInt(recvCanParts[3], 10), output.selectedCandidate.remote.candidateType = computeCanTypeFn(recvCanParts[7]);\n              break;\n            }\n          }\n        }\n\n        output.selectedCandidate.writable = item.writable, output.selectedCandidate.readable = item.readable, output.selectedCandidate.priority = item.priority, output.selectedCandidate.nominated = item.nominated;\n        var rtt = parseInt(item.rtt || \"0\", 10);\n        output.selectedCandidate.totalRtt = rtt, output.selectedCandidate.rtt = self._parseConnectionStats(prevStats, item, \"rtt\");\n        var consentResponsesReceived = parseInt(item.consentResponsesReceived || \"0\", 10);\n        output.selectedCandidate.consentResponses.totalReceived = consentResponsesReceived, output.selectedCandidate.consentResponses.received = self._parseConnectionStats(prevStats, item, \"consentResponsesReceived\");\n        var consentResponsesSent = parseInt(item.consentResponsesSent || \"0\", 10);\n        output.selectedCandidate.consentResponses.totalSent = consentResponsesSent, output.selectedCandidate.consentResponses.sent = self._parseConnectionStats(prevStats, item, \"consentResponsesSent\");\n        var responsesReceived = parseInt(item.responsesReceived || \"0\", 10);\n        output.selectedCandidate.responses.totalReceived = responsesReceived, output.selectedCandidate.responses.received = self._parseConnectionStats(prevStats, item, \"responsesReceived\");\n        var responsesSent = parseInt(item.responsesSent || \"0\", 10);\n        output.selectedCandidate.responses.totalSent = responsesSent, output.selectedCandidate.responses.sent = self._parseConnectionStats(prevStats, item, \"responsesSent\");\n      } else if (\"googCandidatePair\" === item.type) {\n        var prevStats = isAutoBwStats ? self._peerBandwidth[peerId][prop] : self._peerStats[peerId][prop];\n        output.selectedCandidate.writable = \"true\" === item.googWritable, output.selectedCandidate.readable = \"true\" === item.googReadable;\n        var rtt = parseInt(item.googRtt || \"0\", 10);\n\n        if (output.selectedCandidate.totalRtt = rtt, output.selectedCandidate.rtt = self._parseConnectionStats(prevStats, item, \"rtt\"), item.consentResponsesReceived) {\n          var consentResponsesReceived = parseInt(item.consentResponsesReceived || \"0\", 10);\n          output.selectedCandidate.consentResponses.totalReceived = consentResponsesReceived, output.selectedCandidate.consentResponses.received = self._parseConnectionStats(prevStats, item, \"consentResponsesReceived\");\n        }\n\n        if (item.consentResponsesSent) {\n          var consentResponsesSent = parseInt(item.consentResponsesSent || \"0\", 10);\n          output.selectedCandidate.consentResponses.totalSent = consentResponsesSent, output.selectedCandidate.consentResponses.sent = self._parseConnectionStats(prevStats, item, \"consentResponsesSent\");\n        }\n\n        if (item.responsesReceived) {\n          var responsesReceived = parseInt(item.responsesReceived || \"0\", 10);\n          output.selectedCandidate.responses.totalReceived = responsesReceived, output.selectedCandidate.responses.received = self._parseConnectionStats(prevStats, item, \"responsesReceived\");\n        }\n\n        if (item.responsesSent) {\n          var responsesSent = parseInt(item.responsesSent || \"0\", 10);\n          output.selectedCandidate.responses.totalSent = responsesSent, output.selectedCandidate.responses.sent = self._parseConnectionStats(prevStats, item, \"responsesSent\");\n        }\n\n        var localCanItem = output.raw[item.localCandidateId || \"\"] || {};\n        output.selectedCandidate.local.ipAddress = localCanItem.ipAddress, output.selectedCandidate.local.portNumber = parseInt(localCanItem.portNumber, 10), output.selectedCandidate.local.priority = parseInt(localCanItem.priority, 10), output.selectedCandidate.local.networkType = localCanItem.networkType, output.selectedCandidate.local.transport = localCanItem.transport, output.selectedCandidate.local.candidateType = localCanItem.candidateType;\n        var remoteCanItem = output.raw[item.remoteCandidateId || \"\"] || {};\n        output.selectedCandidate.remote.ipAddress = remoteCanItem.ipAddress, output.selectedCandidate.remote.portNumber = parseInt(remoteCanItem.portNumber, 10), output.selectedCandidate.remote.priority = parseInt(remoteCanItem.priority, 10), output.selectedCandidate.remote.transport = remoteCanItem.transport, output.selectedCandidate.remote.candidateType = remoteCanItem.candidateType;\n      } else if (\"candidatepair\" === item.type && \"succeeded\" === item.state && item.nominated) {\n        output.selectedCandidate.writable = item.writable, output.selectedCandidate.readable = item.readable;\n        var localCanItem = output.raw[item.localCandidateId || \"\"];\n        output.selectedCandidate.local.ipAddress = localCanItem.ipAddress, output.selectedCandidate.local.portNumber = localCanItem.portNumber, output.selectedCandidate.local.transport = localCanItem.transport, output.selectedCandidate.local.candidateType = localCanItem.candidateType, output.selectedCandidate.local.turnMediaTransport = localCanItem.mozLocalTransport;\n        var remoteCanItem = output.raw[item.remoteCandidateId || \"\"];\n        output.selectedCandidate.remote.ipAddress = remoteCanItem.ipAddress, output.selectedCandidate.remote.portNumber = remoteCanItem.portNumber, output.selectedCandidate.remote.transport = remoteCanItem.transport, output.selectedCandidate.remote.candidateType = remoteCanItem.candidateType;\n      }\n    },\n        codecsFn = function codecsFn(item, prop) {\n      if (0 === prop.indexOf(\"ssrc_\")) {\n        var direction = prop.indexOf(\"_send\") > 0 ? \"sending\" : \"receiving\";\n        item.codecImplementationName = \"unknown\" === item.codecImplementationName ? null : item.codecImplementationName, output[item.mediaType][direction].codec.implementation = item.codecImplementationName || null, item.googCodecName = \"unknown\" === item.googCodecName ? null : item.googCodecName, output[item.mediaType][direction].codec.name = item.googCodecName || output[item.mediaType][direction].codec.name;\n      }\n    },\n        audioStatsFn = function audioStatsFn(item, prop) {\n      var prevStats = isAutoBwStats ? self._peerBandwidth[peerId][prop] : self._peerStats[peerId][prop];\n\n      if (0 === prop.indexOf(\"RTCInboundRTPAudioStream\")) {\n        if (output.audio.receiving.fractionLost = item.fractionLost, output.audio.receiving.jitter = item.jitter, output.audio.receiving.totalBytes = item.bytesReceived, output.audio.receiving.bytes = self._parseConnectionStats(prevStats, item, \"bytesReceived\"), output.audio.receiving.totalPackets = item.packetsReceived, output.audio.receiving.packets = self._parseConnectionStats(prevStats, item, \"packetsReceived\"), output.audio.receiving.totalPacketsDiscarded = item.packetsDiscarded, output.audio.receiving.packetsDiscarded = self._parseConnectionStats(prevStats, item, \"packetsDiscarded\"), output.audio.receiving.totalPacketsLost = item.packetsLost, output.audio.receiving.packetsLost = self._parseConnectionStats(prevStats, item, \"packetsLost\"), output.audio.receiving.totalNacks = item.nackCount, output.audio.receiving.nacks = self._parseConnectionStats(prevStats, item, \"nackCount\"), \"function\" != typeof pc.getReceivers) return;\n      } else if (0 === prop.indexOf(\"RTCMediaStreamTrack_remote_audio_\")) output.audio.receiving.audioOutputLevel = item.audioLevel;else if (0 === prop.indexOf(\"RTCOutboundRTPAudioStream\")) output.audio.sending.targetBitrate = item.targetBitrate || 0, output.audio.sending.totalBytes = item.bytesSent, output.audio.sending.bytes = self._parseConnectionStats(prevStats, item, \"bytesSent\"), output.audio.sending.totalPackets = item.packetsSent, output.audio.sending.packets = self._parseConnectionStats(prevStats, item, \"packetsSent\"), output.audio.sending.totalNacks = item.nackCount, output.audio.sending.nacks = self._parseConnectionStats(prevStats, item, \"nackCount\");else if (\"edge\" === AdapterJS.webrtcDetectedBrowser && \"inboundrtp\" === item.type && \"audio\" === item.mediaType && item.isRemote) output.audio.receiving.fractionLost = item.fractionLost, output.audio.receiving.jitter = item.jitter, output.audio.receiving.totalBytes = item.bytesReceived, output.audio.receiving.bytes = self._parseConnectionStats(prevStats, item, \"bytesReceived\"), output.audio.receiving.totalPackets = item.packetsReceived, output.audio.receiving.packets = self._parseConnectionStats(prevStats, item, \"packetsReceived\"), output.audio.receiving.totalPacketsLost = item.packetsLost, output.audio.receiving.packetsLost = self._parseConnectionStats(prevStats, item, \"packetsLost\"), output.audio.receiving.totalNacks = item.nackCount, output.audio.receiving.nacks = self._parseConnectionStats(prevStats, item, \"nackCount\");else if (\"edge\" !== AdapterJS.webrtcDetectedBrowser || \"outboundrtp\" !== item.type || \"audio\" !== item.mediaType || item.isRemote) {\n        if (0 === prop.indexOf(\"ssrc_\") && \"audio\" === item.mediaType) {\n          if (prop.indexOf(\"_recv\") > 0) {\n            output.audio.receiving.jitter = parseInt(item.googJitterReceived || \"0\", 10), output.audio.receiving.jitterBufferMs = parseInt(item.googJitterBufferMs || \"0\", 10), output.audio.receiving.currentDelayMs = parseInt(item.googCurrentDelayMs || \"0\", 10);\n            var bytesReceived = parseInt(item.bytesReceived || \"0\", 10);\n            output.audio.receiving.totalBytes = bytesReceived, output.audio.receiving.bytes = self._parseConnectionStats(prevStats, item, \"bytesReceived\");\n            var packetsReceived = parseInt(item.packetsReceived || \"0\", 10);\n            output.audio.receiving.totalPackets = packetsReceived, output.audio.receiving.packets = self._parseConnectionStats(prevStats, item, \"packetsReceived\");\n            var packetsLost = parseInt(item.packetsLost || \"0\", 10);\n            output.audio.receiving.totalPacketsLost = packetsLost, output.audio.receiving.packetsLost = self._parseConnectionStats(prevStats, item, \"packetsLost\");\n          } else {\n            output.audio.sending.rtt = parseInt(item.googRtt || \"0\", 10), output.audio.sending.audioInputLevel = parseInt(item.audioInputLevel || \"0\", 10), output.audio.sending.echoReturnLoss = parseInt(item.googEchoCancellationReturnLoss || \"0\", 10), output.audio.sending.echoReturnLossEnhancement = parseInt(item.googEchoCancellationReturnLossEnhancement || \"0\", 10);\n            var bytesSent = parseInt(item.bytesSent || \"0\", 10);\n            output.audio.sending.totalBytes = bytesSent, output.audio.sending.bytes = self._parseConnectionStats(prevStats, item, \"bytesSent\");\n            var packetsSent = parseInt(item.packetsSent || \"0\", 10);\n            output.audio.sending.totalPackets = packetsSent, output.audio.sending.packets = self._parseConnectionStats(prevStats, item, \"packetsSent\");\n          }\n        } else if (0 === prop.indexOf(\"inbound_rtp_audio\")) output.audio.receiving.jitter = item.jitter || 0, output.audio.receiving.totalBytes = item.bytesReceived, output.audio.receiving.bytes = self._parseConnectionStats(prevStats, item, \"bytesReceived\"), output.audio.receiving.totalPackets = item.packetsReceived, output.audio.receiving.packets = self._parseConnectionStats(prevStats, item, \"packetsReceived\"), output.audio.receiving.totalPacketsLost = item.packetsLost, output.audio.receiving.packetsLost = self._parseConnectionStats(prevStats, item, \"packetsLost\"), output.audio.receiving.totalNacks = item.nackCount, output.audio.receiving.nacks = self._parseConnectionStats(prevStats, item, \"nackCount\");else if (0 === prop.indexOf(\"outbound_rtp_audio\")) {\n          output.audio.sending.totalBytes = item.bytesSent, output.audio.sending.bytes = self._parseConnectionStats(prevStats, item, \"bytesSent\"), output.audio.sending.totalPackets = item.packetsSent, output.audio.sending.packets = self._parseConnectionStats(prevStats, item, \"packetsSent\"), output.audio.sending.totalNacks = item.nackCount, output.audio.sending.nacks = self._parseConnectionStats(prevStats, item, \"nackCount\");\n          var rtcpItem = output.raw[prop.replace(/_rtp_/g, \"_rtcp_\")] || {};\n          output.audio.sending.rtt = rtcpItem.roundTripTime || 0;\n        }\n      } else {\n        output.audio.sending.targetBitrate = item.targetBitrate, output.audio.sending.rtt = item.roundTripTime, output.audio.sending.totalBytes = item.bytesSent, output.audio.sending.bytes = self._parseConnectionStats(prevStats, item, \"bytesSent\"), output.audio.sending.totalPackets = item.packetsSent, output.audio.sending.packets = self._parseConnectionStats(prevStats, item, \"packetsSent\"), output.audio.sending.totalNacks = item.nackCount, output.audio.sending.nacks = self._parseConnectionStats(prevStats, item, \"nackCount\");\n        var trackItem = output.raw[item.mediaTrackId || \"\"] || {};\n        output.audio.sending.audioInputLevel = trackItem.audioLevel, output.audio.sending.echoReturnLoss = trackItem.echoReturnLoss, output.audio.sending.echoReturnLossEnhancement = trackItem.echoReturnLossEnhancement;\n      }\n    },\n        videoStatsFn = function videoStatsFn(item, prop) {\n      var prevStats = isAutoBwStats ? self._peerBandwidth[peerId][prop] : self._peerStats[peerId][prop];\n      if (0 === prop.indexOf(\"RTCInboundRTPVideoStream\")) output.video.receiving.fractionLost = item.fractionLost, output.video.receiving.jitter = item.jitter, output.video.receiving.framesDecoded = item.framesDecoded, output.video.receiving.qpSum = item.qpSum, output.video.receiving.totalBytes = item.bytesReceived, output.video.receiving.bytes = self._parseConnectionStats(prevStats, item, \"bytesReceived\"), output.video.receiving.totalPackets = item.packetsReceived, output.video.receiving.packets = self._parseConnectionStats(prevStats, item, \"packetsReceived\"), output.video.receiving.totalPacketsDiscarded = item.packetsDiscarded, output.video.receiving.packetsDiscarded = self._parseConnectionStats(prevStats, item, \"packetsDiscarded\"), output.video.receiving.totalPacketsLost = item.packetsLost, output.video.receiving.packetsLost = self._parseConnectionStats(prevStats, item, \"packetsLost\"), output.video.receiving.totalNacks = item.nackCount, output.video.receiving.nacks = self._parseConnectionStats(prevStats, item, \"nackCount\"), output.video.receiving.totalFirs = item.firCount, output.video.receiving.firs = self._parseConnectionStats(prevStats, item, \"firCount\"), output.video.receiving.totalSlis = item.sliCount, output.video.receiving.slis = self._parseConnectionStats(prevStats, item, \"sliCount\");else if (0 === prop.indexOf(\"RTCMediaStreamTrack_remote_video_\")) output.video.receiving.frameHeight = item.frameHeight, output.video.receiving.frameWidth = item.frameWidth, output.video.receiving.framesCorrupted = item.framesCorrupted, output.video.receiving.framesPerSecond = item.framesPerSecond, output.video.receiving.framesDropped = item.framesDropped, output.video.receiving.totalFrames = item.framesReceived, output.video.receiving.frames = self._parseConnectionStats(prevStats, item, \"framesReceived\");else if (0 === prop.indexOf(\"RTCOutboundRTPVideoStream\")) output.video.sending.qpSum = item.qpSum, output.video.sending.targetBitrate = item.targetBitrate || 0, output.video.sending.framesEncoded = item.framesEncoded || 0, output.video.sending.totalBytes = item.bytesSent, output.video.sending.bytes = self._parseConnectionStats(prevStats, item, \"bytesSent\"), output.video.sending.totalPackets = item.packetsSent, output.video.sending.packets = self._parseConnectionStats(prevStats, item, \"packetsSent\"), output.video.sending.totalNacks = item.nackCount, output.video.sending.nacks = self._parseConnectionStats(prevStats, item, \"nackCount\"), output.video.receiving.totalFirs = item.firCount, output.video.receiving.firs = self._parseConnectionStats(prevStats, item, \"firCount\"), output.video.sending.totalSlis = item.sliCount, output.video.sending.slis = self._parseConnectionStats(prevStats, item, \"sliCount\");else if (\"edge\" === AdapterJS.webrtcDetectedBrowser && \"inboundrtp\" === item.type && \"video\" === item.mediaType && item.isRemote) {\n        output.video.receiving.fractionLost = item.fractionLost, output.video.receiving.jitter = item.jitter, output.video.receiving.totalBytes = item.bytesReceived, output.video.receiving.bytes = self._parseConnectionStats(prevStats, item, \"bytesReceived\"), output.video.receiving.totalPackets = item.packetsReceived, output.video.receiving.packets = self._parseConnectionStats(prevStats, item, \"packetsReceived\"), output.video.receiving.totalPacketsLost = item.packetsLost, output.video.receiving.packetsLost = self._parseConnectionStats(prevStats, item, \"packetsLost\"), output.video.receiving.totalNacks = item.nackCount, output.video.receiving.nacks = self._parseConnectionStats(prevStats, item, \"nackCount\"), output.video.receiving.totalPlis = item.pliCount, output.video.receiving.plis = self._parseConnectionStats(prevStats, item, \"pliCount\"), output.video.receiving.totalFirs = item.firCount, output.video.receiving.firs = self._parseConnectionStats(prevStats, item, \"firCount\"), output.video.receiving.totalSlis = item.sliCount, output.video.receiving.slis = self._parseConnectionStats(prevStats, item, \"sliCount\");\n        var trackItem = output.raw[item.mediaTrackId || \"\"] || {};\n        output.video.receiving.framesCorrupted = trackItem.framesCorrupted, output.video.receiving.framesDropped = trackItem.framesDropped, output.video.receiving.framesDecoded = trackItem.framesDecoded, output.video.receiving.totalFrames = trackItem.framesReceived, output.video.receiving.frames = self._parseConnectionStats(prevStats, trackItem, \"framesReceived\");\n      } else if (\"edge\" !== AdapterJS.webrtcDetectedBrowser || \"outboundrtp\" !== item.type || \"video\" !== item.mediaType || item.isRemote) {\n        if (0 === prop.indexOf(\"ssrc_\") && \"video\" === item.mediaType) {\n          if (prop.indexOf(\"_recv\") > 0) {\n            output.video.receiving.jitter = parseInt(item.googJitterReceived || \"0\", 10), output.video.receiving.jitterBufferMs = parseInt(item.googJitterBufferMs || \"0\", 10), output.video.receiving.currentDelayMs = parseInt(item.googCurrentDelayMs || \"0\", 10), output.video.receiving.renderDelayMs = parseInt(item.googRenderDelayMs || \"0\", 10), output.video.receiving.frameWidth = parseInt(item.googFrameWidthReceived || \"0\", 10), output.video.receiving.frameHeight = parseInt(item.googFrameHeightReceived || \"0\", 10), output.video.receiving.framesDecoded = parseInt(item.framesDecoded || \"0\", 10), output.video.receiving.frameRateOutput = parseInt(item.googFrameRateOutput || \"0\", 10), output.video.receiving.frameRateDecoded = parseInt(item.googFrameRateDecoded || \"0\", 10), output.video.receiving.frameRateReceived = parseInt(item.googFrameRateReceived || \"0\", 10), output.video.receiving.qpSum = parseInt(item.qpSum || \"0\", 10);\n            var bytesReceived = parseInt(item.bytesReceived || \"0\", 10);\n            output.video.receiving.totalBytes = bytesReceived, output.video.receiving.bytes = self._parseConnectionStats(prevStats, item, \"bytesReceived\");\n            var packetsReceived = parseInt(item.packetsReceived || \"0\", 10);\n            output.video.receiving.totalPackets = packetsReceived, output.video.receiving.packets = self._parseConnectionStats(prevStats, item, \"packetsReceived\");\n            var packetsLost = parseInt(item.packetsLost || \"0\", 10);\n            output.video.receiving.totalPacketsLost = packetsLost, output.video.receiving.packetsLost = self._parseConnectionStats(prevStats, item, \"packetsLost\");\n            var nacksSent = parseInt(item.googNacksSent || \"0\", 10);\n            output.video.receiving.totalNacks = nacksSent, output.video.receiving.nacks = self._parseConnectionStats(prevStats, item, \"googNacksSent\");\n            var plisSent = parseInt(item.googPlisSent || \"0\", 10);\n            output.video.receiving.totalPlis = plisSent, output.video.receiving.plis = self._parseConnectionStats(prevStats, item, \"googPlisSent\");\n            var firsSent = parseInt(item.googFirsSent || \"0\", 10);\n            output.video.receiving.totalFirs = firsSent, output.video.receiving.firs = self._parseConnectionStats(prevStats, item, \"googFirsSent\");\n          } else {\n            output.video.sending.rtt = parseInt(item.googRtt || \"0\", 10), output.video.sending.frameWidth = parseInt(item.googFrameWidthSent || \"0\", 10), output.video.sending.frameHeight = parseInt(item.googFrameHeightSent || \"0\", 10), output.video.sending.framesEncoded = parseInt(item.framesEncoded || \"0\", 10), output.video.sending.frameRateInput = parseInt(item.googFrameRateInput || \"0\", 10), output.video.sending.frameRateEncoded = parseInt(item.googFrameRateEncoded || \"0\", 10), output.video.sending.frameRateSent = parseInt(item.googFrameRateSent || \"0\", 10), output.video.sending.cpuLimitedResolution = \"true\" === item.googCpuLimitedResolution, output.video.sending.bandwidthLimitedResolution = \"true\" === item.googBandwidthLimitedResolution;\n            var bytesSent = parseInt(item.bytesSent || \"0\", 10);\n            output.video.sending.totalBytes = bytesSent, output.video.sending.bytes = self._parseConnectionStats(prevStats, item, \"bytesSent\");\n            var packetsSent = parseInt(item.packetsSent || \"0\", 10);\n            output.video.sending.totalPackets = packetsSent, output.video.sending.packets = self._parseConnectionStats(prevStats, item, \"packetsSent\");\n            var nacksReceived = parseInt(item.googNacksReceived || \"0\", 10);\n            output.video.sending.totalNacks = nacksReceived, output.video.sending.nacks = self._parseConnectionStats(prevStats, item, \"googNacksReceived\");\n            var plisReceived = parseInt(item.googPlisReceived || \"0\", 10);\n            output.video.sending.totalPlis = plisReceived, output.video.sending.plis = self._parseConnectionStats(prevStats, item, \"googPlisReceived\");\n            var firsReceived = parseInt(item.googFirsReceived || \"0\", 10);\n            output.video.sending.totalFirs = firsReceived, output.video.sending.firs = self._parseConnectionStats(prevStats, item, \"googFirsReceived\");\n          }\n        } else if (0 === prop.indexOf(\"inbound_rtp_video\")) output.video.receiving.jitter = item.jitter || 0, output.video.receiving.framesDecoded = item.framesDecoded || 0, output.video.receiving.frameRateMean = item.framerateMean || 0, output.video.receiving.frameRateStdDev = item.framerateStdDev || 0, output.video.receiving.totalBytes = item.bytesReceived, output.video.receiving.bytes = self._parseConnectionStats(prevStats, item, \"bytesReceived\"), output.video.receiving.totalPackets = item.packetsReceived, output.video.receiving.packets = self._parseConnectionStats(prevStats, item, \"packetsReceived\"), output.video.receiving.totalPacketsLost = item.packetsLost, output.video.receiving.packetsLost = self._parseConnectionStats(prevStats, item, \"packetsLost\"), output.video.receiving.totalNacks = item.nackCount, output.video.receiving.nacks = self._parseConnectionStats(prevStats, item, \"nackCount\"), output.video.receiving.totalPlis = item.pliCount, output.video.receiving.plis = self._parseConnectionStats(prevStats, item, \"pliCount\"), output.video.receiving.totalFirs = item.firCount, output.video.receiving.firs = self._parseConnectionStats(prevStats, item, \"firCount\");else if (0 === prop.indexOf(\"outbound_rtp_video\")) {\n          output.video.sending.framesEncoded = item.framesEncoded || 0, output.video.sending.frameRateMean = item.framerateMean || 0, output.video.sending.frameRateStdDev = item.framerateStdDev || 0, output.video.sending.framesDropped = item.droppedFrames || 0, output.video.sending.totalBytes = item.bytesSent, output.video.sending.bytes = self._parseConnectionStats(prevStats, item, \"bytesSent\"), output.video.sending.totalPackets = item.packetsSent, output.video.sending.packets = self._parseConnectionStats(prevStats, item, \"packetsSent\"), output.video.sending.totalNacks = item.nackCount, output.video.sending.nacks = self._parseConnectionStats(prevStats, item, \"nackCount\"), output.video.sending.totalPlis = item.pliCount, output.video.sending.plis = self._parseConnectionStats(prevStats, item, \"pliCount\"), output.video.sending.totalFirs = item.firCount, output.video.sending.firs = self._parseConnectionStats(prevStats, item, \"firCount\");\n          var rtcpItem = output.raw[prop.replace(/_rtp_/g, \"_rtcp_\")] || {};\n          output.video.sending.rtt = rtcpItem.roundTripTime || 0;\n        }\n      } else {\n        output.video.sending.targetBitrate = item.targetBitrate || 0, output.video.sending.roundTripTime = item.roundTripTime || 0, output.video.sending.totalBytes = item.bytesSent, output.video.sending.bytes = self._parseConnectionStats(prevStats, item, \"bytesSent\"), output.video.sending.totalPackets = item.packetsSent, output.video.sending.packets = self._parseConnectionStats(prevStats, item, \"packetsSent\"), output.video.sending.totalNacks = item.nackCount, output.video.sending.nacks = self._parseConnectionStats(prevStats, item, \"nackCount\"), output.video.sending.totalFirs = item.firCount, output.video.sending.firs = self._parseConnectionStats(prevStats, item, \"firCount\"), output.video.sending.totalPlis = item.pliCount, output.video.sending.plis = self._parseConnectionStats(prevStats, item, \"pliCount\"), output.video.sending.totalSlis = item.sliCount, output.video.sending.slis = self._parseConnectionStats(prevStats, item, \"sliCount\");\n        var trackItem = output.raw[item.mediaTrackId || \"\"] || {};\n        output.video.sending.frameHeight = trackItem.frameHeight, output.video.sending.frameWidth = trackItem.frameWidth, output.video.sending.framesPerSecond = trackItem.framesPerSecond, output.video.sending.totalFrames = trackItem.framesSent, output.video.sending.frames = self._parseConnectionStats(prevStats, trackItem, \"framesSent\");\n      }\n    },\n        videoE2EStatsFn = function videoE2EStatsFn(item, prop) {\n      if (0 === prop.indexOf(\"ssrc_\") && \"video\" === item.mediaType) {\n        var captureStartNtpTimeMs = parseInt(item.googCaptureStartNtpTimeMs || \"0\", 10),\n            remoteStream = pc.getRemoteStreams()[0];\n        if (!(captureStartNtpTimeMs > 0 && prop.indexOf(\"_recv\") > 0 && remoteStream && document && \"function\" == typeof document.getElementsByTagName)) return;\n\n        try {\n          var elements = document.getElementsByTagName(\"plugin\" === AdapterJS.webrtcDetectedType ? \"object\" : \"video\");\n          \"plugin\" !== AdapterJS.webrtcDetectedType && 0 === elements.length && (elements = document.getElementsByTagName(\"audio\"));\n\n          for (var e = 0; e < elements.length; e++) {\n            var videoStreamId = null;\n\n            if (\"plugin\" === AdapterJS.webrtcDetectedType) {\n              if (!(elements[e].children && \"object\" == typeof elements[e].children && \"number\" == typeof elements[e].children.length && elements[e].children.length > 0)) break;\n\n              for (var ec = 0; ec < elements[e].children.length; ec++) {\n                if (\"streamId\" === elements[e].children[ec].name) {\n                  videoStreamId = elements[e].children[ec].value || null;\n                  break;\n                }\n              }\n            } else videoStreamId = elements[e].srcObject && (elements[e].srcObject.id || elements[e].srcObject.label) || null;\n\n            if (videoStreamId && videoStreamId === (remoteStream.id || remoteStream.label)) {\n              output.video.receiving.e2eDelay = new Date().getTime() + 22089888e5 - captureStartNtpTimeMs - 1e3 * elements[e].currentTime;\n              break;\n            }\n          }\n        } catch (error) {\n          beSilentOnLogs || log.warn([peerId, \"RTCStatsReport\", null, \"Failed retrieving e2e delay ->\"], error);\n        }\n      }\n    },\n        successCbFn = function successCbFn(stats) {\n      \"function\" == typeof stats.forEach ? stats.forEach(function (item, prop) {\n        output.raw[prop] = item;\n      }) : output.raw = stats;\n      var edgeTracksKind = {\n        remote: {},\n        local: {}\n      };\n      \"edge\" === AdapterJS.webrtcDetectedBrowser && (pc.remoteStream && pc.remoteStream.getTracks().forEach(function (track) {\n        edgeTracksKind.remote[track.id] = track.kind;\n      }), pc.localStream && pc.localStream.getTracks().forEach(function (track) {\n        edgeTracksKind.local[track.id] = track.kind;\n      })), Object.keys(output.raw).forEach(function (prop) {\n        if (0 !== prop.indexOf(\"ssrc_\") || output.raw[prop].mediaType) {\n          if (\"edge\" === AdapterJS.webrtcDetectedBrowser && !output.raw[prop].mediaType && [\"inboundrtp\", \"outboundrtp\"].indexOf(output.raw[prop].type) > -1) {\n            var trackItem = output.raw[output.raw[prop].mediaTrackId] || {};\n            output.raw[prop].mediaType = edgeTracksKind[output.raw[prop].isRemote ? \"remote\" : \"local\"][trackItem.trackIdentifier] || \"\";\n          }\n        } else output.raw[prop].mediaType = output.raw[prop].audioInputLevel || output.raw[prop].audioOutputLevel ? \"audio\" : \"video\";\n\n        certificateFn(output.raw[prop], prop), candidatePairFn(output.raw[prop], prop), codecsFn(output.raw[prop], prop), audioStatsFn(output.raw[prop], prop), videoStatsFn(output.raw[prop], prop), videoE2EStatsFn(output.raw[prop], prop), isAutoBwStats && !self._peerBandwidth[peerId][prop] ? self._peerBandwidth[peerId][prop] = output.raw[prop] : isAutoBwStats || self._peerStats[peerId][prop] || (self._peerStats[peerId][prop] = output.raw[prop]);\n      }), output.audio.sending.bytes = output.audio.sending.bytes || 0, output.audio.sending.packets = output.audio.sending.packets || 0, output.audio.sending.totalBytes = output.audio.sending.totalBytes || 0, output.audio.sending.totalPackets = output.audio.sending.totalPackets || 0, output.video.sending.bytes = output.video.sending.bytes || 0, output.video.sending.packets = output.video.sending.packets || 0, output.video.sending.totalBytes = output.video.sending.totalBytes || 0, output.video.sending.totalPackets = output.video.sending.totalPackets || 0, output.audio.receiving.bytes = output.audio.receiving.bytes || 0, output.audio.receiving.packets = output.audio.receiving.packets || 0, output.audio.receiving.totalBytes = output.audio.receiving.totalBytes || 0, output.audio.receiving.totalPackets = output.audio.receiving.totalPackets || 0, output.video.receiving.bytes = output.video.receiving.bytes || 0, output.video.receiving.packets = output.video.receiving.packets || 0, output.video.receiving.totalBytes = output.video.receiving.totalBytes || 0, output.video.receiving.totalPackets = output.video.receiving.totalPackets || 0, callback(null, output);\n    },\n        errorCbFn = function errorCbFn(error) {\n      beSilentOnLogs || log.error([peerId, \"RTCStatsReport\", null, \"Failed retrieving stats ->\"], error), callback(error, null);\n    };\n\n    if (\"function\" != typeof pc.getStats) return errorCbFn(new Error(\"getStats() API is not available.\"));\n    \"plugin\" === AdapterJS.webrtcDetectedType ? pc.getStats(null, successCbFn, errorCbFn) : pc.getStats(null).then(successCbFn).catch(errorCbFn);\n  }, Skylink.prototype._addPeer = function (targetMid, cert, peerBrowser, receiveOnly, isSS) {\n    var self = this;\n    return self._peerConnections[targetMid] ? void log.error([targetMid, null, null, \"Connection to peer has already been made\"]) : (self._peerConnStatus[targetMid] = {\n      connected: !1,\n      init: !1\n    }, log.log([targetMid, null, null, \"Starting the connection to peer. Options provided:\"], {\n      peerBrowser: peerBrowser,\n      receiveOnly: receiveOnly,\n      enableDataChannel: self._initOptions.enableDataChannel\n    }), log.info(\"Adding peer\", isSS), self._peerConnections[targetMid] = self._createPeerConnection(targetMid, !!isSS, cert), self._peerConnections[targetMid] ? (self._peerConnStatus[targetMid].init = !0, void (self._peerConnections[targetMid].hasScreen = !!isSS)) : void log.error([targetMid, null, null, \"Failed creating the connection to peer.\"]));\n  }, Skylink.prototype._restartPeerConnection = function (peerId, doIceRestart, bwOptions, callback) {\n    var self = this;\n    if (!self._peerConnections[peerId]) return void log.error([peerId, null, null, \"Peer does not have an existing connection. Unable to restart\"]);\n    var pc = self._peerConnections[peerId],\n        agent = (self.getPeerInfo(peerId) || {}).agent || {};\n\n    if (self._isLowerThanVersion(agent.SMProtocolVersion || \"\", \"0.1.2\")) {\n      var notSupportedError = new Error(\"Failed restarting with other agents connecting from other SDKs as re-negotiation is not supported by other SDKs\");\n      return log.warn([peerId, \"RTCPeerConnection\", null, \"Ignoring restart request as agent's SDK does not support it\"], notSupportedError), void (\"function\" == typeof callback && (log.debug([peerId, \"RTCPeerConnection\", null, \"Firing restart failure callback\"]), callback(notSupportedError)));\n    }\n\n    if (pc.signalingState === self.PEER_CONNECTION_STATE.STABLE && self._peerConnections[peerId]) {\n      log.log([peerId, null, null, \"Sending restart message to signaling server ->\"], {\n        iceRestart: doIceRestart,\n        options: bwOptions\n      }), self._peerCustomConfigs[peerId] = self._peerCustomConfigs[peerId] || {}, self._peerCustomConfigs[peerId].bandwidth = self._peerCustomConfigs[peerId].bandwidth || {}, self._peerCustomConfigs[peerId].googleXBandwidth = self._peerCustomConfigs[peerId].googleXBandwidth || {}, bwOptions.bandwidth && \"object\" == typeof bwOptions.bandwidth && (\"number\" == typeof bwOptions.bandwidth.audio && (self._peerCustomConfigs[peerId].bandwidth.audio = bwOptions.bandwidth.audio), \"number\" == typeof bwOptions.bandwidth.video && (self._peerCustomConfigs[peerId].bandwidth.video = bwOptions.bandwidth.video), \"number\" == typeof bwOptions.bandwidth.data && (self._peerCustomConfigs[peerId].bandwidth.data = bwOptions.bandwidth.data)), bwOptions.googleXBandwidth && \"object\" == typeof bwOptions.googleXBandwidth && (\"number\" == typeof bwOptions.googleXBandwidth.min && (self._peerCustomConfigs[peerId].googleXBandwidth.min = bwOptions.googleXBandwidth.min), \"number\" == typeof bwOptions.googleXBandwidth.max && (self._peerCustomConfigs[peerId].googleXBandwidth.max = bwOptions.googleXBandwidth.max));\n      var restartMsg = {\n        type: self._SIG_MESSAGE_TYPE.RESTART,\n        mid: self._user.sid,\n        rid: self._room.id,\n        agent: AdapterJS.webrtcDetectedBrowser,\n        version: (AdapterJS.webrtcDetectedVersion || 0).toString(),\n        os: window.navigator.platform,\n        userInfo: self._getUserInfo(peerId),\n        target: peerId,\n        weight: self._peerPriorityWeight,\n        receiveOnly: self.getPeerInfo().config.receiveOnly,\n        enableIceTrickle: self._initOptions.enableIceTrickle,\n        enableDataChannel: self._initOptions.enableDataChannel,\n        enableIceRestart: self._enableIceRestart,\n        doIceRestart: !0 === doIceRestart && self._enableIceRestart && self._peerInformations[peerId] && self._peerInformations[peerId].config.enableIceRestart,\n        isRestartResend: !1,\n        temasysPluginVersion: AdapterJS.WebRTCPlugin.plugin ? AdapterJS.WebRTCPlugin.plugin.VERSION : null,\n        SMProtocolVersion: self.SM_PROTOCOL_VERSION,\n        DTProtocolVersion: self.DT_PROTOCOL_VERSION\n      };\n      self._publishOnly && (restartMsg.publishOnly = {\n        type: self._streams.screenshare && self._streams.screenshare.stream ? \"screenshare\" : \"video\"\n      }), self._parentId && (restartMsg.parentId = self._parentId), self._peerEndOfCandidatesCounter[peerId] = self._peerEndOfCandidatesCounter[peerId] || {}, self._peerEndOfCandidatesCounter[peerId].len = 0, self._sendChannelMessage(restartMsg), self._handleNegotiationStats(\"restart\", peerId, restartMsg, !1), self._trigger(\"peerRestart\", peerId, self.getPeerInfo(peerId), !0, !0 === doIceRestart), \"function\" == typeof callback && (log.debug([peerId, \"RTCPeerConnection\", null, \"Firing restart callback\"]), callback(null));\n    } else if (pc.signalingState === self.PEER_CONNECTION_STATE.HAVE_LOCAL_OFFER) {\n      var hasLocalDescription = pc.localDescription && pc.localDescription.sdp;\n      if (hasLocalDescription) self._sendChannelMessage({\n        type: pc.localDescription.type,\n        sdp: pc.localDescription.sdp,\n        mid: self._user.sid,\n        target: peerId,\n        rid: self._room.id,\n        restart: !0\n      });else {\n        var noLocalDescriptionError = \"Failed re-sending localDescription as there is no localDescription set to connection. There could be a handshaking step error\";\n        log.error([peerId, \"RTCPeerConnection\", null, noLocalDescriptionError], {\n          localDescription: pc.localDescription,\n          remoteDescription: pc.remoteDescription\n        }), \"function\" == typeof callback && (log.debug([peerId, \"RTCPeerConnection\", null, \"Firing restart failure callback\"]), callback(new Error(noLocalDescriptionError)));\n      }\n    } else {\n      var unableToRestartError = \"Failed restarting as peer connection state is \" + pc.signalingState;\n      log.warn([peerId, \"RTCPeerConnection\", null, unableToRestartError]), \"function\" == typeof callback && (log.debug([peerId, \"RTCPeerConnection\", null, \"Firing restart failure callback\"]), callback(new Error(unableToRestartError)));\n    }\n  }, Skylink.prototype._removePeer = function (peerId) {\n    if (!this._peerConnections[peerId] && !this._peerInformations[peerId]) return void log.debug([peerId, \"RTCPeerConnection\", null, \"Dropping the hangup from Peer as not connected to Peer at all.\"]);\n    var peerInfo = clone(this.getPeerInfo(peerId)) || {\n      userData: \"\",\n      settings: {\n        audio: !1,\n        video: !1,\n        data: !1\n      },\n      mediaStatus: {\n        audioMuted: !0,\n        videoMuted: !0\n      },\n      agent: {\n        name: \"unknown\",\n        version: 0,\n        os: \"\",\n        pluginVersion: null\n      },\n      config: {\n        enableDataChannel: !0,\n        enableIceRestart: !1,\n        enableIceTrickle: !0,\n        priorityWeight: 0,\n        publishOnly: !1,\n        receiveOnly: !0\n      },\n      parentId: null,\n      room: clone(this._selectedRoom)\n    };\n    \"MCU\" !== peerId ? this._trigger(\"peerLeft\", peerId, peerInfo, !1) : (this._hasMCU = !1, log.log([peerId, null, null, \"MCU has stopped listening and left\"]), this._trigger(\"serverPeerLeft\", peerId, this.SERVER_PEER_TYPE.MCU)), this._peerConnections[peerId] && (this._peerConnections[peerId].signalingState !== this.PEER_CONNECTION_STATE.CLOSED && (this._peerConnections[peerId].close(), \"AppleWebKit\" === AdapterJS.webrtcDetectedType && (this._peerConnections[peerId].signalingStateClosed || (this._peerConnections[peerId].signalingStateClosed = !0, this._trigger(\"peerConnectionState\", this.PEER_CONNECTION_STATE.CLOSED, peerId)), this._peerConnections[peerId].iceConnectionStateClosed || (this._peerConnections[peerId].iceConnectionStateClosed = !0, this._handleIceConnectionStats(this.ICE_CONNECTION_STATE.CLOSED, peerId), this._trigger(\"iceConnectionState\", this.ICE_CONNECTION_STATE.CLOSED, peerId)))), \"MCU\" !== peerId && this._handleEndedStreams(peerId), delete this._peerConnections[peerId]), this._peerInformations[peerId] && delete this._peerInformations[peerId], this._peerMessagesStamps[peerId] && delete this._peerMessagesStamps[peerId], this._streamsSession[peerId] && delete this._streamsSession[peerId], this._peerEndOfCandidatesCounter[peerId] && delete this._peerEndOfCandidatesCounter[peerId], this._peerCandidatesQueue[peerId] && delete this._peerCandidatesQueue[peerId], this._sdpSessions[peerId] && delete this._sdpSessions[peerId], this._peerStats[peerId] && delete this._peerStats[peerId], this._peerBandwidth[peerId] && delete this._peerBandwidth[peerId], this._gatheredCandidates[peerId] && delete this._gatheredCandidates[peerId], this._peerCustomConfigs[peerId] && delete this._peerCustomConfigs[peerId], this._peerConnStatus[peerId] && delete this._peerConnStatus[peerId], this._dataChannels[peerId] && this._closeDataChannel(peerId), log.log([peerId, \"RTCPeerConnection\", null, \"Successfully removed peer\"]);\n  }, Skylink.prototype._createPeerConnection = function (targetMid, isScreenSharing, cert) {\n    var pc,\n        self = this;\n\n    if (self._inRoom && self._room && self._room.connection && self._room.connection.peerConfig && Array.isArray(self._room.connection.peerConfig.iceServers)) {\n      var constraints = {\n        iceServers: self._room.connection.peerConfig.iceServers,\n        iceTransportPolicy: self._initOptions.filterCandidatesType.host && self._initOptions.filterCandidatesType.srflx && !self._initOptions.filterCandidatesType.relay ? \"relay\" : \"all\",\n        bundlePolicy: self._peerConnectionConfig.bundlePolicy === self.BUNDLE_POLICY.NONE ? self.BUNDLE_POLICY.BALANCED : self._peerConnectionConfig.bundlePolicy,\n        rtcpMuxPolicy: self._peerConnectionConfig.rtcpMuxPolicy,\n        iceCandidatePoolSize: self._peerConnectionConfig.iceCandidatePoolSize\n      },\n          optional = {\n        optional: [{\n          DtlsSrtpKeyAgreement: !0\n        }, {\n          googIPv6: !0\n        }]\n      };\n      cert && (constraints.certificates = [cert]), self._peerConnStatus[targetMid] && (self._peerConnStatus[targetMid].constraints = constraints, self._peerConnStatus[targetMid].optional = optional), \"chrome\" === AdapterJS.webrtcDetectedBrowser && (constraints.sdpSemantics = \"plan-b\");\n\n      try {\n        log.debug([targetMid, \"RTCPeerConnection\", null, \"Creating peer connection ->\"], {\n          constraints: constraints,\n          optional: optional\n        }), pc = new (self._initOptions.useEdgeWebRTC && window.msRTCPeerConnection ? window.msRTCPeerConnection : RTCPeerConnection)(constraints, optional);\n      } catch (error) {\n        return log.error([targetMid, null, null, \"Failed creating peer connection:\"], error), self._trigger(\"handshakeProgress\", self.HANDSHAKE_PROGRESS.ERROR, targetMid, error), null;\n      }\n\n      pc.setOffer = \"\", pc.setAnswer = \"\", pc.hasStream = !1, pc.hasScreen = !!isScreenSharing, pc.hasMainChannel = !1, pc.firefoxStreamId = \"\", pc.processingLocalSDP = !1, pc.processingRemoteSDP = !1, pc.gathered = !1, pc.gathering = !1, pc.localStream = null, pc.localStreamId = null, pc.remoteStream = null, pc.remoteStreamId = null, pc.iceConnectionStateClosed = !1, pc.signalingStateClosed = !1, self._gatheredCandidates[targetMid] = {\n        sending: {\n          host: [],\n          srflx: [],\n          relay: []\n        },\n        receiving: {\n          host: [],\n          srflx: [],\n          relay: []\n        }\n      }, self._streamsSession[targetMid] = self._streamsSession[targetMid] || {}, self._peerEndOfCandidatesCounter[targetMid] = self._peerEndOfCandidatesCounter[targetMid] || {}, self._sdpSessions[targetMid] = {\n        local: {},\n        remote: {}\n      }, self._peerBandwidth[targetMid] = {};\n      var bandwidth = null;\n      pc.ondatachannel = function (event) {\n        var dc = event.channel || event;\n\n        if (log.debug([targetMid, \"RTCDataChannel\", dc.label, \"Received datachannel ->\"], dc), self._initOptions.enableDataChannel && self._peerInformations[targetMid] && self._peerInformations[targetMid].config.enableDataChannel) {\n          self.DATA_CHANNEL_TYPE.DATA, dc.label;\n          pc.hasMainChannel || (self.DATA_CHANNEL_TYPE.MESSAGING, \"main\", pc.hasMainChannel = !0), self._createDataChannel(targetMid, dc);\n        } else log.warn([targetMid, \"RTCDataChannel\", dc.label, \"Not adding datachannel as enable datachannel is set to false\"]);\n      }, pc.onaddstream = function (evt) {\n        if (self._peerConnections[targetMid]) {\n          var stream = evt.stream || evt;\n          if (\"MCU\" === targetMid) return void log.warn([targetMid, \"MediaStream\", pc.remoteStreamId, \"Ignoring received remote stream from MCU ->\"], stream);\n          if (!self._sdpSettings.direction.audio.receive && !self._sdpSettings.direction.video.receive) return void log.warn([targetMid, \"MediaStream\", pc.remoteStreamId, \"Ignoring received empty remote stream ->\"], stream);\n          pc.remoteStream = stream, pc.remoteStreamId = pc.remoteStreamId || stream.id || stream.label;\n          var peerSettings = clone(self.getPeerInfo(targetMid).settings);\n          self._streamsSession[targetMid][pc.remoteStreamId] = peerSettings, 0 === stream.getAudioTracks().length && (self._streamsSession[targetMid][pc.remoteStreamId].audio = !1), 0 === stream.getVideoTracks().length && (self._streamsSession[targetMid][pc.remoteStreamId].video = !1), pc.hasStream = !0, pc.hasScreen = peerSettings.video && \"object\" == typeof peerSettings.video && peerSettings.video.screenshare, self._onRemoteStreamAdded(targetMid, stream, !!pc.hasScreen);\n        }\n      }, pc.onicecandidate = function (event) {\n        self._onIceCandidate(targetMid, event.candidate || event);\n      };\n      var statsInterval = null;\n      return pc.oniceconnectionstatechange = function (evt) {\n        var iceConnectionState = pc.iceConnectionState;\n        if (log.debug([targetMid, \"RTCIceConnectionState\", null, \"Ice connection state changed ->\"], iceConnectionState), \"edge\" === AdapterJS.webrtcDetectedBrowser && (\"connecting\" === iceConnectionState ? iceConnectionState = self.ICE_CONNECTION_STATE.CHECKING : \"new\" === iceConnectionState && (iceConnectionState = self.ICE_CONNECTION_STATE.FAILED)), \"AppleWebKit\" === AdapterJS.webrtcDetectedType && iceConnectionState === self.ICE_CONNECTION_STATE.CLOSED) return void setTimeout(function () {\n          pc.iceConnectionStateClosed || (self._handleIceConnectionStats(self.ICE_CONNECTION_STATE.CLOSED, targetMid), self._trigger(\"iceConnectionState\", self.ICE_CONNECTION_STATE.CLOSED, targetMid));\n        }, 10);\n\n        if (self._handleIceConnectionStats(pc.iceConnectionState, targetMid), self._trigger(\"iceConnectionState\", iceConnectionState, targetMid), iceConnectionState === self.ICE_CONNECTION_STATE.FAILED && self._initOptions.enableIceTrickle && self._trigger(\"iceConnectionState\", self.ICE_CONNECTION_STATE.TRICKLE_FAILED, targetMid), self._peerConnStatus[targetMid] && (self._peerConnStatus[targetMid].connected = [self.ICE_CONNECTION_STATE.COMPLETED, self.ICE_CONNECTION_STATE.CONNECTED].indexOf(iceConnectionState) > -1), !statsInterval && [self.ICE_CONNECTION_STATE.CONNECTED, self.ICE_CONNECTION_STATE.COMPLETED].indexOf(iceConnectionState) > -1 && (statsInterval = !0, self.getConnectionStatus(targetMid, function () {\n          statsInterval = setInterval(function () {\n            if (!self._peerConnections[targetMid] || self._peerConnections[targetMid].signalingState === self.PEER_CONNECTION_STATE.CLOSED) return void clearInterval(statsInterval);\n\n            self._handleBandwidthStats(targetMid);\n          }, 2e4);\n        })), !self._hasMCU && [self.ICE_CONNECTION_STATE.CONNECTED, self.ICE_CONNECTION_STATE.COMPLETED].indexOf(iceConnectionState) > -1 && self._bandwidthAdjuster && !bandwidth && \"edge\" !== AdapterJS.webrtcDetectedBrowser && \"edge\" !== (((self._peerInformations[targetMid] || {}).agent || {}).name || \"edge\")) {\n          var currentBlock = 0,\n              formatTotalFn = function formatTotalFn(arr) {\n            for (var total = 0, i = 0; i < arr.length; i++) {\n              total += arr[i];\n            }\n\n            return total / arr.length;\n          };\n\n          bandwidth = {\n            audio: {\n              send: [],\n              recv: []\n            },\n            video: {\n              send: [],\n              recv: []\n            }\n          };\n          var pullInterval = setInterval(function () {\n            if (!self._peerConnections[targetMid] || self._peerConnections[targetMid].signalingState === self.PEER_CONNECTION_STATE.CLOSED || !self._bandwidthAdjuster || !self._peerBandwidth[targetMid]) return void clearInterval(pullInterval);\n\n            self._retrieveStats(targetMid, function (err, stats) {\n              if (!self._peerConnections[targetMid] || self._peerConnections[targetMid].signalingState === self.PEER_CONNECTION_STATE.CLOSED || !self._bandwidthAdjuster) return void clearInterval(pullInterval);\n\n              if (err ? (bandwidth.audio.send.push(0), bandwidth.audio.recv.push(0), bandwidth.video.send.push(0), bandwidth.video.recv.push(0)) : (bandwidth.audio.send.push(8 * stats.audio.sending.bytes), bandwidth.audio.recv.push(8 * stats.audio.receiving.bytes), bandwidth.video.send.push(8 * stats.video.sending.bytes), bandwidth.video.recv.push(8 * stats.video.receiving.bytes)), ++currentBlock === self._bandwidthAdjuster.interval) {\n                currentBlock = 0;\n                var totalAudioBw = formatTotalFn(bandwidth.audio.send),\n                    totalVideoBw = formatTotalFn(bandwidth.video.send);\n                self._bandwidthAdjuster.useUploadBwOnly || (totalAudioBw += formatTotalFn(bandwidth.audio.recv), totalVideoBw += formatTotalFn(bandwidth.video.recv), totalAudioBw /= 2, totalVideoBw /= 2), totalAudioBw = parseInt(totalAudioBw * (self._bandwidthAdjuster.limitAtPercentage / 100) / 1e3, 10), totalVideoBw = parseInt(totalVideoBw * (self._bandwidthAdjuster.limitAtPercentage / 100) / 1e3, 10), bandwidth = {\n                  audio: {\n                    send: [],\n                    recv: []\n                  },\n                  video: {\n                    send: [],\n                    recv: []\n                  }\n                }, self.refreshConnection(targetMid, {\n                  bandwidth: {\n                    audio: totalAudioBw,\n                    video: totalVideoBw\n                  }\n                });\n              }\n            }, !0, !0);\n          }, 1e3);\n        }\n      }, pc.onsignalingstatechange = function () {\n        if (log.debug([targetMid, \"RTCSignalingState\", null, \"Peer connection state changed ->\"], pc.signalingState), \"AppleWebKit\" === AdapterJS.webrtcDetectedType && pc.signalingState === self.PEER_CONNECTION_STATE.CLOSED) return void setTimeout(function () {\n          pc.signalingStateClosed || self._trigger(\"peerConnectionState\", self.PEER_CONNECTION_STATE.CLOSED, targetMid);\n        }, 10);\n\n        self._trigger(\"peerConnectionState\", pc.signalingState, targetMid);\n      }, pc.onicegatheringstatechange = function () {\n        log.log([targetMid, \"RTCIceGatheringState\", null, \"Ice gathering state changed ->\"], pc.iceGatheringState), self._trigger(\"candidateGenerationState\", pc.iceGatheringState, targetMid);\n      }, \"firefox\" === AdapterJS.webrtcDetectedBrowser && (pc.removeStream = function (stream) {\n        for (var senders = pc.getSenders(), s = 0; s < senders.length; s++) {\n          for (var tracks = stream.getTracks(), t = 0; t < tracks.length; t++) {\n            tracks[t] === senders[s].track && pc.removeTrack(senders[s]);\n          }\n        }\n      }), self._handleIceConnectionStats(pc.iceConnectionState, targetMid), self._handleIceGatheringStats(\"new\", targetMid, !1), pc;\n    }\n  }, Skylink.prototype._restartMCUConnection = function (callback, doIceRestart, bwOptions) {\n    var self = this,\n        listOfPeers = Object.keys(self._peerConnections),\n        listOfPeerRestartErrors = {},\n        sendRestartMsgFn = function sendRestartMsgFn(peerId) {\n      var restartMsg = {\n        type: self._SIG_MESSAGE_TYPE.RESTART,\n        mid: self._user.sid,\n        rid: self._room.id,\n        agent: AdapterJS.webrtcDetectedBrowser,\n        version: (AdapterJS.webrtcDetectedVersion || 0).toString(),\n        os: window.navigator.platform,\n        userInfo: self._getUserInfo(peerId),\n        target: peerId,\n        weight: self._peerPriorityWeight,\n        receiveOnly: self.getPeerInfo().config.receiveOnly,\n        enableIceTrickle: self._initOptions.enableIceTrickle,\n        enableDataChannel: self._initOptions.enableDataChannel,\n        enableIceRestart: self._enableIceRestart,\n        doIceRestart: self._initOptions.mcuUseRenegoRestart && !0 === doIceRestart && self._enableIceRestart && self._peerInformations[peerId] && self._peerInformations[peerId].config.enableIceRestart,\n        isRestartResend: !1,\n        temasysPluginVersion: AdapterJS.WebRTCPlugin.plugin ? AdapterJS.WebRTCPlugin.plugin.VERSION : null,\n        SMProtocolVersion: self.SM_PROTOCOL_VERSION,\n        DTProtocolVersion: self.DT_PROTOCOL_VERSION\n      };\n      self._publishOnly && (restartMsg.publishOnly = {\n        type: self._streams.screenshare && self._streams.screenshare.stream ? \"screenshare\" : \"video\"\n      }), self._parentId && (restartMsg.parentId = self._parentId), log.log([peerId, \"RTCPeerConnection\", null, \"Sending restart message to signaling server ->\"], restartMsg), self._sendChannelMessage(restartMsg), self._handleNegotiationStats(\"restart\", peerId, restartMsg, !1);\n    };\n\n    bwOptions.bandwidth && \"object\" == typeof bwOptions.bandwidth && (\"number\" == typeof bwOptions.bandwidth.audio && (self._streamsBandwidthSettings.bAS.audio = bwOptions.bandwidth.audio), \"number\" == typeof bwOptions.bandwidth.video && (self._streamsBandwidthSettings.bAS.video = bwOptions.bandwidth.video), \"number\" == typeof bwOptions.bandwidth.data && (self._streamsBandwidthSettings.bAS.data = bwOptions.bandwidth.data)), bwOptions.googleXBandwidth && \"object\" == typeof bwOptions.googleXBandwidth && (\"number\" == typeof bwOptions.googleXBandwidth.min && (self._streamsBandwidthSettings.googleX.min = bwOptions.googleXBandwidth.min), \"number\" == typeof bwOptions.googleXBandwidth.max && (self._streamsBandwidthSettings.googleX.max = bwOptions.googleXBandwidth.max));\n\n    for (var i = 0; i < listOfPeers.length; i++) {\n      if (self._peerConnections[listOfPeers[i]]) \"MCU\" !== listOfPeers[i] && (self._trigger(\"peerRestart\", listOfPeers[i], self.getPeerInfo(listOfPeers[i]), !0, !1), self._initOptions.mcuUseRenegoRestart || sendRestartMsgFn(listOfPeers[i]));else {\n        var error = \"Peer connection with peer does not exists. Unable to restart\";\n        log.error([listOfPeers[i], \"PeerConnection\", null, error]), listOfPeerRestartErrors[listOfPeers[i]] = new Error(error);\n      }\n    }\n\n    if (self._trigger(\"serverPeerRestart\", \"MCU\", self.SERVER_PEER_TYPE.MCU), self._initOptions.mcuUseRenegoRestart) self._peerEndOfCandidatesCounter.MCU = self._peerEndOfCandidatesCounter.MCU || {}, self._peerEndOfCandidatesCounter.MCU.len = 0, sendRestartMsgFn(\"MCU\");else {\n      var peerJoinedFn = function peerJoinedFn(peerId, peerInfo, isSelf) {\n        log.log([null, \"PeerConnection\", null, \"Invoked all peers to restart with MCU. Firing callback\"]), \"function\" == typeof callback && (Object.keys(listOfPeerRestartErrors).length > 0 ? callback({\n          refreshErrors: listOfPeerRestartErrors,\n          listOfPeers: listOfPeers\n        }, null) : callback(null, {\n          listOfPeers: listOfPeers\n        }));\n      };\n\n      self.once(\"peerJoined\", peerJoinedFn, function (peerId, peerInfo, isSelf) {\n        return isSelf;\n      }), self.leaveRoom(!1, function (error, success) {\n        if (error) {\n          if (\"function\" == typeof callback) {\n            for (var i = 0; i < listOfPeers.length; i++) {\n              listOfPeerRestartErrors[listOfPeers[i]] = error;\n            }\n\n            callback({\n              refreshErrors: listOfPeerRestartErrors,\n              listOfPeers: listOfPeers\n            }, null);\n          }\n        } else self.joinRoom(self._selectedRoom, {\n          bandwidth: bwOptions.bandwidth || {},\n          googleXBandwidth: bwOptions.googleXBandwidth || {},\n          sdpSettings: clone(self._sdpSettings),\n          voiceActivityDetection: self._voiceActivityDetection,\n          publishOnly: !!self._publishOnly,\n          parentId: self._parentId || null,\n          autoBandwidthAdjustment: self._bandwidthAdjuster\n        });\n      });\n    }\n  }, Skylink.prototype._parseConnectionStats = function (prevStats, stats, prop) {\n    var nTime = stats.timestamp,\n        oTime = prevStats ? prevStats.timestamp || 0 : 0,\n        nVal = parseFloat(stats[prop] || \"0\", 10),\n        oVal = parseFloat(prevStats ? prevStats[prop] || \"0\" : \"0\", 10);\n    return new Date(nTime).getTime() === new Date(oTime).getTime() ? nVal : parseFloat(((nVal - oVal) / (nTime - oTime) * 1e3).toFixed(3) || \"0\", 10);\n  }, Skylink.prototype._signalingEndOfCandidates = function (targetMid) {\n    var self = this;\n\n    if (self._peerEndOfCandidatesCounter[targetMid] && self._peerConnections[targetMid] && self._peerConnections[targetMid].signalingState !== self.PEER_CONNECTION_STATE.CLOSED && self._peerConnections[targetMid].remoteDescription && self._peerConnections[targetMid].remoteDescription.sdp && \"number\" == typeof self._peerEndOfCandidatesCounter[targetMid].expectedLen && self._peerEndOfCandidatesCounter[targetMid].len >= self._peerEndOfCandidatesCounter[targetMid].expectedLen && (!self._peerCandidatesQueue[targetMid] || 0 === self._peerCandidatesQueue[targetMid].length) && !self._peerEndOfCandidatesCounter[targetMid].hasSet) {\n      log.debug([targetMid, \"RTCPeerConnection\", null, \"Signaling of end-of-candidates remote ICE gathering.\"]), self._peerEndOfCandidatesCounter[targetMid].hasSet = !0;\n\n      try {\n        if (\"edge\" === AdapterJS.webrtcDetectedBrowser) {\n          for (var mLineCounter = -1, addedMids = [], sdpLines = self._peerConnections[targetMid].remoteDescription.sdp.split(\"\\r\\n\"), rejected = !1, i = 0; i < sdpLines.length; i++) {\n            if (0 === sdpLines[i].indexOf(\"m=\")) rejected = \"0\" === sdpLines[i].split(\" \")[1], mLineCounter++;else if (0 === sdpLines[i].indexOf(\"a=mid:\") && !rejected) {\n              var mid = sdpLines[i].split(\"a=mid:\")[1] || \"\";\n              if (mid && -1 === addedMids.indexOf(mid) && (addedMids.push(mid), self._addIceCandidate(targetMid, \"endofcan-\" + new Date().getTime(), new RTCIceCandidate({\n                sdpMid: mid,\n                sdpMLineIndex: mLineCounter,\n                candidate: \"candidate:1 1 udp 1 0.0.0.0 9 typ endOfCandidates\"\n              })), self._peerConnectionConfig.bundlePolicy === self.BUNDLE_POLICY.MAX_BUNDLE)) break;\n            }\n          }\n        } else AdapterJS && !self._isLowerThanVersion(AdapterJS.VERSION, \"0.14.0\") && self._peerConnections[targetMid].addIceCandidate(null);\n\n        self._gatheredCandidates[targetMid] && self._trigger(\"candidatesGathered\", targetMid, {\n          expected: self._peerEndOfCandidatesCounter[targetMid].expectedLen || 0,\n          received: self._peerEndOfCandidatesCounter[targetMid].len || 0,\n          processed: self._gatheredCandidates[targetMid].receiving.srflx.length + self._gatheredCandidates[targetMid].receiving.relay.length + self._gatheredCandidates[targetMid].receiving.host.length\n        });\n      } catch (error) {\n        log.error([targetMid, \"RTCPeerConnection\", null, \"Failed signaling end-of-candidates ->\"], error);\n      }\n    }\n  }, Skylink.prototype.setUserData = function (userData) {\n    var self = this,\n        updatedUserData = \"\";\n    void 0 !== userData && null !== userData && (updatedUserData = userData), this._userData = updatedUserData, self._inRoom ? (log.log(\"Updated userData -> \", updatedUserData), self._sendChannelMessage({\n      type: self._SIG_MESSAGE_TYPE.UPDATE_USER,\n      mid: self._user.sid,\n      rid: self._room.id,\n      userData: updatedUserData,\n      stamp: new Date().getTime()\n    }), self._trigger(\"peerUpdated\", self._user.sid, self.getPeerInfo(), !0)) : log.warn(\"User is not in the room. Broadcast of updated information will be dropped\");\n  }, Skylink.prototype.getUserData = function (peerId) {\n    if (peerId && this._peerInformations[peerId]) {\n      var userData = this._peerInformations[peerId].userData;\n      return null !== userData && void 0 !== userData || (userData = \"\"), userData;\n    }\n\n    return this._userData;\n  }, Skylink.prototype.getPeerInfo = function (peerId) {\n    var peerInfo = null;\n    return \"string\" == typeof peerId && \"object\" == typeof this._peerInformations[peerId] ? (peerInfo = clone(this._peerInformations[peerId]), peerInfo.room = clone(this._selectedRoom), peerInfo.settings.bandwidth = peerInfo.settings.bandwidth || {}, peerInfo.settings.googleXBandwidth = peerInfo.settings.googleXBandwidth || {}, \"boolean\" == typeof peerInfo.settings.video || peerInfo.settings.video && \"object\" == typeof peerInfo.settings.video || (peerInfo.settings.video = !1, peerInfo.mediaStatus.audioMuted = !0), \"boolean\" == typeof peerInfo.settings.audio || peerInfo.settings.audio && \"object\" == typeof peerInfo.settings.audio || (peerInfo.settings.audio = !1, peerInfo.mediaStatus.audioMuted = !0), \"boolean\" != typeof peerInfo.mediaStatus.audioMuted && (peerInfo.mediaStatus.audioMuted = !0), \"boolean\" != typeof peerInfo.mediaStatus.videoMuted && (peerInfo.mediaStatus.videoMuted = !0), peerInfo.settings.maxBandwidth && (peerInfo.settings.bandwidth = clone(peerInfo.settings.maxBandwidth), delete peerInfo.settings.maxBandwidth), peerInfo.settings.video && \"object\" == typeof peerInfo.settings.video && peerInfo.settings.video.customSettings && \"object\" == typeof peerInfo.settings.video.customSettings && (peerInfo.settings.video.customSettings.frameRate && (peerInfo.settings.video.frameRate = clone(peerInfo.settings.video.customSettings.frameRate)), peerInfo.settings.video.customSettings.facingMode && (peerInfo.settings.video.facingMode = clone(peerInfo.settings.video.customSettings.facingMode)), peerInfo.settings.video.customSettings.width && (peerInfo.settings.video.resolution = peerInfo.settings.video.resolution || {}, peerInfo.settings.video.resolution.width = clone(peerInfo.settings.video.customSettings.width)), peerInfo.settings.video.customSettings.height && (peerInfo.settings.video.resolution = peerInfo.settings.video.resolution || {}, peerInfo.settings.video.resolution.height = clone(peerInfo.settings.video.customSettings.height)), peerInfo.settings.video.customSettings.facingMode && (peerInfo.settings.video.facingMode = clone(peerInfo.settings.video.customSettings.facingMode))), peerInfo.settings.audio && \"object\" == typeof peerInfo.settings.audio && (peerInfo.settings.audio.stereo = !0 === peerInfo.settings.audio.stereo), null !== peerInfo.userData && void 0 !== peerInfo.userData || (peerInfo.userData = \"\"), peerInfo.parentId = peerInfo.parentId || null, \"MCU\" === peerId ? (peerInfo.config.receiveOnly = !0, peerInfo.config.publishOnly = !1) : this._hasMCU && (peerInfo.config.receiveOnly = !1, peerInfo.config.publishOnly = !0), this._sdpSettings.direction.audio.receive || (peerInfo.settings.audio = !1, peerInfo.mediaStatus.audioMuted = !0), this._sdpSettings.direction.video.receive || (peerInfo.settings.video = !1, peerInfo.mediaStatus.videoMuted = !0), this._sdpSettings.connection.audio || (peerInfo.settings.audio = !1, peerInfo.mediaStatus.audioMuted = !0), this._sdpSettings.connection.video || (peerInfo.settings.video = !1, peerInfo.mediaStatus.videoMuted = !0), peerInfo.settings.data = !!(this._dataChannels[peerId] && this._dataChannels[peerId].main && this._dataChannels[peerId].main.channel && this._dataChannels[peerId].main.channel.readyState === this.DATA_CHANNEL_STATE.OPEN), peerInfo.connected = this._peerConnStatus[peerId] && !!this._peerConnStatus[peerId].connected, peerInfo.init = this._peerConnStatus[peerId] && !!this._peerConnStatus[peerId].init, this._sdpSessions[peerId] && this._sdpSessions[peerId].remote && this._sdpSessions[peerId].remote.connection && \"object\" == typeof this._sdpSessions[peerId].remote.connection && (this._sdpSessions[peerId].remote.connection.audio && this._sdpSessions[peerId].remote.connection.audio.indexOf(\"send\") > -1 || (peerInfo.settings.audio = !1, peerInfo.mediaStatus.audioMuted = !0), this._sdpSessions[peerId].remote.connection.video && this._sdpSessions[peerId].remote.connection.video.indexOf(\"send\") > -1 || (peerInfo.settings.video = !1, peerInfo.mediaStatus.videoMuted = !0), this._sdpSessions[peerId].remote.connection.data && this._sdpSessions[peerId].remote.connection.data.indexOf(\"send\") > -1 || (peerInfo.settings.data = !1))) : (peerInfo = {\n      userData: clone(this._userData),\n      settings: {\n        audio: !1,\n        video: !1\n      },\n      mediaStatus: clone(this._streamsMutedSettings),\n      agent: {\n        name: AdapterJS.webrtcDetectedBrowser,\n        version: AdapterJS.webrtcDetectedVersion,\n        os: window.navigator.platform,\n        pluginVersion: AdapterJS.WebRTCPlugin.plugin ? AdapterJS.WebRTCPlugin.plugin.VERSION : null,\n        SMProtocolVersion: this.SMProtocolVersion,\n        DTProtocolVersion: this.DTProtocolVersion\n      },\n      room: clone(this._selectedRoom),\n      config: {\n        enableDataChannel: this._initOptions.enableDataChannel,\n        enableIceTrickle: this._initOptions.enableIceTrickle,\n        enableIceRestart: this._enableIceRestart,\n        priorityWeight: this._peerPriorityWeight,\n        receiveOnly: !1,\n        publishOnly: !!this._publishOnly\n      },\n      connected: null,\n      init: null\n    }, null !== peerInfo.userData && void 0 !== peerInfo.userData || (peerInfo.userData = \"\"), this._streams.screenshare ? peerInfo.settings = clone(this._streams.screenshare.settings) : this._streams.userMedia && (peerInfo.settings = clone(this._streams.userMedia.settings)), peerInfo.settings.bandwidth = clone(this._streamsBandwidthSettings.bAS), peerInfo.settings.googleXBandwidth = clone(this._streamsBandwidthSettings.googleX), peerInfo.parentId = this._parentId ? this._parentId : null, peerInfo.config.receiveOnly = !peerInfo.settings.video && !peerInfo.settings.audio, peerInfo.settings.data = this._initOptions.enableDataChannel && this._sdpSettings.connection.data, peerInfo.settings.audio && \"object\" == typeof peerInfo.settings.audio && (\"boolean\" == typeof this._initOptions.codecParams.audio.opus.stereo && (peerInfo.settings.audio.stereo = this._initOptions.codecParams.audio.opus.stereo), \"boolean\" == typeof this._initOptions.codecParams.audio.opus.usedtx && (peerInfo.settings.audio.usedtx = this._initOptions.codecParams.audio.opus.usedtx), \"number\" == typeof this._initOptions.codecParams.audio.opus.maxplaybackrate && (peerInfo.settings.audio.maxplaybackrate = this._initOptions.codecParams.audio.opus.maxplaybackrate), \"boolean\" == typeof this._initOptions.codecParams.audio.opus.useinbandfec && (peerInfo.settings.audio.useinbandfec = this._initOptions.codecParams.audio.opus.useinbandfec))), peerInfo.settings.audio || (peerInfo.mediaStatus.audioMuted = !0), peerInfo.settings.video || (peerInfo.mediaStatus.videoMuted = !0), peerInfo.settings.audio || peerInfo.settings.video || (peerInfo.config.receiveOnly = !0, peerInfo.config.publishOnly = !1), peerInfo;\n  }, Skylink.prototype.getPeersInRoom = function () {\n    for (var listOfPeersInfo = {}, listOfPeers = Object.keys(this._peerInformations), i = 0; i < listOfPeers.length; i++) {\n      listOfPeersInfo[listOfPeers[i]] = clone(this.getPeerInfo(listOfPeers[i])), listOfPeersInfo[listOfPeers[i]].isSelf = !1;\n    }\n\n    return this._user && this._user.sid && (listOfPeersInfo[this._user.sid] = clone(this.getPeerInfo()), listOfPeersInfo[this._user.sid].isSelf = !0), listOfPeersInfo;\n  }, Skylink.prototype.getPeersStream = function () {\n    for (var listOfPeersStreams = {}, listOfPeers = Object.keys(this._peerConnections), i = 0; i < listOfPeers.length; i++) {\n      var stream = null,\n          streamId = null;\n      this._peerConnections[listOfPeers[i]] && this._peerConnections[listOfPeers[i]].remoteDescription && this._peerConnections[listOfPeers[i]].remoteDescription.sdp && (this._sdpSettings.direction.audio.receive || this._sdpSettings.direction.video.receive) && (stream = this._peerConnections[listOfPeers[i]].remoteStream, streamId = stream && (this._peerConnections[listOfPeers[i]].remoteStreamId || stream.id || stream.label)), listOfPeersStreams[listOfPeers[i]] = {\n        streamId: streamId,\n        stream: stream,\n        isSelf: !1\n      };\n    }\n\n    if (this._user && this._user.sid) {\n      var selfStream = null;\n      this._streams.screenshare && this._streams.screenshare.stream ? selfStream = this._streams.screenshare.stream : this._streams.userMedia && this._streams.userMedia.stream && (selfStream = this._streams.userMedia.stream), listOfPeersStreams[this._user.sid] = {\n        streamId: selfStream ? selfStream.id || selfStream.label || null : null,\n        stream: selfStream,\n        isSelf: !0\n      };\n    }\n\n    return listOfPeersStreams;\n  }, Skylink.prototype.getPeersDatachannels = function () {\n    for (var listOfPeersDatachannels = {}, listOfPeers = Object.keys(this._peerConnections), i = 0; i < listOfPeers.length; i++) {\n      if (listOfPeersDatachannels[listOfPeers[i]] = {}, this._dataChannels[listOfPeers[i]]) for (var channelProp in this._dataChannels[listOfPeers[i]]) {\n        if (this._dataChannels[listOfPeers[i]].hasOwnProperty(channelProp) && this._dataChannels[listOfPeers[i]][channelProp]) {\n          var channel = this._dataChannels[listOfPeers[i]][channelProp];\n          listOfPeersDatachannels[listOfPeers[i]][channel.channelName] = this._getDataChannelBuffer(listOfPeers[i], channelProp), listOfPeersDatachannels[listOfPeers[i]][channel.channelName].channelName = channel.channelName, listOfPeersDatachannels[listOfPeers[i]][channel.channelName].channelType = channel.channelType, listOfPeersDatachannels[listOfPeers[i]][channel.channelName].channelProp = channelProp, listOfPeersDatachannels[listOfPeers[i]][channel.channelName].currentTransferId = channel.transferId, listOfPeersDatachannels[listOfPeers[i]][channel.channelName].currentStreamId = channel.streamId, listOfPeersDatachannels[listOfPeers[i]][channel.channelName].readyState = channel.channel ? channel.channel.readyState : self.DATA_CHANNEL_STATE.CREATE_ERROR;\n        }\n      }\n    }\n\n    return listOfPeersDatachannels;\n  }, Skylink.prototype.getCurrentDataTransfers = function () {\n    var listOfDataTransfers = {};\n    if (!this._user || !this._user.sid) return {};\n\n    for (var prop in this._dataTransfers) {\n      this._dataTransfers.hasOwnProperty(prop) && this._dataTransfers[prop] && (listOfDataTransfers[prop] = {\n        transferInfo: this._getTransferInfo(prop, this._user.sid, !0, !0, !0),\n        isSelf: this._dataTransfers[prop].senderPeerId === this._user.sid,\n        peerId: this._dataTransfers[prop].senderPeerId || this._user.sid\n      });\n    }\n\n    return listOfDataTransfers;\n  }, Skylink.prototype.getCurrentDataStreamsSession = function () {\n    var listOfDataStreams = {};\n    if (!this._user || !this._user.sid) return {};\n\n    for (var prop in this._dataStreams) {\n      this._dataStreams.hasOwnProperty(prop) && this._dataStreams[prop] && (listOfDataStreams[prop] = {\n        streamInfo: {\n          chunkType: \"string\" === this._dataStreams[prop].sessionChunkType ? this.DATA_TRANSFER_DATA_TYPE.STRING : this.DATA_TRANSFER_DATA_TYPE.BLOB,\n          isPrivate: this._dataStreams[prop].isPrivate,\n          isStringStream: \"string\" === this._dataStreams[prop].sessionChunkType,\n          senderPeerId: this._dataStreams[prop].senderPeerId\n        },\n        isSelf: this._dataStreams[prop].senderPeerId === this._user.sid,\n        peerId: this._dataStreams[prop].senderPeerId || this._user.sid\n      });\n    }\n\n    return listOfDataStreams;\n  }, Skylink.prototype.getPeersCustomSettings = function () {\n    var self = this,\n        customSettingsList = {};\n\n    for (var peerId in self._peerInformations) {\n      self._peerInformations.hasOwnProperty(peerId) && self._peerInformations[peerId] && (customSettingsList[peerId] = self._getPeerCustomSettings(peerId));\n    }\n\n    return customSettingsList;\n  }, Skylink.prototype._getPeerCustomSettings = function (peerId) {\n    var self = this,\n        customSettings = {\n      settings: {\n        audio: !1,\n        video: !1,\n        data: !1,\n        bandwidth: clone(self._streamsBandwidthSettings.bAS),\n        googleXBandwidth: clone(self._streamsBandwidthSettings.googleX)\n      },\n      mediaStatus: {\n        audioMuted: !0,\n        videoMuted: !0\n      }\n    },\n        usePeerId = self._hasMCU ? \"MCU\" : peerId;\n    if (!self._peerInformations[usePeerId]) return customSettings;\n\n    if (self._peerConnections[usePeerId] && self._peerConnections[usePeerId].signalingState !== self.PEER_CONNECTION_STATE.CLOSED) {\n      var stream = self._peerConnections[peerId].localStream,\n          streamId = self._peerConnections[peerId].localStreamId || stream && (stream.id || stream.label);\n\n      if (customSettings.settings.data = self._initOptions.enableDataChannel && self._peerInformations[peerId].config.enableDataChannel, stream && (self._streams.screenshare && self._streams.screenshare.stream && streamId === (self._streams.screenshare.stream.id || self._streams.screenshare.stream.label) ? (customSettings.settings.audio = clone(self._streams.screenshare.settings.audio), customSettings.settings.video = clone(self._streams.screenshare.settings.video), customSettings.mediaStatus = clone(self._streamsMutedSettings)) : self._streams.userMedia && self._streams.userMedia.stream && streamId === (self._streams.userMedia.stream.id || self._streams.userMedia.stream.label) && (customSettings.settings.audio = clone(self._streams.userMedia.settings.audio), customSettings.settings.video = clone(self._streams.userMedia.settings.video), customSettings.mediaStatus = clone(self._streamsMutedSettings)), !(\"function\" != typeof self._peerConnections[peerId].getSenders || self._initOptions.useEdgeWebRTC && window.msRTCPeerConnection))) {\n        for (var senders = self._peerConnections[peerId].getSenders(), hasSendAudio = !1, hasSendVideo = !1, i = 0; i < senders.length; i++) {\n          senders[i] && senders[i].track && senders[i].track.kind && (\"audio\" === senders[i].track.kind ? hasSendAudio = !0 : \"video\" === senders[i].track.kind && (hasSendVideo = !0));\n        }\n\n        hasSendAudio || (customSettings.settings.audio = !1, customSettings.mediaStatus.audioMuted = !0), hasSendVideo || (customSettings.settings.video = !1, customSettings.mediaStatus.videoMuted = !0);\n      }\n    }\n\n    return self._peerCustomConfigs[usePeerId] && (self._peerCustomConfigs[usePeerId].bandwidth && \"object\" == typeof self._peerCustomConfigs[usePeerId].bandwidth && (\"number\" == typeof self._peerCustomConfigs[usePeerId].bandwidth.audio && (customSettings.settings.bandwidth.audio = self._peerCustomConfigs[usePeerId].bandwidth.audio), \"number\" == typeof self._peerCustomConfigs[usePeerId].bandwidth.video && (customSettings.settings.bandwidth.video = self._peerCustomConfigs[usePeerId].bandwidth.video), \"number\" == typeof self._peerCustomConfigs[usePeerId].bandwidth.data && (customSettings.settings.bandwidth.data = self._peerCustomConfigs[usePeerId].bandwidth.data)), self._peerCustomConfigs[usePeerId].googleXBandwidth && \"object\" == typeof self._peerCustomConfigs[usePeerId].googleXBandwidth && (\"number\" == typeof self._peerCustomConfigs[usePeerId].googleXBandwidth.min && (customSettings.settings.googleXBandwidth.min = self._peerCustomConfigs[usePeerId].googleXBandwidth.min), \"number\" == typeof self._peerCustomConfigs[usePeerId].googleXBandwidth.max && (customSettings.settings.googleXBandwidth.max = self._peerCustomConfigs[usePeerId].googleXBandwidth.max))), self._sdpSessions[usePeerId] && self._sdpSessions[usePeerId].local && self._sdpSessions[usePeerId].local.connection && \"object\" == typeof self._sdpSessions[usePeerId].local.connection && (self._sdpSessions[usePeerId].local.connection.audio && self._sdpSessions[usePeerId].local.connection.audio.indexOf(\"send\") > -1 || (customSettings.settings.audio = !1, customSettings.mediaStatus.audioMuted = !0), self._sdpSessions[usePeerId].local.connection.video && self._sdpSessions[usePeerId].local.connection.video.indexOf(\"send\") > -1 || (customSettings.settings.video = !1, customSettings.mediaStatus.videoMuted = !0), self._sdpSessions[usePeerId].local.connection.data && self._sdpSessions[usePeerId].local.connection.data.indexOf(\"send\") > -1 || (customSettings.settings.data = !1)), customSettings;\n  }, Skylink.prototype._getUserInfo = function (peerId) {\n    var userInfo = clone(this.getPeerInfo()),\n        userCustomInfoForPeer = peerId ? this._getPeerCustomSettings(peerId) : null;\n    return userCustomInfoForPeer && \"object\" == typeof userCustomInfoForPeer && (userInfo.settings = userCustomInfoForPeer.settings, userInfo.mediaStatus = userCustomInfoForPeer.mediaStatus), userInfo.settings.video && \"object\" == typeof userInfo.settings.video && (userInfo.settings.video.customSettings = {}, userInfo.settings.video.frameRate && \"object\" == typeof userInfo.settings.video.frameRate && (userInfo.settings.video.customSettings.frameRate = clone(userInfo.settings.video.frameRate), userInfo.settings.video.frameRate = -1), userInfo.settings.video.facingMode && \"object\" == typeof userInfo.settings.video.facingMode && (userInfo.settings.video.customSettings.facingMode = clone(userInfo.settings.video.facingMode), userInfo.settings.video.facingMode = \"-1\"), userInfo.settings.video.resolution && \"object\" == typeof userInfo.settings.video.resolution && (userInfo.settings.video.resolution.width && \"object\" == typeof userInfo.settings.video.resolution.width && (userInfo.settings.video.customSettings.width = clone(userInfo.settings.video.width), userInfo.settings.video.resolution.width = -1), userInfo.settings.video.resolution.height && \"object\" == typeof userInfo.settings.video.resolution.height && (userInfo.settings.video.customSettings.height = clone(userInfo.settings.video.height), userInfo.settings.video.resolution.height = -1))), userInfo.settings.bandwidth && (userInfo.settings.maxBandwidth = clone(userInfo.settings.bandwidth), delete userInfo.settings.bandwidth), this._getSDPCommonSupports(peerId).video || (userInfo.settings.video = !1, userInfo.mediaStatus.videoMuted = !0), this._getSDPCommonSupports(peerId).audio || (userInfo.settings.audio = !1, userInfo.mediaStatus.audioMuted = !0), delete userInfo.agent, delete userInfo.room, delete userInfo.config, delete userInfo.parentId, delete userInfo.settings.data, userInfo;\n  }, Skylink.prototype._doOffer = function (targetMid, iceRestart) {\n    var self = this,\n        pc = self._peerConnections[targetMid];\n    if (!pc) return void log.warn([targetMid, \"RTCSessionDescription\", \"offer\", \"Dropping of creating of offer as connection does not exists\"]);\n    if (pc.signalingState !== self.PEER_CONNECTION_STATE.STABLE) return void log.warn([targetMid, \"RTCSessionDescription\", \"offer\", 'Dropping of creating of offer as signalingState is not \"' + self.PEER_CONNECTION_STATE.STABLE + '\" ->'], pc.signalingState);\n    var offerConstraints = {\n      offerToReceiveAudio: !(!self._sdpSettings.connection.audio && \"MCU\" !== targetMid) && self._getSDPCommonSupports(targetMid).video,\n      offerToReceiveVideo: !(!self._sdpSettings.connection.video && \"MCU\" !== targetMid) && self._getSDPCommonSupports(targetMid).audio,\n      iceRestart: !!((self._peerInformations[targetMid] || {}).config || {}).enableIceRestart && iceRestart && self._enableIceRestart,\n      voiceActivityDetection: self._voiceActivityDetection\n    };\n    self._hasMCU && \"MCU\" !== targetMid || self._addLocalMediaStreams(targetMid), self._initOptions.enableDataChannel && self._peerInformations[targetMid] && self._peerInformations[targetMid].config.enableDataChannel && (self._dataChannels[targetMid] && self._dataChannels[targetMid].main || (self._createDataChannel(targetMid), self._peerConnections[targetMid].hasMainChannel = !0)), log.debug([targetMid, null, null, \"Creating offer with config:\"], offerConstraints), pc.endOfCandidates = !1, self._peerConnStatus[targetMid] && (self._peerConnStatus[targetMid].sdpConstraints = offerConstraints);\n\n    var onSuccessCbFn = function onSuccessCbFn(offer) {\n      log.debug([targetMid, null, null, \"Created offer\"], offer), self._handleNegotiationStats(\"create_offer\", targetMid, offer, !1), self._setLocalAndSendMessage(targetMid, offer);\n    },\n        onErrorCbFn = function onErrorCbFn(error) {\n      log.error([targetMid, null, null, \"Failed creating an offer:\"], error), self._handleNegotiationStats(\"error_create_offer\", targetMid, null, !1, error), self._trigger(\"handshakeProgress\", self.HANDSHAKE_PROGRESS.ERROR, targetMid, error);\n    };\n\n    pc.createOffer(onSuccessCbFn, onErrorCbFn, \"plugin\" === AdapterJS.webrtcDetectedType ? {\n      mandatory: {\n        OfferToReceiveAudio: offerConstraints.offerToReceiveAudio,\n        OfferToReceiveVideo: offerConstraints.offerToReceiveVideo,\n        iceRestart: offerConstraints.iceRestart,\n        voiceActivityDetection: offerConstraints.voiceActivityDetection\n      }\n    } : offerConstraints);\n  }, Skylink.prototype._doAnswer = function (targetMid) {\n    var self = this;\n    log.log([targetMid, null, null, \"Creating answer with config:\"], self._room.connection.sdpConstraints);\n    var pc = self._peerConnections[targetMid];\n    if (!pc) return void log.warn([targetMid, \"RTCSessionDescription\", \"answer\", \"Dropping of creating of answer as connection does not exists\"]);\n    if (pc.signalingState !== self.PEER_CONNECTION_STATE.HAVE_REMOTE_OFFER) return void log.warn([targetMid, \"RTCSessionDescription\", \"answer\", 'Dropping of creating of answer as signalingState is not \"' + self.PEER_CONNECTION_STATE.HAVE_REMOTE_OFFER + '\" ->'], pc.signalingState);\n    var answerConstraints = \"edge\" === AdapterJS.webrtcDetectedBrowser ? {\n      offerToReceiveVideo: !(!self._sdpSettings.connection.audio && \"MCU\" !== targetMid) && self._getSDPCommonSupports(targetMid, pc.remoteDescription).video,\n      offerToReceiveAudio: !(!self._sdpSettings.connection.video && \"MCU\" !== targetMid) && self._getSDPCommonSupports(targetMid, pc.remoteDescription).audio,\n      voiceActivityDetection: self._voiceActivityDetection\n    } : void 0;\n    self._hasMCU && \"MCU\" !== targetMid || self._addLocalMediaStreams(targetMid), self._peerConnStatus[targetMid] && (self._peerConnStatus[targetMid].sdpConstraints = answerConstraints);\n\n    var onSuccessCbFn = function onSuccessCbFn(answer) {\n      log.debug([targetMid, null, null, \"Created answer\"], answer), self._handleNegotiationStats(\"create_answer\", targetMid, answer, !1), self._setLocalAndSendMessage(targetMid, answer);\n    },\n        onErrorCbFn = function onErrorCbFn(error) {\n      log.error([targetMid, null, null, \"Failed creating an answer:\"], error), self._handleNegotiationStats(\"error_create_answer\", targetMid, null, !1, error), self._trigger(\"handshakeProgress\", self.HANDSHAKE_PROGRESS.ERROR, targetMid, error);\n    };\n\n    pc.createAnswer(onSuccessCbFn, onErrorCbFn, answerConstraints);\n  }, Skylink.prototype._setLocalAndSendMessage = function (targetMid, _sessionDescription) {\n    var self = this,\n        pc = self._peerConnections[targetMid];\n    if (!_sessionDescription || !_sessionDescription.sdp) return void log.warn([targetMid, \"RTCSessionDescription\", null, \"Local session description is undefined ->\"], _sessionDescription);\n    if (!pc) return log.warn([targetMid, \"RTCSessionDescription\", _sessionDescription.type, \"Local session description will not be set as connection does not exists ->\"], _sessionDescription), void self._handleNegotiationStats(\"dropped_\" + sessionDescription.type, targetMid, sessionDescription, !1, \"Peer connection does not exists\");\n    if (_sessionDescription.type === self.HANDSHAKE_PROGRESS.OFFER && pc.signalingState !== self.PEER_CONNECTION_STATE.STABLE) return log.warn([targetMid, \"RTCSessionDescription\", _sessionDescription.type, 'Local session description will not be set as signaling state is \"' + pc.signalingState + '\" ->'], _sessionDescription), void self._handleNegotiationStats(\"dropped_offer\", targetMid, sessionDescription, !1, 'Peer connection state is \"' + pc.signalingState + '\"');\n    if (_sessionDescription.type === self.HANDSHAKE_PROGRESS.ANSWER && pc.signalingState !== self.PEER_CONNECTION_STATE.HAVE_REMOTE_OFFER) return log.warn([targetMid, \"RTCSessionDescription\", _sessionDescription.type, 'Local session description will not be set as signaling state is \"' + pc.signalingState + '\" ->'], _sessionDescription), void self._handleNegotiationStats(\"dropped_answer\", targetMid, sessionDescription, !1, 'Peer connection state is \"' + pc.signalingState + '\"');\n    if (pc.processingLocalSDP) return log.warn([targetMid, \"RTCSessionDescription\", _sessionDescription.type, \"Local session description will not be set as another is being processed ->\"], _sessionDescription), void self._handleNegotiationStats(\"dropped_\" + sessionDescription.type, targetMid, sessionDescription, !1, \"Peer connection is currently processing an existing sdp\");\n    pc.processingLocalSDP = !0;\n    var sessionDescription = {\n      type: _sessionDescription.type,\n      sdp: _sessionDescription.sdp\n    };\n    sessionDescription.sdp = self._removeSDPFirefoxH264Pref(targetMid, sessionDescription), sessionDescription.sdp = self._setSDPCodecParams(targetMid, sessionDescription), sessionDescription.sdp = self._removeSDPUnknownAptRtx(targetMid, sessionDescription), sessionDescription.sdp = self._removeSDPCodecs(targetMid, sessionDescription), sessionDescription.sdp = self._handleSDPConnectionSettings(targetMid, sessionDescription, \"local\"), sessionDescription.sdp = self._removeSDPREMBPackets(targetMid, sessionDescription), sessionDescription.sdp = self._setSCTPport(targetMid, sessionDescription), self._peerConnectionConfig.disableBundle && (sessionDescription.sdp = sessionDescription.sdp.replace(/a=group:BUNDLE.*\\r\\n/gi, \"\")), log.log([targetMid, \"RTCSessionDescription\", sessionDescription.type, \"Local session description updated ->\"], sessionDescription.sdp);\n\n    var onSuccessCbFn = function onSuccessCbFn() {\n      if (log.debug([targetMid, \"RTCSessionDescription\", sessionDescription.type, \"Local session description has been set ->\"], sessionDescription), pc.processingLocalSDP = !1, self._handleNegotiationStats(\"set_\" + sessionDescription.type, targetMid, sessionDescription, !1), self._trigger(\"handshakeProgress\", sessionDescription.type, targetMid), sessionDescription.type === self.HANDSHAKE_PROGRESS.ANSWER ? pc.setAnswer = \"local\" : pc.setOffer = \"local\", !self._initOptions.enableIceTrickle && !pc.gathered) return void log.log([targetMid, \"RTCSessionDescription\", sessionDescription.type, \"Local session description sending is halted to complete ICE gathering.\"]);\n      self._sendChannelMessage({\n        type: sessionDescription.type,\n        sdp: self._renderSDPOutput(targetMid, sessionDescription),\n        mid: self._user.sid,\n        target: targetMid,\n        rid: self._room.id,\n        userInfo: self._getUserInfo(targetMid)\n      }), self._handleNegotiationStats(sessionDescription.type, targetMid, sessionDescription, !1);\n    },\n        onErrorCbFn = function onErrorCbFn(error) {\n      log.error([targetMid, \"RTCSessionDescription\", sessionDescription.type, \"Local description failed setting ->\"], error), pc.processingLocalSDP = !1, self._handleNegotiationStats(\"error_set_\" + sessionDescription.type, targetMid, sessionDescription, !1, error), self._trigger(\"handshakeProgress\", self.HANDSHAKE_PROGRESS.ERROR, targetMid, error);\n    };\n\n    pc.setLocalDescription(new RTCSessionDescription(sessionDescription), onSuccessCbFn, onErrorCbFn);\n  }, Skylink.prototype.getPeers = function (showAll, callback) {\n    var self = this;\n    return self._isPrivileged ? self._initOptions.appKey ? (\"function\" == typeof showAll && (callback = showAll, showAll = !1), self._sendChannelMessage({\n      type: self._SIG_MESSAGE_TYPE.GET_PEERS,\n      showAll: showAll || !1\n    }), self._trigger(\"getPeersStateChange\", self.GET_PEERS_STATE.ENQUIRED, self._user.sid, null), log.log(\"Enquired server for peers within the realm\"), void (\"function\" == typeof callback && self.once(\"getPeersStateChange\", function (state, privilegedPeerId, peerList) {\n      callback(null, peerList);\n    }, function (state, privilegedPeerId, peerList) {\n      return state === self.GET_PEERS_STATE.RECEIVED;\n    }))) : void log.warn(\"App key is not defined. Please authenticate again.\") : void log.warn(\"Please upgrade your key to privileged to use this function\");\n  }, Skylink.prototype.introducePeer = function (sendingPeerId, receivingPeerId) {\n    var self = this;\n    if (!self._isPrivileged) return log.warn(\"Please upgrade your key to privileged to use this function\"), void self._trigger(\"introduceStateChange\", self.INTRODUCE_STATE.ERROR, self._user.sid, sendingPeerId, receivingPeerId, \"notPrivileged\");\n    var introduceMsg = {\n      type: self._SIG_MESSAGE_TYPE.INTRODUCE,\n      sendingPeerId: sendingPeerId,\n      receivingPeerId: receivingPeerId\n    };\n    self._sendChannelMessage(introduceMsg), self._handleSessionStats(introduceMsg), self._trigger(\"introduceStateChange\", self.INTRODUCE_STATE.INTRODUCING, self._user.sid, sendingPeerId, receivingPeerId, null), log.log(\"Introducing\", sendingPeerId, \"to\", receivingPeerId);\n  }, Skylink.prototype.joinRoom = function (room, options, callback) {\n    var self = this,\n        selectedRoom = self._initOptions.defaultRoom,\n        previousRoom = self._selectedRoom,\n        mediaOptions = {},\n        timestamp = new Date().getTime() + Math.floor(1e4 * Math.random());\n    self._joinRoomManager.timestamp = timestamp, room && \"string\" == typeof room ? selectedRoom = room : room && \"object\" == typeof room ? mediaOptions = room : \"function\" == typeof room && (callback = room), options && \"object\" == typeof options ? mediaOptions = options : \"function\" == typeof options && (callback = options);\n\n    var resolveAsErrorFn = function resolveAsErrorFn(error, tryRoom, readyState) {\n      log.error(error), \"function\" == typeof callback && callback({\n        room: tryRoom,\n        errorCode: readyState || null,\n        error: error instanceof Error ? error : new Error(JSON.stringify(error))\n      });\n    },\n        resolveAsWarningFn = function resolveAsWarningFn(error, tryRoom) {\n      log.warn(error + \" room: \" + tryRoom);\n    },\n        joinRoomFn = function joinRoomFn() {\n      if (self._joinRoomManager.timestamp !== timestamp) return void resolveAsWarningFn(\"joinRoom() process did not complete\", selectedRoom);\n\n      self._initSelectedRoom(selectedRoom, function (initError, initSuccess) {\n        return initError ? void resolveAsErrorFn(initError.error, self._selectedRoom, self._readyState) : self._joinRoomManager.timestamp !== timestamp ? void resolveAsWarningFn(\"joinRoom() process did not complete\", selectedRoom) : void self._waitForOpenChannel(mediaOptions || {}, timestamp, function (error, success) {\n          if (error) return void resolveAsErrorFn(error, self._selectedRoom, self._readyState);\n          if (self._joinRoomManager.timestamp !== timestamp) return void resolveAsWarningFn(\"joinRoom() process did not complete\", selectedRoom);\n\n          if (\"AppleWebKit\" === AdapterJS.webrtcDetectedType) {\n            var checkStream = self._streams.screenshare && self._streams.screenshare.stream ? self._streams.screenshare.stream : self._streams.userMedia && self._streams.userMedia.stream ? self._streams.userMedia.stream : null;\n            checkStream && 0 !== checkStream.getTracks().length ? 0 === checkStream.getAudioTracks().length ? log.warn(\"Note that receiving audio streams may fail as safari 11 needs stream with audio and video tracks and not just with video tracks\") : 0 === checkStream.getVideoTracks().length && log.warn(\"Note that receiving video streams may fail as safari 11 needs stream with audio and video tracks and not just with audio tracks\") : log.warn(\"Note that receiving audio and video streams may fail as safari 11 needs stream with audio and video tracks\");\n          }\n\n          if (\"function\" == typeof callback) {\n            var peerOnJoin = function peerOnJoin(peerId, peerInfo, isSelf) {\n              self.off(\"systemAction\", peerFailedJoin), self.off(\"channelClose\", peerSocketFailedJoin), log.info([null, \"Room\", selectedRoom, \"Connected to Room ->\"], peerInfo), callback(null, {\n                room: self._selectedRoom,\n                peerId: peerId,\n                peerInfo: peerInfo\n              });\n            },\n                peerFailedJoin = function peerFailedJoin(action, message) {\n              self.off(\"peerJoined\", peerOnJoin), self.off(\"channelClose\", peerSocketFailedJoin), log.error([null, \"Room\", selectedRoom, \"Failed connecting to Room ->\"], message), resolveAsErrorFn(new Error(message), self._selectedRoom, self._readyState);\n            },\n                peerSocketFailedJoin = function peerSocketFailedJoin() {\n              self.off(\"systemAction\", peerFailedJoin), self.off(\"peerJoined\", peerOnJoin), log.error([null, \"Room\", selectedRoom, \"Failed connecting to Room due to abrupt disconnection.\"]), resolveAsErrorFn(new Error(\"Channel closed abruptly before session was established\"), self._selectedRoom, self._readyState);\n            };\n\n            self.once(\"peerJoined\", peerOnJoin, function (peerId, peerInfo, isSelf) {\n              return peerInfo.room === selectedRoom && isSelf;\n            }), self.once(\"systemAction\", peerFailedJoin, function (action) {\n              return action === self.SYSTEM_ACTION.REJECT;\n            }), self.once(\"channelClose\", peerSocketFailedJoin);\n          }\n\n          var joinRoomMsg = {\n            type: self._SIG_MESSAGE_TYPE.JOIN_ROOM,\n            uid: self._user.uid,\n            cid: self._key,\n            rid: self._room.id,\n            userCred: self._user.token,\n            timeStamp: self._user.timeStamp,\n            apiOwner: self._appKeyOwner,\n            roomCred: self._room.token,\n            start: self._room.startDateTime,\n            len: self._room.duration,\n            isPrivileged: !0 === self._isPrivileged,\n            autoIntroduce: !1 !== self._autoIntroduce,\n            key: self._initOptions.appKey\n          };\n          self._sendChannelMessage(joinRoomMsg), self._handleSessionStats(joinRoomMsg);\n        });\n      });\n    };\n\n    if (null === room || [\"number\", \"boolean\"].indexOf(typeof room) > -1) return void resolveAsErrorFn(\"Invalid room name is provided\", room);\n    if (null === options || [\"number\", \"boolean\"].indexOf(typeof options) > -1) return void resolveAsErrorFn(\"Invalid mediaOptions is provided\", selectedRoom);\n    self._joinRoomManager.socketsFn.forEach(function (fnItem) {\n      fnItem(timestamp);\n    }), self._joinRoomManager.socketsFn = [];\n    var stopStream = !1 === mediaOptions.audio && !1 === mediaOptions.video;\n    self._inRoom ? self.leaveRoom({\n      userMedia: stopStream\n    }, function (lRError, lRSuccess) {\n      log.debug([null, \"Room\", previousRoom, \"Leave Room callback result ->\"], [lRError, lRSuccess]), joinRoomFn();\n    }) : (stopStream && self.stopStream(), joinRoomFn());\n  }, Skylink.prototype.leaveRoom = function (stopMediaOptions, callback) {\n    var self = this,\n        stopUserMedia = !0,\n        stopScreenshare = !0,\n        previousRoom = self._selectedRoom,\n        previousUserPeerId = self._user ? self._user.sid : null,\n        peersThatLeft = [],\n        isNotInRoom = !self._inRoom;\n    \"boolean\" == typeof stopMediaOptions ? !1 === stopMediaOptions && (stopUserMedia = !1, stopScreenshare = !1) : stopMediaOptions && \"object\" == typeof stopMediaOptions ? (stopUserMedia = !1 !== stopMediaOptions.userMedia, stopScreenshare = !1 !== stopMediaOptions.screenshare) : \"function\" == typeof stopMediaOptions && (callback = stopMediaOptions);\n\n    for (var infoPeerId in self._peerInformations) {\n      self._peerInformations.hasOwnProperty(infoPeerId) && self._peerInformations[infoPeerId] && (peersThatLeft.push(infoPeerId), self._removePeer(infoPeerId));\n    }\n\n    for (var connPeerId in self._peerConnections) {\n      self._peerConnections.hasOwnProperty(connPeerId) && self._peerConnections[connPeerId] && -1 === peersThatLeft.indexOf(connPeerId) && (peersThatLeft.push(connPeerId), self._removePeer(connPeerId));\n    }\n\n    if (self._inRoom = !1, self._closeChannel(), isNotInRoom) {\n      var notInRoomError = \"Unable to leave room as user is not in any room\";\n      return log.error([null, \"Room\", previousRoom, notInRoomError]), void (\"function\" == typeof callback && callback(new Error(notInRoomError), null));\n    }\n\n    self._stopStreams({\n      userMedia: stopUserMedia,\n      screenshare: stopScreenshare\n    }), self._wait(function () {\n      log.log([null, \"Room\", previousRoom, \"User left the room\"]), self._trigger(\"peerLeft\", previousUserPeerId, self.getPeerInfo(), !0), \"function\" == typeof callback && callback(null, {\n        peerId: previousUserPeerId,\n        previousRoom: previousRoom\n      });\n    }, function () {\n      return !self._channelOpen;\n    });\n  }, Skylink.prototype.lockRoom = function () {\n    this._user && this._user.sid && (log.log(\"Update to isRoomLocked status ->\", !0), this._sendChannelMessage({\n      type: this._SIG_MESSAGE_TYPE.ROOM_LOCK,\n      mid: this._user.sid,\n      rid: this._room.id,\n      lock: !0\n    }), this._roomLocked = !0, this._trigger(\"roomLock\", !0, this._user.sid, this.getPeerInfo(), !0));\n  }, Skylink.prototype.unlockRoom = function () {\n    this._user && this._user.sid && (log.log(\"Update to isRoomLocked status ->\", !1), this._sendChannelMessage({\n      type: this._SIG_MESSAGE_TYPE.ROOM_LOCK,\n      mid: this._user.sid,\n      rid: this._room.id,\n      lock: !1\n    }), this._roomLocked = !1, this._trigger(\"roomLock\", !1, this._user.sid, this.getPeerInfo(), !0));\n  }, Skylink.prototype._waitForOpenChannel = function (mediaOptions, joinRoomTimestamp, callback) {\n    var self = this;\n    self._socketCurrentReconnectionAttempt = 0, self._wait(function () {\n      var onChannelOpen = function onChannelOpen() {\n        self.off(\"socketError\", onChannelError), setTimeout(function () {\n          if (mediaOptions = mediaOptions || {}, self._userData = mediaOptions.userData || self._userData || \"\", self._streamsBandwidthSettings = {\n            googleX: {},\n            bAS: {}\n          }, self._publishOnly = !1, self._sdpSettings = {\n            connection: {\n              audio: !0,\n              video: !0,\n              data: !0\n            },\n            direction: {\n              audio: {\n                send: !0,\n                receive: !0\n              },\n              video: {\n                send: !0,\n                receive: !0\n              }\n            }\n          }, self._voiceActivityDetection = \"boolean\" != typeof mediaOptions.voiceActivityDetection || mediaOptions.voiceActivityDetection, self._peerConnectionConfig = {\n            bundlePolicy: self.BUNDLE_POLICY.BALANCED,\n            rtcpMuxPolicy: self.RTCP_MUX_POLICY.REQUIRE,\n            iceCandidatePoolSize: 0,\n            certificate: self.PEER_CERTIFICATE.AUTO,\n            disableBundle: !1\n          }, self._bandwidthAdjuster = null, mediaOptions.bandwidth && (\"number\" == typeof mediaOptions.bandwidth.audio && (self._streamsBandwidthSettings.bAS.audio = mediaOptions.bandwidth.audio), \"number\" == typeof mediaOptions.bandwidth.video && (self._streamsBandwidthSettings.bAS.video = mediaOptions.bandwidth.video), \"number\" == typeof mediaOptions.bandwidth.data && (self._streamsBandwidthSettings.bAS.data = mediaOptions.bandwidth.data)), mediaOptions.googleXBandwidth && (\"number\" == typeof mediaOptions.googleXBandwidth.min && (self._streamsBandwidthSettings.googleX.min = mediaOptions.googleXBandwidth.min), \"number\" == typeof mediaOptions.googleXBandwidth.max && (self._streamsBandwidthSettings.googleX.max = mediaOptions.googleXBandwidth.max)), mediaOptions.sdpSettings && (mediaOptions.sdpSettings.direction && (mediaOptions.sdpSettings.direction.audio && (self._sdpSettings.direction.audio.receive = \"boolean\" != typeof mediaOptions.sdpSettings.direction.audio.receive || mediaOptions.sdpSettings.direction.audio.receive, self._sdpSettings.direction.audio.send = \"boolean\" != typeof mediaOptions.sdpSettings.direction.audio.send || mediaOptions.sdpSettings.direction.audio.send), mediaOptions.sdpSettings.direction.video && (self._sdpSettings.direction.video.receive = \"boolean\" != typeof mediaOptions.sdpSettings.direction.video.receive || mediaOptions.sdpSettings.direction.video.receive, self._sdpSettings.direction.video.send = \"boolean\" != typeof mediaOptions.sdpSettings.direction.video.send || mediaOptions.sdpSettings.direction.video.send)), mediaOptions.sdpSettings.connection && (self._sdpSettings.connection.audio = \"boolean\" != typeof mediaOptions.sdpSettings.connection.audio || mediaOptions.sdpSettings.connection.audio, self._sdpSettings.connection.video = \"boolean\" != typeof mediaOptions.sdpSettings.connection.video || mediaOptions.sdpSettings.connection.video, self._sdpSettings.connection.data = \"boolean\" != typeof mediaOptions.sdpSettings.connection.data || mediaOptions.sdpSettings.connection.data)), mediaOptions.publishOnly && (self._sdpSettings.direction.audio.send = !0, self._sdpSettings.direction.audio.receive = !1, self._sdpSettings.direction.video.send = !0, self._sdpSettings.direction.video.receive = !1, self._publishOnly = !0, \"object\" == typeof mediaOptions.publishOnly && mediaOptions.publishOnly.parentId && \"string\" == typeof mediaOptions.publishOnly.parentId && (self._parentId = mediaOptions.publishOnly.parentId)), mediaOptions.parentId && (self._parentId = mediaOptions.parentId), mediaOptions.peerConnection && \"object\" == typeof mediaOptions.peerConnection) {\n            if (\"string\" == typeof mediaOptions.peerConnection.bundlePolicy) for (var bpProp in self.BUNDLE_POLICY) {\n              self.BUNDLE_POLICY.hasOwnProperty(bpProp) && self.BUNDLE_POLICY[bpProp] === mediaOptions.peerConnection.bundlePolicy && (self._peerConnectionConfig.bundlePolicy = mediaOptions.peerConnection.bundlePolicy);\n            }\n            if (\"string\" == typeof mediaOptions.peerConnection.rtcpMuxPolicy) for (var rmpProp in self.RTCP_MUX_POLICY) {\n              self.RTCP_MUX_POLICY.hasOwnProperty(rmpProp) && self.RTCP_MUX_POLICY[rmpProp] === mediaOptions.peerConnection.rtcpMuxPolicy && (self._peerConnectionConfig.rtcpMuxPolicy = mediaOptions.peerConnection.rtcpMuxPolicy);\n            }\n            if (\"number\" == typeof mediaOptions.peerConnection.iceCandidatePoolSize && mediaOptions.peerConnection.iceCandidatePoolSize > 0 && (self._peerConnectionConfig.iceCandidatePoolSize = mediaOptions.peerConnection.iceCandidatePoolSize), \"string\" == typeof mediaOptions.peerConnection.certificate) for (var pcProp in self.PEER_CERTIFICATE) {\n              self.PEER_CERTIFICATE.hasOwnProperty(pcProp) && self.PEER_CERTIFICATE[pcProp] === mediaOptions.peerConnection.certificate && (self._peerConnectionConfig.certificate = mediaOptions.peerConnection.certificate);\n            }\n            self._peerConnectionConfig.disableBundle = !0 === mediaOptions.peerConnection.disableBundle;\n          }\n\n          if (mediaOptions.autoBandwidthAdjustment && (self._bandwidthAdjuster = {\n            interval: 10,\n            limitAtPercentage: 100,\n            useUploadBwOnly: !1\n          }, \"object\" == typeof mediaOptions.autoBandwidthAdjustment && (\"number\" == typeof mediaOptions.autoBandwidthAdjustment.interval && mediaOptions.autoBandwidthAdjustment.interval >= 10 && (self._bandwidthAdjuster.interval = mediaOptions.autoBandwidthAdjustment.interval), \"number\" == typeof mediaOptions.autoBandwidthAdjustment.limitAtPercentage && mediaOptions.autoBandwidthAdjustment.limitAtPercentage >= 0 && mediaOptions.autoBandwidthAdjustment.limitAtPercentage <= 100 && (self._bandwidthAdjuster.limitAtPercentage = mediaOptions.autoBandwidthAdjustment.limitAtPercentage), \"boolean\" == typeof mediaOptions.autoBandwidthAdjustment.useUploadBwOnly && (self._bandwidthAdjuster.useUploadBwOnly = mediaOptions.autoBandwidthAdjustment.useUploadBwOnly))), !0 === mediaOptions.manualGetUserMedia) {\n            self._trigger(\"mediaAccessRequired\");\n\n            var current50Block = 0,\n                mediaAccessRequiredFailure = !1;\n            return void self._wait(function () {\n              !0 === mediaAccessRequiredFailure ? self._onUserMediaError(new Error(\"Waiting for stream timeout\"), !1, !1) : callback(null, self._streams.userMedia.stream);\n            }, function () {\n              return current50Block += 1, 600 === current50Block ? (mediaAccessRequiredFailure = !0, !0) : !(!self._streams.userMedia || !self._streams.userMedia.stream) || void 0;\n            }, 50);\n          }\n\n          if (mediaOptions.audio || mediaOptions.video) return void self.getUserMedia({\n            useExactConstraints: !!mediaOptions.useExactConstraints,\n            audio: mediaOptions.audio,\n            video: mediaOptions.video\n          }, function (error, success) {\n            error ? callback(error, null) : callback(null, success);\n          });\n          callback(null, null);\n        }, 1);\n      },\n          onChannelError = function onChannelError(errorState, error) {\n        self.off(\"channelOpen\", onChannelOpen), callback(error);\n      };\n\n      self._channelOpen ? onChannelOpen() : (self.once(\"channelOpen\", onChannelOpen), self.once(\"socketError\", onChannelError, function (errorState) {\n        return errorState === self.SOCKET_ERROR.RECONNECTION_ABORTED;\n      }), self._openChannel(joinRoomTimestamp));\n    }, function () {\n      return self._readyState === self.READY_STATE_CHANGE.COMPLETED;\n    });\n  }, Skylink.prototype.generateUUID = function () {\n    var d = new Date().getTime();\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n      var r = (d + 16 * Math.random()) % 16 | 0;\n      return d = Math.floor(d / 16), (\"x\" === c ? r : r && 15).toString(16);\n    });\n  }, Skylink.prototype.init = function (_options, _callback) {\n    var self = this,\n        options = {},\n        callback = function callback() {};\n\n    if (\"function\" == typeof _options ? callback = _options : _options && \"object\" == typeof _options ? (options = clone(_options), options.appKey && \"string\" == typeof options.appKey || !options.apiKey || \"string\" != typeof options.apiKey || (options.appKey = options.apiKey)) : _options && \"string\" == typeof _options && (options.appKey = _options), \"function\" == typeof _callback && (callback = _callback), options.defaultRoom = options.defaultRoom && \"string\" == typeof options.defaultRoom ? options.defaultRoom : options.appKey, options.roomServer = options.roomServer && \"string\" == typeof options.roomServer ? options.roomServer : \"//api.temasys.io\", options.statsServer = options.statsServer && \"string\" == typeof options.statsServer ? options.statsServer : \"//api.temasys.io\", options.enableIceTrickle = !1 !== options.enableIceTrickle, options.enableDataChannel = !1 !== options.enableDataChannel, options.enableSTUNServer = !1 !== options.enableSTUNServer, options.enableTURNServer = !1 !== options.enableTURNServer, options.audioFallback = !0 === options.audioFallback, options.forceSSL = !1 !== options.forceSSL, options.enableStatsGathering = !1 !== options.enableStatsGathering, options.socketTimeout = \"number\" == typeof options.socketTimeout && options.socketTimeout >= 5e3 ? options.socketTimeout : 7e3, options.apiTimeout = \"number\" == typeof options.apiTimeout ? options.apiTimeout : 4e3, options.forceTURNSSL = !0 === options.forceTURNSSL, options.forceTURN = !0 === options.forceTURN, options.usePublicSTUN = !0 === options.usePublicSTUN, options.disableVideoFecCodecs = !0 === options.disableVideoFecCodecs, options.disableComfortNoiseCodec = !0 === options.disableComfortNoiseCodec, options.disableREMB = !0 === options.disableREMB, options.throttleShouldThrowError = !0 === options.throttleShouldThrowError, options.mcuUseRenegoRestart = !0 === options.mcuUseRenegoRestart, options.useEdgeWebRTC = !0 === options.useEdgeWebRTC, options.enableSimultaneousTransfers = !1 !== options.enableSimultaneousTransfers, options.priorityWeightScheme = self._containsInList(\"PRIORITY_WEIGHT_SCHEME\", options.priorityWeightScheme, \"AUTO\"), options.TURNServerTransport = self._containsInList(\"TURN_TRANSPORT\", options.TURNServerTransport, \"ANY\"), options.credentials = options.credentials && \"object\" == typeof options.credentials && options.credentials.startDateTime && \"string\" == typeof options.credentials.startDateTime && options.credentials.credentials && \"string\" == typeof options.credentials.credentials && \"number\" == typeof options.credentials.duration ? options.credentials : null, options.filterCandidatesType = options.filterCandidatesType && \"object\" == typeof options.filterCandidatesType ? options.filterCandidatesType : {}, options.filterCandidatesType.host = !0 === options.filterCandidatesType.host, options.filterCandidatesType.srflx = !0 === options.filterCandidatesType.srflx, options.filterCandidatesType.relay = !0 === options.filterCandidatesType.relay, options.throttleIntervals = options.throttleIntervals && \"object\" == typeof options.throttleIntervals ? options.throttleIntervals : {}, options.throttleIntervals.shareScreen = \"number\" == typeof options.throttleIntervals.shareScreen ? options.throttleIntervals.shareScreen : 1e4, options.throttleIntervals.refreshConnection = \"number\" == typeof options.throttleIntervals.refreshConnection ? options.throttleIntervals.refreshConnection : 5e3, options.throttleIntervals.getUserMedia = \"number\" == typeof options.throttleIntervals.getUserMedia ? options.throttleIntervals.getUserMedia : 0, options.iceServer && \"string\" == typeof options.iceServer ? options.iceServer = {\n      urls: [options.iceServer]\n    } : Array.isArray(options.iceServer) && options.iceServer.length > 0 ? options.iceServer = {\n      urls: options.iceServer\n    } : options.iceServer = null, options.socketServer && \"string\" == typeof options.socketServer ? options.socketServer = options.socketServer : options.socketServer && \"object\" == typeof options.socketServer && options.socketServer.url && \"string\" == typeof options.socketServer.url ? options.socketServer = {\n      url: options.socketServer.url,\n      ports: Array.isArray(options.socketServer.ports) ? options.socketServer.ports : [],\n      protocol: options.socketServer.protocol ? options.socketServer.protocol : null\n    } : options.socketServer = null, options.audioCodec && \"object\" == typeof options.audioCodec && self._containsInList(\"AUDIO_CODEC\", options.audioCodec.codec, \"-\") ? options.audioCodec = {\n      codec: options.audioCodec.codec,\n      samplingRate: \"number\" == typeof options.audioCodec.samplingRate ? options.audioCodec.samplingRate : null,\n      channels: \"number\" == typeof options.audioCodec.channels ? options.audioCodec.channels : null\n    } : options.audioCodec = self._containsInList(\"AUDIO_CODEC\", options.audioCodec, \"AUTO\"), options.videoCodec && \"object\" == typeof options.videoCodec && self._containsInList(\"VIDEO_CODEC\", options.videoCodec.codec, \"-\") ? options.videoCodec = {\n      codec: options.videoCodec.codec,\n      samplingRate: \"number\" == typeof options.videoCodec.samplingRate ? options.videoCodec.samplingRate : null\n    } : options.videoCodec = self._containsInList(\"VIDEO_CODEC\", options.videoCodec, \"AUTO\"), options.codecParams = options.codecParams && \"object\" == typeof options.codecParams ? options.codecParams : {}, options.codecParams.audio = options.codecParams.audio && \"object\" == typeof options.codecParams.audio ? options.codecParams.audio : {}, options.codecParams.video = options.codecParams.video && \"object\" == typeof options.codecParams.video ? options.codecParams.video : {}, options.codecParams.audio.opus = options.codecParams.audio.opus && \"object\" == typeof options.codecParams.audio.opus ? options.codecParams.audio.opus : {}, options.codecParams.audio.opus.stereo = \"boolean\" == typeof options.codecParams.audio.opus.stereo ? options.codecParams.audio.opus.stereo : null, options.codecParams.audio.opus[\"sprop-stereo\"] = \"boolean\" == typeof options.codecParams.audio.opus[\"sprop-stereo\"] ? options.codecParams.audio.opus[\"sprop-stereo\"] : null, options.codecParams.audio.opus.usedtx = \"boolean\" == typeof options.codecParams.audio.opus.usedtx ? options.codecParams.audio.opus.usedtx : null, options.codecParams.audio.opus.useinbandfec = \"boolean\" == typeof options.codecParams.audio.opus.useinbandfec ? options.codecParams.audio.opus.useinbandfec : null, options.codecParams.audio.opus.maxplaybackrate = \"number\" == typeof options.codecParams.audio.opus.maxplaybackrate && options.codecParams.audio.opus.maxplaybackrate >= 8e3 && options.codecParams.audio.opus.maxplaybackrate <= 48e3 ? options.codecParams.audio.opus.maxplaybackrate : null, options.codecParams.audio.opus.minptime = \"number\" == typeof options.codecParams.audio.opus.minptime && options.codecParams.audio.opus.minptime >= 3 ? options.codecParams.audio.opus.minptime : null, options.codecParams.video.h264 = options.codecParams.video.h264 && \"object\" == typeof options.codecParams.video.h264 ? options.codecParams.video.h264 : {}, options.codecParams.video.h264.profileLevelId = options.codecParams.video.h264.profileLevelId && \"string\" == typeof options.codecParams.video.h264.profileLevelId ? options.codecParams.video.h264.profileLevelId : null, options.codecParams.video.h264.levelAsymmetryAllowed = \"boolean\" == typeof options.codecParams.video.h264.levelAsymmetryAllowed ? options.codecParams.video.h264.levelAsymmetryAllowed : null, options.codecParams.video.h264.packetizationMode = \"boolean\" == typeof options.codecParams.video.h264.packetizationMode ? !0 === options.codecParams.video.h264.packetizationMode ? 1 : 0 : \"number\" == typeof options.codecParams.video.h264.packetizationMode ? options.codecParams.video.h264.packetizationMode : null, options.codecParams.video.vp8 = options.codecParams.video.vp8 && \"object\" == typeof options.codecParams.video.vp8 ? options.codecParams.video.vp8 : {}, options.codecParams.video.vp8.maxFs = \"number\" == typeof options.codecParams.video.vp8.maxFs ? options.codecParams.video.vp8.maxFs : null, options.codecParams.video.vp8.maxFr = \"number\" == typeof options.codecParams.video.vp8.maxFr ? options.codecParams.video.vp8.maxFr : null, options.codecParams.video.vp9 = options.codecParams.video.vp9 && \"object\" == typeof options.codecParams.video.vp9 ? options.codecParams.video.vp9 : {}, options.codecParams.video.vp9.maxFs = \"number\" == typeof options.codecParams.video.vp9.maxFs ? options.codecParams.video.vp9.maxFs : null, options.codecParams.video.vp9.maxFr = \"number\" == typeof options.codecParams.video.vp9.maxFr ? options.codecParams.video.vp9.maxFr : null, options.forceTURN && (options.enableTURNServer = !0, options.enableSTUNServer = !1, options.filterCandidatesType.host = !0, options.filterCandidatesType.srflx = !0, options.filterCandidatesType.relay = !1), self.once(\"readyStateChange\", function () {}, function (state, error) {\n      if (state === self.READY_STATE_CHANGE.ERROR) return log.error(\"Failed init() process ->\", error), callback({\n        error: error.content,\n        errorCode: error.errorCode,\n        status: error.status\n      }, null), !0;\n\n      if (state === self.READY_STATE_CHANGE.COMPLETED) {\n        log.info(\"Completed init() successfully ->\", options);\n        var success = clone(self._initOptions);\n        return success.serverUrl = self._path, success.readyState = self._readyState, success.selectedRoom = self._selectedRoom, success.TURNTransport = success.TURNServerTransport, callback(null, success), !0;\n      }\n    }), self._initOptions = options, self._readyState = self.READY_STATE_CHANGE.INIT, self._selectedRoom = self._initOptions.defaultRoom, self._trigger(\"readyStateChange\", self.READY_STATE_CHANGE.INIT, null, self._selectedRoom), !options || !options.appKey || \"string\" != typeof options.appKey) return self._readyState = self.READY_STATE_CHANGE.ERROR, void self._trigger(\"readyStateChange\", self.READY_STATE_CHANGE.ERROR, {\n      content: new Error(\"Please provide an app key\"),\n      errorCode: self.READY_STATE_CHANGE_ERROR.NO_PATH,\n      status: -2\n    }, self._selectedRoom);\n    self._setClientInfoForLogging(), self._path = self._initOptions.roomServer + \"/api/\" + self._initOptions.appKey + \"/\" + self._selectedRoom + (self._initOptions.credentials ? \"/\" + self._initOptions.credentials.startDateTime + \"/\" + self._initOptions.credentials.duration + \"?cred=\" + self._initOptions.credentials.credentials : \"\") + (self._initOptions.credentials ? \"&\" : \"?\") + \"rand=\" + Date.now(), self._loadInfo();\n  }, Skylink.prototype._containsInList = function (listName, value, defaultProperty) {\n    var self = this;\n\n    for (var property in self[listName]) {\n      if (self[listName].hasOwnProperty(property) && self[listName][property] === value) return value;\n    }\n\n    return self[listName][defaultProperty];\n  }, Skylink.prototype._requestServerInfo = function (method, url, callback, params) {\n    var self = this,\n        retries = 0;\n    self._socketUseXDR = \"function\" == typeof window.XDomainRequest || \"object\" == typeof window.XDomainRequest, url = self._initOptions.forceSSL ? \"https:\" + url : url, function requestFn() {\n      var xhr = new XMLHttpRequest(),\n          completed = !1;\n      self._socketUseXDR && (log.debug([null, \"XMLHttpRequest\", method, \"Using XDomainRequest for CORS authentication.\"]), xhr = new XDomainRequest(), xhr.setContentType = function (contentType) {\n        xhr.contentType = contentType;\n      }), xhr.onload = function () {\n        if (!completed) {\n          completed = !0;\n          var response = JSON.parse(xhr.responseText || xhr.response || \"{}\"),\n              status = xhr.status || (response.success ? 200 : 400);\n          if (self._handleAuthStats(response.success ? \"success\" : \"error\", response, status), response.success) return log.debug([null, \"XMLHttpRequest\", method, \"Received sessions parameters ->\"], response), void callback(response);\n          log.error([null, \"XMLHttpRequest\", method, \"Failed retrieving sessions parameters ->\"], response), self._readyState = self.READY_STATE_CHANGE.ERROR, self._trigger(\"readyStateChange\", self.READY_STATE_CHANGE.ERROR, {\n            status: status,\n            content: new Error(response.info || \"XMLHttpRequest status not OK\\nStatus was: \" + status),\n            errorCode: response.error || status\n          }, self._selectedRoom);\n        }\n      }, xhr.onerror = function (error) {\n        completed || (completed = !0, log.error([null, \"XMLHttpRequest\", method, \"Failed retrieving information with status ->\"], xhr.status), self._handleAuthStats(\"error\", null, -1, \"Failed connecting to server\"), self._readyState = self.READY_STATE_CHANGE.ERROR, self._trigger(\"readyStateChange\", self.READY_STATE_CHANGE.ERROR, {\n          status: xhr.status || -1,\n          content: new Error(\"Network error occurred. (Status: \" + xhr.status + \")\"),\n          errorCode: self.READY_STATE_CHANGE_ERROR.XML_HTTP_REQUEST_ERROR\n        }, self._selectedRoom));\n      }, xhr.onprogress = function () {\n        log.debug([null, \"XMLHttpRequest\", method, \"Retrieving information and config from webserver ->\"], {\n          url: url,\n          params: params\n        });\n      };\n\n      try {\n        xhr.open(method, url, !0), self._socketUseXDR || (xhr.setRequestHeader(\"Skylink_SDK_version\", self.VERSION), xhr.setRequestHeader(\"Skylink_SDK_type\", \"WEB_SDK\")), params ? (xhr.setContentType(\"application/json;charset=UTF-8\"), xhr.send(JSON.stringify(params))) : xhr.send();\n      } catch (error) {\n        return completed = !0, self._handleAuthStats(\"error\", null, -1, error), self._readyState = self.READY_STATE_CHANGE.ERROR, void self._trigger(\"readyStateChange\", self.READY_STATE_CHANGE.ERROR, {\n          status: xhr.status || -1,\n          content: new Error(\"Failed starting XHR process.\"),\n          errorCode: self.READY_STATE_CHANGE_ERROR.XML_HTTP_REQUEST_ERROR\n        }, self._selectedRoom);\n      }\n\n      setTimeout(function () {\n        if (!completed) if (completed = !0, xhr.onload = null, xhr.onerror = null, xhr.onprogress = null, retries < 2) retries++, requestFn();else {\n          var timeoutError = new Error(\"Response timed out from API server\");\n          self._handleAuthStats(\"error\", null, -1, timeoutError), self._readyState = self.READY_STATE_CHANGE.ERROR, self._trigger(\"readyStateChange\", self.READY_STATE_CHANGE.ERROR, {\n            status: xhr.status || -1,\n            content: timeoutError,\n            errorCode: self.READY_STATE_CHANGE_ERROR.XML_HTTP_NO_REPONSE_ERROR\n          }, self._selectedRoom);\n        }\n      }, self._initOptions.apiTimeout);\n    }();\n  }, Skylink.prototype._parseInfo = function (info) {\n    if (log.log(\"Parsing parameter from server\", info), !info.pc_constraints && !info.offer_constraints) return void this._trigger(\"readyStateChange\", this.READY_STATE_CHANGE.ERROR, {\n      status: 200,\n      content: info.info,\n      errorCode: info.error\n    }, self._selectedRoom);\n    log.debug(\"Peer connection constraints:\", info.pc_constraints), log.debug(\"Offer constraints:\", info.offer_constraints), this._key = info.cid, this._appKeyOwner = info.apiOwner, this._signalingServer = info.ipSigserver, this._isPrivileged = info.isPrivileged, this._autoIntroduce = info.autoIntroduce, info.enable_stats_config || (this._initOptions.enableStatsGathering = !1), this._user = {\n      uid: info.username,\n      token: info.userCred,\n      timeStamp: info.timeStamp,\n      streams: [],\n      info: {}\n    }, this._room = {\n      id: info.room_key,\n      token: info.roomCred,\n      startDateTime: info.start,\n      duration: info.len,\n      connection: {\n        peerConstraints: JSON.parse(info.pc_constraints),\n        peerConfig: null,\n        offerConstraints: JSON.parse(info.offer_constraints),\n        sdpConstraints: {\n          mandatory: {\n            OfferToReceiveAudio: !0,\n            OfferToReceiveVideo: !0\n          }\n        },\n        mediaConstraints: JSON.parse(info.media_constraints)\n      }\n    }, this._socketPorts = {\n      \"http:\": Array.isArray(info.httpPortList) && info.httpPortList.length > 0 ? info.httpPortList : [80, 3e3],\n      \"https:\": Array.isArray(info.httpsPortList) && info.httpsPortList.length > 0 ? info.httpsPortList : [443, 3443]\n    }, this._readyState = this.READY_STATE_CHANGE.COMPLETED, this._trigger(\"readyStateChange\", this.READY_STATE_CHANGE.COMPLETED, null, this._selectedRoom), log.info(\"Parsed parameters from webserver. Ready for web-realtime communication\");\n  }, Skylink.prototype._loadInfo = function () {\n    var self = this;\n\n    if (\"function\" != typeof (globals.AdapterJS || window.AdapterJS || {}).webRTCReady) {\n      return void self._trigger(\"readyStateChange\", self.READY_STATE_CHANGE.ERROR, {\n        status: -2,\n        content: new Error(\"AdapterJS dependency is not loaded or incorrect AdapterJS dependency is used\"),\n        errorCode: self.READY_STATE_CHANGE_ERROR.ADAPTER_NO_LOADED\n      }, self._selectedRoom);\n    }\n\n    return globals.io || window.io ? window.XMLHttpRequest ? self._path ? void AdapterJS.webRTCReady(function () {\n      if (self._enableIceRestart = \"firefox\" !== AdapterJS.webrtcDetectedBrowser || AdapterJS.webrtcDetectedVersion >= 48, self._binaryChunkType = \"firefox\" === AdapterJS.webrtcDetectedBrowser ? self.DATA_TRANSFER_DATA_TYPE.BLOB : self.DATA_TRANSFER_DATA_TYPE.ARRAY_BUFFER, !function () {\n        try {\n          var p = new window.RTCPeerConnection(null);\n          return [\"object\", \"function\"].indexOf(typeof p.createOffer) > -1 && null !== p.createOffer;\n        } catch (e) {\n          return !1;\n        }\n      }()) return window.RTCPeerConnection && \"plugin\" === AdapterJS.webrtcDetectedType ? log.error(\"Plugin is not available. Please check plugin status.\") : log.error(\"WebRTC not supported. Please upgrade your browser\"), self._readyState = self.READY_STATE_CHANGE.ERROR, void self._trigger(\"readyStateChange\", self.READY_STATE_CHANGE.ERROR, {\n        status: -2,\n        content: new Error(\"plugin\" === AdapterJS.webrtcDetectedType && window.RTCPeerConnection ? \"Plugin is not available\" : \"WebRTC not available\"),\n        errorCode: self.READY_STATE_CHANGE_ERROR.NO_WEBRTC_SUPPORT\n      }, self._selectedRoom);\n\n      self._getCodecsSupport(function (error) {\n        return error ? (log.error(error), self._readyState = self.READY_STATE_CHANGE.ERROR, void self._trigger(\"readyStateChange\", self.READY_STATE_CHANGE.ERROR, {\n          status: -2,\n          content: new Error(error.message || error.toString()),\n          errorCode: self.READY_STATE_CHANGE_ERROR.PARSE_CODECS\n        }, self._selectedRoom)) : 0 === Object.keys(self._currentCodecSupport.audio).length && 0 === Object.keys(self._currentCodecSupport.video).length ? (log.error(\"No audio/video codecs available to start connection.\"), self._readyState = self.READY_STATE_CHANGE.ERROR, void self._trigger(\"readyStateChange\", self.READY_STATE_CHANGE.ERROR, {\n          status: -2,\n          content: new Error(\"No audio/video codecs available to start connection\"),\n          errorCode: self.READY_STATE_CHANGE_ERROR.PARSE_CODECS\n        }, self._selectedRoom)) : (self._readyState = self.READY_STATE_CHANGE.LOADING, self._trigger(\"readyStateChange\", self.READY_STATE_CHANGE.LOADING, null, self._selectedRoom), self._handleClientStats(), void self._requestServerInfo(\"GET\", self._path, function (response) {\n          self._parseInfo(response);\n        }));\n      });\n    }) : (log.error(\"Skylink is not initialised. Please call init() first\"), self._readyState = self.READY_STATE_CHANGE.ERROR, void self._trigger(\"readyStateChange\", self.READY_STATE_CHANGE.ERROR, {\n      status: -2,\n      content: new Error(\"No API Path is found\"),\n      errorCode: self.READY_STATE_CHANGE_ERROR.NO_PATH\n    }, self._selectedRoom)) : (log.error(\"XMLHttpRequest not supported. Please upgrade your browser\"), self._readyState = self.READY_STATE_CHANGE.ERROR, void self._trigger(\"readyStateChange\", self.READY_STATE_CHANGE.ERROR, {\n      status: -2,\n      content: new Error(\"XMLHttpRequest not available\"),\n      errorCode: self.READY_STATE_CHANGE_ERROR.NO_XMLHTTPREQUEST_SUPPORT\n    }, self._selectedRoom)) : (log.error(\"Socket.io not loaded. Please load socket.io\"), self._readyState = self.READY_STATE_CHANGE.ERROR, void self._trigger(\"readyStateChange\", self.READY_STATE_CHANGE.ERROR, {\n      status: -2,\n      content: new Error(\"Socket.io not found\"),\n      errorCode: self.READY_STATE_CHANGE_ERROR.NO_SOCKET_IO\n    }, self._selectedRoom));\n  }, Skylink.prototype._initSelectedRoom = function (room, callback) {\n    var self = this;\n    if (\"function\" == typeof room || void 0 === room) return log.error(\"Invalid room provided. Room:\", room), void callback(new Error(\"Invalid room provided\"), null);\n    var defaultRoom = self._initOptions.defaultRoom,\n        options = clone(self._initOptions);\n    options.iceServer = options.iceServer ? options.iceServer.urls : null, options.defaultRoom !== room && (options.defaultRoom = room), self.init(options, function (error, success) {\n      self._initOptions.defaultRoom = defaultRoom, error ? callback(error, null) : callback(null, success);\n    });\n  };\n\n  var _LOG_KEY = \"SkylinkJS\",\n      _LOG_LEVELS = [\"error\", \"warn\", \"info\", \"log\", \"debug\"],\n      _logLevel = 0,\n      _enableDebugMode = !1,\n      _enableDebugStack = !1,\n      _enableDebugTrace = !1,\n      _printTimestamp = !1,\n      _storedLogs = [],\n      _reportErrorConfig = {\n    app_key: null,\n    statsServer: null\n  },\n      _getStoredLogsFn = function _getStoredLogsFn(logLevel) {\n    if (void 0 === logLevel) return _storedLogs;\n\n    for (var returnLogs = [], i = 0; i < _storedLogs.length; i++) {\n      _storedLogs[i][1] === _LOG_LEVELS[logLevel] && returnLogs.push(_storedLogs[i]);\n    }\n\n    return returnLogs;\n  },\n      _clearAllStoredLogsFn = function _clearAllStoredLogsFn() {\n    _storedLogs = [];\n  },\n      _printAllStoredLogsFn = function _printAllStoredLogsFn() {\n    for (var i = 0; i < _storedLogs.length; i++) {\n      var timestamp = _storedLogs[i][0],\n          log = \"undefined\" !== console[_storedLogs[i][1]] ? _storedLogs[i][1] : \"log\",\n          message = _storedLogs[i][2],\n          debugObject = _storedLogs[i][3];\n      void 0 !== debugObject ? console[log](message, debugObject, timestamp) : console[log](message, timestamp);\n    }\n  },\n      SkylinkLogs = {\n    getLogs: _getStoredLogsFn,\n    clearAllLogs: _clearAllStoredLogsFn,\n    printAllLogs: _printAllStoredLogsFn\n  },\n      _reportToAPI = function _reportToAPI(message, object) {\n    if (_reportErrorConfig.statsServer) {\n      var statsServer = _reportErrorConfig.statsServer,\n          requestBody = {\n        data: {\n          message: message,\n          object: object\n        }\n      };\n      requestBody.app_key = _reportErrorConfig.app_key, requestBody.timestamp = new Date().toISOString();\n\n      try {\n        var xhr = new XMLHttpRequest();\n        xhr.onerror = function () {}, xhr.open(\"POST\", statsServer + \"/rest/stats/sessionerror\", !0), xhr.setRequestHeader(\"Content-Type\", \"application/json;charset=UTF-8\"), xhr.send(JSON.stringify(requestBody));\n      } catch (error) {}\n    }\n  },\n      _logFn = function _logFn(logLevel, message, debugObject) {\n    var outputLog = \"\",\n        datetime = new Date();\n\n    if (\"object\" == typeof message) {\n      if (outputLog += message[0] ? \" [\" + message[0] + \"] -\" : \" -\", outputLog += message[1] ? \" <<\" + message[1] + \">>\" : \"\", message[2]) if (outputLog += \" \", \"object\" == typeof message[2]) for (var i = 0; i < message[2].length; i++) {\n        outputLog += \"(\" + message[2][i] + \")\";\n      } else outputLog += \"(\" + message[2] + \")\";\n      outputLog += \" \" + message[3];\n    } else outputLog += \" - \" + message;\n\n    if (_enableDebugMode && _enableDebugStack) {\n      var logItem = [datetime, _LOG_LEVELS[logLevel], outputLog];\n      void 0 !== debugObject && logItem.push(debugObject), _storedLogs.push(logItem);\n    }\n\n    if (outputLog = _LOG_KEY + (_printTimestamp ? \" :: \" + datetime.toISOString() : \"\") + outputLog, _logLevel >= logLevel) if (logLevel = void 0 === console[_LOG_LEVELS[logLevel]] ? 3 : logLevel, _enableDebugMode && _enableDebugTrace) {\n      void 0 === console.trace && logLevel[3];\n      void 0 !== debugObject ? (console[_LOG_LEVELS[logLevel]](outputLog, debugObject), void 0 !== console.trace && console.trace(\"\")) : (console[_LOG_LEVELS[logLevel]](outputLog), void 0 !== console.trace && console.trace(\"\"));\n    } else void 0 !== debugObject ? console[_LOG_LEVELS[logLevel]](outputLog, debugObject) : console[_LOG_LEVELS[logLevel]](outputLog);\n  },\n      log = {\n    debug: function debug(message, object) {\n      _logFn(4, message, object);\n    },\n    log: function log(message, object) {\n      _logFn(3, message, object);\n    },\n    info: function info(message, object) {\n      _logFn(2, message, object);\n    },\n    warn: function warn(message, object) {\n      _logFn(1, message, object);\n    },\n    error: function error(message, object) {\n      _reportToAPI(message, object), _logFn(0, message, object);\n    }\n  };\n\n  Skylink.prototype.setLogLevel = function (logLevel) {\n    for (var level in this.LOG_LEVEL) {\n      if (this.LOG_LEVEL[level] === logLevel) return _logLevel = logLevel, void log.log([null, \"Log\", level, \"Log level exists. Level is set\"]);\n    }\n\n    log.error([null, \"Log\", level, \"Log level does not exist. Level is not set\"]);\n  }, Skylink.prototype.setDebugMode = function (isDebugMode) {\n    isDebugMode && \"object\" == typeof isDebugMode ? (_enableDebugMode = !0, _enableDebugTrace = !0 === isDebugMode.trace, _enableDebugStack = !0 === isDebugMode.storeLogs, _printTimestamp = !0 === isDebugMode.printTimestamp) : !0 === isDebugMode ? (_enableDebugMode = !0, _enableDebugTrace = !0, _enableDebugStack = !0, _printTimestamp = !1) : (_enableDebugMode = !1, _enableDebugTrace = !1, _enableDebugStack = !1, _printTimestamp = !1);\n  }, Skylink.prototype._setClientInfoForLogging = function () {\n    var initOptions = this._initOptions;\n    _reportErrorConfig.app_key = initOptions.appKey, _reportErrorConfig.statsServer = initOptions.statsServer;\n  };\n  Skylink.prototype.on = function (eventName, callback) {\n    \"function\" == typeof callback ? (this._EVENTS[eventName] = this._EVENTS[eventName] || [], this._EVENTS[eventName].push(callback), log.log([null, \"Event\", eventName, \"Event is subscribed\"])) : log.error([null, \"Event\", eventName, \"Provided parameter is not a function\"]);\n  }, Skylink.prototype.once = function (eventName, callback, condition, fireAlways) {\n    \"boolean\" == typeof condition && (fireAlways = condition, condition = null), fireAlways = void 0 !== fireAlways && fireAlways, condition = \"function\" != typeof condition ? function () {\n      return !0;\n    } : condition, \"function\" == typeof callback ? (this._onceEvents[eventName] = this._onceEvents[eventName] || [], this._onceEvents[eventName].push([callback, condition, fireAlways]), log.log([null, \"Event\", eventName, \"Event is subscribed on condition\"])) : log.error([null, \"Event\", eventName, \"Provided callback is not a function\"]);\n  }, Skylink.prototype.off = function (eventName, callback) {\n    if (eventName && \"string\" == typeof eventName) {\n      if (void 0 === callback) return this._EVENTS[eventName] = [], this._onceEvents[eventName] = [], void log.log([null, \"Event\", eventName, \"All events are unsubscribed\"]);\n\n      for (var arr = this._EVENTS[eventName] || [], once = this._onceEvents[eventName] || [], i = 0; i < arr.length; i++) {\n        if (arr[i] === callback) {\n          log.log([null, \"Event\", eventName, \"Event is unsubscribed\"]), arr.splice(i, 1);\n          break;\n        }\n      }\n\n      if (void 0 !== once) for (var j = 0; j < once.length; j++) {\n        if (once[j][0] === callback) {\n          log.log([null, \"Event\", eventName, \"One-time Event is unsubscribed\"]), once.splice(j, 1);\n          break;\n        }\n      }\n    } else this._EVENTS = {}, this._onceEvents = {};\n  }, Skylink.prototype._trigger = function (eventName) {\n    var args = Array.prototype.slice.call(arguments),\n        arr = this._EVENTS[eventName],\n        once = this._onceEvents[eventName] || null;\n    if (args.shift(), arr) for (var i = 0; i < arr.length; i++) {\n      try {\n        if (log.log([null, \"Event\", eventName, \"Event is fired\"]), !1 === arr[i].apply(this, args)) break;\n      } catch (error) {\n        throw log.error([null, \"Event\", eventName, \"Exception occurred in event:\"], error), error;\n      }\n    }\n    if (once) for (var j = 0; j < once.length; j++) {\n      if (!0 === once[j][1].apply(this, args)) {\n        if (log.log([null, \"Event\", eventName, \"Condition is met. Firing event\"]), !1 === once[j][0].apply(this, args)) break;\n        once[j] && !once[j][2] && (log.log([null, \"Event\", eventName, \"Removing event after firing once\"]), once.splice(j, 1), j--);\n      } else log.log([null, \"Event\", eventName, \"Condition is still not met. Holding event from being fired\"]);\n    }\n    log.log([null, \"Event\", eventName, \"Event is triggered\"]);\n  }, Skylink.prototype._condition = function (eventName, callback, checkFirst, condition, fireAlways) {\n    if (\"boolean\" == typeof condition && (fireAlways = condition, condition = null), \"function\" == typeof callback && \"function\" == typeof checkFirst) {\n      if (checkFirst()) return log.log([null, \"Event\", eventName, \"First condition is met. Firing callback\"]), void callback();\n      log.log([null, \"Event\", eventName, \"First condition is not met. Subscribing to event\"]), this.once(eventName, callback, condition, fireAlways);\n    } else log.error([null, \"Event\", eventName, \"Provided callback or checkFirst is not a function\"]);\n  }, Skylink.prototype._wait = function (callback, condition, intervalTime, fireAlways) {\n    if (fireAlways = void 0 !== fireAlways && fireAlways, \"function\" == typeof callback && \"function\" == typeof condition) {\n      if (condition()) return log.log([null, \"Event\", null, \"Condition is met. Firing callback\"]), void callback();\n      log.log([null, \"Event\", null, \"Condition is not met. Doing a check.\"]), intervalTime = \"number\" == typeof intervalTime ? intervalTime : 50;\n      var doWait = setInterval(function () {\n        condition() && (log.log([null, \"Event\", null, \"Condition is met after waiting. Firing callback\"]), fireAlways || clearInterval(doWait), callback());\n      }, intervalTime);\n    } else \"function\" != typeof callback && log.error([null, \"Event\", null, \"Provided callback is not a function\"]), \"function\" != typeof condition && log.error([null, \"Event\", null, \"Provided condition is not a function\"]);\n  }, Skylink.prototype._throttle = function (func, prop, wait) {\n    var self = this,\n        now = new Date().getTime();\n    self._timestamp[prop] && now - self._timestamp[prop] < wait ? func(!1) : (func(!0), self._timestamp[prop] = now);\n  }, Skylink.prototype._postStats = function (endpoint, params) {\n    var self = this,\n        requestBody = {};\n\n    if (self._initOptions.enableStatsGathering) {\n      Array.isArray(params) ? requestBody.data = params : requestBody = params, requestBody.client_id = (self._user && self._user.uid || \"dummy\") + \"_\" + self._statIdRandom, requestBody.app_key = self._initOptions.appKey, requestBody.timestamp = new Date().toISOString();\n\n      try {\n        var xhr = new XMLHttpRequest();\n        xhr.onerror = function () {}, xhr.open(\"POST\", self._initOptions.statsServer + endpoint, !0), xhr.setRequestHeader(\"Content-Type\", \"application/json;charset=UTF-8\"), xhr.send(JSON.stringify(requestBody));\n      } catch (error) {\n        log.error([null, \"XMLHttpRequest\", \"POST\", \"Error in posting stats data ->\"], error);\n      }\n    }\n  }, Skylink.prototype._handleClientStats = function () {\n    var self = this,\n        statsObject = {\n      username: self._user && self._user.uid || null,\n      sdk_name: \"web\",\n      sdk_version: self.VERSION,\n      agent_name: AdapterJS.webrtcDetectedBrowser,\n      agent_version: AdapterJS.webrtcDetectedVersion,\n      agent_platform: navigator.platform,\n      agent_plugin_version: AdapterJS.WebRTCPlugin.plugin && AdapterJS.WebRTCPlugin.plugin.VERSION || null\n    };\n\n    self._postStats(\"/rest/stats/client\", statsObject);\n  }, Skylink.prototype._handleSessionStats = function (message) {\n    var self = this,\n        statsObject = {\n      room_id: self._room && self._room.id,\n      user_id: self._user && self._user.sid || null,\n      state: message.type,\n      contents: message\n    };\n\n    self._postStats(\"/rest/stats/session\", statsObject);\n  }, Skylink.prototype._handleAuthStats = function (state, result, status, error) {\n    var self = this,\n        statsObject = {\n      room_id: result && result.room_key || null,\n      state: state,\n      http_status: status,\n      http_error: (\"string\" == typeof error ? error : error && error.message) || null,\n      api_url: self._path,\n      api_result: result\n    };\n\n    self._postStats(\"/rest/stats/auth\", statsObject);\n  }, Skylink.prototype._handleSignalingStats = function (state, retries, error) {\n    var self = this,\n        socketSession = clone(self._socketSession),\n        statsObject = {\n      room_id: self._room && self._room.id,\n      user_id: self._user && self._user.sid || null,\n      state: state,\n      signaling_url: socketSession.socketServer,\n      signaling_transport: socketSession.transportType.toLowerCase(),\n      attempts: retries,\n      error: (\"string\" == typeof error ? error : error && error.message) || null\n    };\n\n    self._postStats(\"/rest/stats/client/signaling\", statsObject);\n  }, Skylink.prototype._handleIceConnectionStats = function (state, peerId) {\n    var self = this,\n        statsObject = {\n      room_id: self._room && self._room.id,\n      user_id: self._user && self._user.sid,\n      peer_id: peerId,\n      state: state,\n      local_candidate: {},\n      remote_candidate: {}\n    };\n\n    self._retrieveStats(peerId, function (error, stats) {\n      stats && [\"local\", \"remote\"].forEach(function (dirType) {\n        var candidate = stats.selectedCandidate[dirType];\n        candidate && (statsObject[dirType + \"_candidate\"].ip_address = candidate.ipAddress || null, statsObject[dirType + \"_candidate\"].port_number = candidate.portNumber || null, statsObject[dirType + \"_candidate\"].candidate_type = candidate.candidateType || null, statsObject[dirType + \"_candidate\"].protocol = candidate.transport || null, statsObject[dirType + \"_candidate\"].priority = candidate.priority || null, \"local\" === dirType && (statsObject.local_candidate.network_type = candidate.networkType || null));\n      }), self._postStats(\"/rest/stats/client/iceconnection\", statsObject);\n    }, !0);\n  }, Skylink.prototype._handleIceCandidateStats = function (state, peerId, candidateId, candidate, error) {\n    var self = this,\n        statsObject = {\n      room_id: self._room && self._room.id,\n      user_id: self._user && self._user.sid,\n      peer_id: peerId,\n      state: state,\n      is_remote: !!candidateId,\n      candidate_id: candidateId || null,\n      candidate_sdp_mid: candidate.sdpMid,\n      candidate_sdp_mindex: candidate.sdpMLineIndex,\n      candidate_candidate: candidate.candidate,\n      error: (\"string\" == typeof error ? error : error && error.message) || null\n    };\n\n    self._manageStatsBuffer(\"iceCandidate\", statsObject, \"/rest/stats/client/icecandidate\");\n  }, Skylink.prototype._handleIceGatheringStats = function (state, peerId, isRemote) {\n    var self = this,\n        statsObject = {\n      room_id: self._room && self._room.id,\n      user_id: self._user && self._user.sid,\n      peer_id: peerId,\n      state: state,\n      is_remote: isRemote\n    };\n\n    self._manageStatsBuffer(\"iceGathering\", statsObject, \"/rest/stats/client/icegathering\");\n  }, Skylink.prototype._handleNegotiationStats = function (state, peerId, sdpOrMessage, isRemote, error) {\n    var self = this,\n        statsObject = {\n      room_id: self._room && self._room.id,\n      user_id: self._user && self._user.sid,\n      peer_id: peerId,\n      state: state,\n      is_remote: isRemote,\n      weight: sdpOrMessage.weight,\n      sdp_type: null,\n      sdp_sdp: null,\n      error: (\"string\" == typeof error ? error : error && error.message) || null\n    };\n    -1 === [\"enter\", \"welcome\", \"restart\"].indexOf(state) && (statsObject.weight = self.getPeerInfo(isRemote ? peerId : void 0).config.priorityWeight, statsObject.sdp_type = sdpOrMessage && sdpOrMessage.type || null, statsObject.sdp_sdp = sdpOrMessage && sdpOrMessage.sdp || null), self._manageStatsBuffer(\"negotiation\", statsObject, \"/rest/stats/client/negotiation\");\n  }, Skylink.prototype._handleBandwidthStats = function (peerId) {\n    var self = this,\n        statsObject = {\n      room_id: self._room && self._room.id,\n      user_id: self._user && self._user.sid,\n      peer_id: peerId,\n      audio_send: {\n        tracks: []\n      },\n      audio_recv: {},\n      video_send: {\n        tracks: []\n      },\n      video_recv: {}\n    },\n        useStream = self._streams.screenshare || self._streams.userMedia || null,\n        mutedStatus = self.getPeerInfo().mediaStatus;\n    useStream && (useStream.tracks.audio && (statsObject.audio_send.tracks = [{\n      stream_id: useStream.id,\n      id: useStream.tracks.audio.id,\n      label: useStream.tracks.audio.label,\n      muted: mutedStatus.audioMuted\n    }]), useStream.tracks.video && (statsObject.video_send.tracks = [{\n      stream_id: useStream.id,\n      id: useStream.tracks.video.id,\n      label: useStream.tracks.video.label,\n      height: useStream.tracks.video.height,\n      width: useStream.tracks.video.width,\n      muted: mutedStatus.videoMuted\n    }])), self._retrieveStats(peerId, function (error, stats) {\n      error && (statsObject.error = error && error.message, stats = {\n        audio: {\n          sending: {},\n          receiving: {}\n        },\n        video: {\n          sending: {},\n          receiving: {}\n        }\n      });\n\n      var formatValue = function formatValue(mediaType, directionType, itemKey) {\n        var value = stats[mediaType][\"send\" === directionType ? \"sending\" : \"receiving\"][itemKey];\n        return [\"number\", \"string\", \"boolean\"].indexOf(typeof value) > -1 ? value : null;\n      };\n\n      statsObject.audio_send.bytes = formatValue(\"audio\", \"send\", \"bytes\"), statsObject.audio_send.packets = formatValue(\"audio\", \"send\", \"packets\"), statsObject.audio_send.round_trip_time = formatValue(\"audio\", \"send\", \"rtt\"), statsObject.audio_send.nack_count = formatValue(\"audio\", \"send\", \"nacks\"), statsObject.audio_send.echo_return_loss = formatValue(\"audio\", \"send\", \"echoReturnLoss\"), statsObject.audio_send.echo_return_loss_enhancement = formatValue(\"audio\", \"send\", \"echoReturnLossEnhancement\"), statsObject.audio_recv.bytes = formatValue(\"audio\", \"recv\", \"bytes\"), statsObject.audio_recv.packets = formatValue(\"audio\", \"recv\", \"packets\"), statsObject.audio_recv.packets_lost = formatValue(\"audio\", \"recv\", \"packetsLost\"), statsObject.video_recv.packets_discarded = formatValue(\"audio\", \"recv\", \"packetsDiscarded\"), statsObject.audio_recv.jitter = formatValue(\"audio\", \"recv\", \"jitter\"), statsObject.audio_recv.nack_count = formatValue(\"audio\", \"recv\", \"nacks\"), statsObject.video_send.bytes = formatValue(\"video\", \"send\", \"bytes\"), statsObject.video_send.packets = formatValue(\"video\", \"send\", \"packets\"), statsObject.video_send.round_trip_time = formatValue(\"video\", \"send\", \"rtt\"), statsObject.video_send.nack_count = formatValue(\"video\", \"send\", \"nacks\"), statsObject.video_send.firs_count = formatValue(\"video\", \"send\", \"firs\"), statsObject.video_send.plis_count = formatValue(\"video\", \"send\", \"plis\"), statsObject.video_send.frames = formatValue(\"video\", \"send\", \"frames\"), statsObject.video_send.frames_encoded = formatValue(\"video\", \"send\", \"framesEncoded\"), statsObject.video_send.frames_dropped = formatValue(\"video\", \"send\", \"framesDropped\"), statsObject.video_send.frame_width = formatValue(\"video\", \"send\", \"frameWidth\"), statsObject.video_send.frame_height = formatValue(\"video\", \"send\", \"frameHeight\"), statsObject.video_send.framerate = formatValue(\"video\", \"send\", \"frameRate\"), statsObject.video_send.framerate_input = formatValue(\"video\", \"send\", \"frameRateInput\"), statsObject.video_send.framerate_encoded = formatValue(\"video\", \"send\", \"frameRateEncoded\"), statsObject.video_send.framerate_mean = formatValue(\"video\", \"send\", \"frameRateMean\"), statsObject.video_send.framerate_std_dev = formatValue(\"video\", \"send\", \"frameRateStdDev\"), statsObject.video_send.cpu_limited_resolution = formatValue(\"video\", \"send\", \"cpuLimitedResolution\"), statsObject.video_send.bandwidth_limited_resolution = formatValue(\"video\", \"send\", \"bandwidthLimitedResolution\"), statsObject.video_recv.bytes = formatValue(\"video\", \"recv\", \"bytes\"), statsObject.video_recv.packets = formatValue(\"video\", \"recv\", \"packets\"), statsObject.video_recv.packets_lost = formatValue(\"video\", \"recv\", \"packetsLost\"), statsObject.video_recv.packets_discarded = formatValue(\"video\", \"recv\", \"packetsDiscarded\"), statsObject.video_recv.jitter = formatValue(\"video\", \"recv\", \"jitter\"), statsObject.video_recv.nack_count = formatValue(\"video\", \"recv\", \"nacks\"), statsObject.video_recv.firs_count = formatValue(\"video\", \"recv\", \"firs\"), statsObject.video_recv.plis_count = formatValue(\"video\", \"recv\", \"plis\"), statsObject.video_recv.frames = formatValue(\"video\", \"recv\", \"frames\"), statsObject.video_recv.frames_decoded = formatValue(\"video\", \"recv\", \"framesDecoded\"), statsObject.video_recv.frame_width = formatValue(\"video\", \"recv\", \"frameWidth\"), statsObject.video_recv.frame_height = formatValue(\"video\", \"recv\", \"frameHeight\"), statsObject.video_recv.framerate = formatValue(\"video\", \"recv\", \"frameRate\"), statsObject.video_recv.framerate_output = formatValue(\"video\", \"recv\", \"frameRateOutput\"), statsObject.video_recv.framerate_decoded = formatValue(\"video\", \"recv\", \"frameRateDecoded\"), statsObject.video_recv.framerate_mean = formatValue(\"video\", \"recv\", \"frameRateMean\"), statsObject.video_recv.framerate_std_dev = formatValue(\"video\", \"recv\", \"frameRateStdDev\"), statsObject.video_recv.qp_sum = formatValue(\"video\", \"recv\", \"qpSum\"), self._postStats(\"/rest/stats/client/bandwidth\", statsObject);\n    }, !0);\n  }, Skylink.prototype._handleRecordingStats = function (state, recordingId, recordings, error) {\n    var self = this,\n        statsObject = {\n      room_id: self._room && self._room.id,\n      user_id: self._user && self._user.sid,\n      state: state,\n      recording_id: recordingId || null,\n      recordings: recordings,\n      error: (\"string\" == typeof error ? error : error && error.message) || null\n    };\n\n    self._postStats(\"/rest/stats/client/recording\", statsObject);\n  }, Skylink.prototype._handleDatachannelStats = function (state, peerId, channel, channelProp, error) {\n    var self = this,\n        statsObject = {\n      room_id: self._room && self._room.id,\n      user_id: self._user && self._user.sid,\n      peer_id: peerId,\n      state: state,\n      channel_id: channel && channel.id,\n      channel_label: channel && channel.label,\n      channel_type: \"main\" === channelProp ? \"persistent\" : \"temporal\",\n      channel_binary_type: channel && channel.binaryType,\n      error: (\"string\" == typeof error ? error : error && error.message) || null\n    };\n    channel && \"plugin\" === AdapterJS.webrtcDetectedType && (statsObject.channel_binary_type = \"int8Array\", \"IE\" === AdapterJS.webrtcDetectedBrowser && AdapterJS.webrtcDetectedVersion < 11 && (statsObject.channel_binary_type = \"none\")), self._postStats(\"/rest/stats/client/datachannel\", statsObject);\n  }, Skylink.prototype._stats_buffer = {}, Skylink.prototype._manageStatsBuffer = function (operation, data, url) {\n    var self = this;\n    void 0 === self._stats_buffer[operation] && (self._stats_buffer[operation] = {}, self._stats_buffer[operation].url = url, self._stats_buffer[operation].data = []), self._stats_buffer[operation].data.push(data), setInterval(function () {\n      for (var key in self._stats_buffer) {\n        self._stats_buffer[key].data.length > 0 && (self._postStats(self._stats_buffer[key].url, self._stats_buffer[key].data), self._stats_buffer[key].data = []);\n      }\n    }, 5e3);\n  }, Skylink.prototype._sendChannelMessage = function (message) {\n    var self = this,\n        interval = 1e3,\n        throughput = 16;\n    if (!self._channelOpen || !self._user || !self._socket) return void log.warn([message.target || \"Server\", \"Socket\", message.type, \"Dropping of message as Socket connection is not opened or is at incorrect step ->\"], message);\n    self._user.sid && !self._peerMessagesStamps[self._user.sid] && (self._peerMessagesStamps[self._user.sid] = {\n      userData: 0,\n      audioMuted: 0,\n      videoMuted: 0\n    });\n\n    var checkStampFn = function checkStampFn(statusMessage) {\n      return statusMessage.type === self._SIG_MESSAGE_TYPE.UPDATE_USER ? !!self._user.sid && statusMessage.stamp > self._peerMessagesStamps[self._user.sid].userData : statusMessage.type === self._SIG_MESSAGE_TYPE.MUTE_VIDEO ? !!self._user.sid && statusMessage.stamp > self._peerMessagesStamps[self._user.sid].videoMuted : statusMessage.type !== self._SIG_MESSAGE_TYPE.MUTE_AUDIO || !!self._user.sid && statusMessage.stamp > self._peerMessagesStamps[self._user.sid].audioMuted;\n    },\n        setStampFn = function setStampFn(statusMessage) {\n      statusMessage.type === self._SIG_MESSAGE_TYPE.UPDATE_USER ? self._peerMessagesStamps[self._user.sid].userData = statusMessage.stamp : statusMessage.type === self._SIG_MESSAGE_TYPE.MUTE_VIDEO ? self._peerMessagesStamps[self._user.sid].videoMuted = statusMessage.stamp : statusMessage.type === self._SIG_MESSAGE_TYPE.MUTE_AUDIO && (self._peerMessagesStamps[self._user.sid].audioMuted = statusMessage.stamp);\n    },\n        setQueueFn = function setQueueFn() {\n      log.debug([null, \"Socket\", null, \"Starting queue timeout\"]), self._socketMessageTimeout = setTimeout(function () {\n        if (new Date().getTime() - self._timestamp.socketMessage <= interval) return log.debug([null, \"Socket\", null, \"Restarting queue timeout\"]), void setQueueFn();\n        startSendingQueuedMessageFn();\n      }, interval - (new Date().getTime() - self._timestamp.socketMessage));\n    },\n        triggerEventFn = function triggerEventFn(eventMessage) {\n      eventMessage.type === self._SIG_MESSAGE_TYPE.PUBLIC_MESSAGE && self._trigger(\"incomingMessage\", {\n        content: eventMessage.data,\n        isPrivate: !1,\n        targetPeerId: null,\n        listOfPeers: Object.keys(self._peerInformations),\n        isDataChannel: !1,\n        senderPeerId: self._user.sid\n      }, self._user.sid, self.getPeerInfo(), !0);\n    },\n        sendGroupMessageFn = function sendGroupMessageFn(groupMessageList) {\n      if (self._socketMessageTimeout = null, !(self._channelOpen && self._user && self._user.sid && self._socket)) return void log.warn([message.target || \"Server\", \"Socket\", null, \"Dropping of group messages as Socket connection is not opened or is at incorrect step ->\"], groupMessageList);\n\n      for (var strGroupMessageList = [], stamps = {\n        userData: 0,\n        audioMuted: 0,\n        videoMuted: 0\n      }, k = 0; k < groupMessageList.length; k++) {\n        checkStampFn(groupMessageList[k]) && (groupMessageList[k].type === self._SIG_MESSAGE_TYPE.UPDATE_USER && groupMessageList[k].stamp > self._peerMessagesStamps[self._user.sid].userData && groupMessageList[k].stamp > stamps.userData ? stamps.userData = groupMessageList[k].stamp : groupMessageList[k].type === self._SIG_MESSAGE_TYPE.MUTE_AUDIO && groupMessageList[k].stamp > self._peerMessagesStamps[self._user.sid].audioMuted && groupMessageList[k].stamp > stamps.audioMuted ? stamps.audioMuted = groupMessageList[k].stamp : groupMessageList[k].type === self._SIG_MESSAGE_TYPE.MUTE_VIDEO && groupMessageList[k].stamp > self._peerMessagesStamps[self._user.sid].videoMuted && groupMessageList[k].stamp > stamps.videoMuted && (stamps.videoMuted = groupMessageList[k].stamp));\n      }\n\n      for (var i = 0; i < groupMessageList.length; i++) {\n        groupMessageList[i].type === self._SIG_MESSAGE_TYPE.UPDATE_USER && groupMessageList[i].stamp < stamps.userData || groupMessageList[i].type === self._SIG_MESSAGE_TYPE.MUTE_AUDIO && groupMessageList[i].stamp < stamps.audioMuted || groupMessageList[i].type === self._SIG_MESSAGE_TYPE.MUTE_VIDEO && groupMessageList[i].stamp < stamps.videoMuted ? (log.warn([message.target || \"Server\", \"Socket\", groupMessageList[i], \"Dropping of outdated status message ->\"], clone(groupMessageList[i])), groupMessageList.splice(i, 1), i--) : strGroupMessageList.push(JSON.stringify(groupMessageList[i]));\n      }\n\n      if (strGroupMessageList.length > 0) {\n        var groupMessage = {\n          type: self._SIG_MESSAGE_TYPE.GROUP,\n          lists: strGroupMessageList,\n          mid: self._user.sid,\n          rid: self._room.id\n        };\n        log.log([message.target || \"Server\", \"Socket\", groupMessage.type, \"Sending queued grouped message (max: 16 per group) ->\"], clone(groupMessage)), self._socket.send(JSON.stringify(groupMessage)), self._timestamp.socketMessage = new Date().getTime();\n\n        for (var j = 0; j < groupMessageList.length; j++) {\n          setStampFn(groupMessageList[j]), triggerEventFn(groupMessageList[j]);\n        }\n      }\n    },\n        startSendingQueuedMessageFn = function startSendingQueuedMessageFn() {\n      self._socketMessageQueue.length > 0 && (self._socketMessageQueue.length < throughput ? sendGroupMessageFn(self._socketMessageQueue.splice(0, self._socketMessageQueue.length)) : (sendGroupMessageFn(self._socketMessageQueue.splice(0, throughput)), setQueueFn()));\n    };\n\n    if (self._GROUP_MESSAGE_LIST.indexOf(message.type) > -1) {\n      if (self._timestamp.socketMessage && new Date().getTime() - self._timestamp.socketMessage <= interval) log.debug([message.target || \"Server\", \"Socket\", message.type, \"Queueing socket message to prevent message drop ->\"], clone(message)), self._socketMessageQueue.push(message), self._socketMessageTimeout || setQueueFn();else {\n        if (!checkStampFn(message)) return void log.warn([message.target || \"Server\", \"Socket\", message.type, \"Dropping of outdated status message ->\"], clone(message));\n        self._socketMessageTimeout && clearTimeout(self._socketMessageTimeout), log.log([message.target || \"Server\", \"Socket\", message.type, \"Sending message ->\"], clone(message)), self._socket.send(JSON.stringify(message)), setStampFn(message), triggerEventFn(message), self._timestamp.socketMessage = new Date().getTime();\n      }\n    } else log.log([message.target || \"Server\", \"Socket\", message.type, \"Sending message ->\"], clone(message)), self._socket.send(JSON.stringify(message)), message.type === self._SIG_MESSAGE_TYPE.BYE && self._inRoom && self._user && self._user.sid && message.mid === self._user.sid && (self.leaveRoom(!1), self._trigger(\"sessionDisconnect\", self._user.sid, self.getPeerInfo()));\n  }, Skylink.prototype._createSocket = function (type, joinRoomTimestamp) {\n    var self = this,\n        options = {\n      forceNew: !0,\n      reconnection: !0,\n      timeout: self._initOptions.socketTimeout,\n      reconnectionAttempts: 2,\n      reconnectionDelayMax: 5e3,\n      reconnectionDelay: 1e3,\n      transports: [\"websocket\"],\n      query: {\n        Skylink_SDK_type: \"WEB_SDK\",\n        Skylink_SDK_version: self.VERSION\n      }\n    },\n        ports = self._initOptions.socketServer && \"object\" == typeof self._initOptions.socketServer && Array.isArray(self._initOptions.socketServer.ports) && self._initOptions.socketServer.ports.length > 0 ? self._initOptions.socketServer.ports : self._socketPorts[self._signalingServerProtocol],\n        fallbackType = null;\n    null === self._signalingServerPort ? (self._signalingServerPort = ports[0], fallbackType = self.SOCKET_FALLBACK.NON_FALLBACK) : ports.indexOf(self._signalingServerPort) === ports.length - 1 || \"string\" == typeof self._initOptions.socketServer ? \"WebSocket\" === type ? (type = \"Polling\", self._signalingServerPort = ports[0]) : self._socketSession.finalAttempts++ : self._signalingServerPort = ports[ports.indexOf(self._signalingServerPort) + 1], \"Polling\" === type && (options.reconnectionDelayMax = 1e3, options.reconnectionAttempts = 4, options.transports = [\"xhr-polling\", \"jsonp-polling\", \"polling\"]);\n    var url = self._signalingServerProtocol + \"//\" + self._signalingServer + \":\" + self._signalingServerPort + \"?rand=\" + Date.now(),\n        retries = 0;\n    self._initOptions.socketServer && (url = \"string\" == typeof self._initOptions.socketServer ? self._initOptions.socketServer : (self._initOptions.socketServer.protocol ? self._initOptions.socketServer.protocol : self._signalingServerProtocol) + \"//\" + self._initOptions.socketServer.url + \":\" + self._signalingServerPort), self._socketSession.transportType = type, self._socketSession.socketOptions = options, self._socketSession.socketServer = url, null === fallbackType && (fallbackType = \"http:\" === self._signalingServerProtocol ? \"Polling\" === type ? self.SOCKET_FALLBACK.LONG_POLLING : self.SOCKET_FALLBACK.FALLBACK_PORT : \"Polling\" === type ? self.SOCKET_FALLBACK.LONG_POLLING_SSL : self.SOCKET_FALLBACK.FALLBACK_SSL_PORT, self._socketSession.attempts++, self._trigger(\"socketError\", self.SOCKET_ERROR.RECONNECTION_ATTEMPT, null, fallbackType, clone(self._socketSession)), self._trigger(\"channelRetry\", fallbackType, self._socketSession.attempts, clone(self._socketSession))), self._socket && self._closeChannel(), self._channelOpen = !1, log.log(\"Opening channel with signaling server url:\", clone(self._socketSession));\n    var socket = null;\n\n    try {\n      socket = io.connect(url, options);\n    } catch (error) {\n      return log.error(\"Failed creating socket connection object ->\", error), fallbackType === self.SOCKET_FALLBACK.NON_FALLBACK ? self._trigger(\"socketError\", self.SOCKET_ERROR.CONNECTION_FAILED, error, fallbackType, clone(self._socketSession)) : self._trigger(\"socketError\", self.SOCKET_ERROR.RECONNECTION_FAILED, error, fallbackType, clone(self._socketSession)), void self._trigger(\"socketError\", self.SOCKET_ERROR.RECONNECTION_ABORTED, new Error(\"Reconnection aborted as there no more available ports, transports and final attempts left.\"), fallbackType, clone(self._socketSession));\n    }\n\n    socket.on(\"reconnect_attempt\", function (attempt) {\n      retries++, self._socketSession.attempts++, self._handleSignalingStats(\"reconnect_attempt\", retries), self._trigger(\"channelRetry\", fallbackType, self._socketSession.attempts, clone(self._socketSession));\n    }), socket.on(\"reconnect_failed\", function () {\n      var errorMsg = 'Failed reconnection with transport \"' + type + '\" and port ' + self._signalingServerPort + \".\";\n      self._handleSignalingStats(\"reconnect_failed\", retries, errorMsg), fallbackType === self.SOCKET_FALLBACK.NON_FALLBACK ? (errorMsg = errorMsg.replace(/ reconnection /g, \" connection \"), self._trigger(\"socketError\", self.SOCKET_ERROR.CONNECTION_FAILED, new Error(errorMsg), fallbackType, clone(self._socketSession))) : self._trigger(\"socketError\", self.SOCKET_ERROR.RECONNECTION_FAILED, new Error(errorMsg), fallbackType, clone(self._socketSession)), self._socketSession.finalAttempts < 2 ? self._createSocket(type, joinRoomTimestamp) : self._trigger(\"socketError\", self.SOCKET_ERROR.RECONNECTION_ABORTED, new Error(\"Reconnection aborted as there no more available ports, transports and final attempts left.\"), fallbackType, clone(self._socketSession));\n    }), socket.on(\"reconnect_error\", function (error) {\n      self._handleSignalingStats(\"reconnect_error\", retries, error);\n    }), socket.on(\"connect\", function () {\n      self._handleSignalingStats(\"connect\", retries), self._channelOpen || (log.log([null, \"Socket\", null, \"Channel opened\"]), self._channelOpen = !0, self._trigger(\"channelOpen\", clone(self._socketSession)));\n    }), socket.on(\"reconnect\", function () {\n      self._handleSignalingStats(\"reconnect\", retries), self._channelOpen || (log.log([null, \"Socket\", null, \"Channel opened\"]), self._channelOpen = !0, self._trigger(\"channelOpen\", clone(self._socketSession)));\n    }), socket.on(\"error\", function (error) {\n      if (self._handleSignalingStats(\"error\", retries, error), error && error.message.indexOf(\"xhr poll error\") > -1) return log.error([null, \"Socket\", null, \"XHR poll connection unstable. Disconnecting.. ->\"], error), void self._closeChannel();\n      log.error([null, \"Socket\", null, \"Exception occurred ->\"], error), self._trigger(\"channelError\", error, clone(self._socketSession));\n    }), socket.on(\"disconnect\", function () {\n      self._handleSignalingStats(\"disconnect\", retries), self._channelOpen && (self._channelOpen = !1, self._trigger(\"channelClose\", clone(self._socketSession)), log.log([null, \"Socket\", null, \"Channel closed\"]), self._inRoom && self._user && self._user.sid && (self.leaveRoom(!1), self._trigger(\"sessionDisconnect\", self._user.sid, self.getPeerInfo())));\n    }), socket.on(\"message\", function (messageStr) {\n      var message = JSON.parse(messageStr);\n\n      if (log.log([null, \"Socket\", null, \"Received message ->\"], message), message.type === self._SIG_MESSAGE_TYPE.GROUP) {\n        log.debug(\"Bundle of \" + message.lists.length + \" messages\");\n\n        for (var i = 0; i < message.lists.length; i++) {\n          var indiMessage = JSON.parse(message.lists[i]);\n          self._processSigMessage(indiMessage), self._trigger(\"channelMessage\", indiMessage, clone(self._socketSession));\n        }\n      } else self._processSigMessage(message), self._trigger(\"channelMessage\", message, clone(self._socketSession));\n    }), self._joinRoomManager.socketsFn.push(function (currentJoinRoomTimestamp) {\n      currentJoinRoomTimestamp !== joinRoomTimestamp && socket.disconnect();\n    }), self._socket = socket;\n  }, Skylink.prototype._openChannel = function (joinRoomTimestamp) {\n    var self = this;\n    if (self._channelOpen) return void log.error([null, \"Socket\", null, \"Unable to instantiate a new channel connection as there is already an ongoing channel connection\"]);\n    if (self._readyState !== self.READY_STATE_CHANGE.COMPLETED) return void log.error([null, \"Socket\", null, \"Unable to instantiate a new channel connection as readyState is not ready\"]);\n    self._initOptions.forceSSL ? self._signalingServerProtocol = \"https:\" : self._signalingServerProtocol = window.location.protocol;\n    var socketType = \"WebSocket\";\n    window.WebSocket || (socketType = \"Polling\"), self._socketSession.finalAttempts = 0, self._socketSession.attempts = 0, self._signalingServerPort = null, self._createSocket(socketType, joinRoomTimestamp);\n  }, Skylink.prototype._closeChannel = function () {\n    this._socket && (this._socket.removeAllListeners(\"connect_error\"), this._socket.removeAllListeners(\"reconnect_attempt\"), this._socket.removeAllListeners(\"reconnect_error\"), this._socket.removeAllListeners(\"reconnect_failed\"), this._socket.removeAllListeners(\"connect\"), this._socket.removeAllListeners(\"reconnect\"), this._socket.removeAllListeners(\"error\"), this._socket.removeAllListeners(\"disconnect\"), this._socket.removeAllListeners(\"message\")), this._channelOpen && (this._socket && this._socket.disconnect(), log.log([null, \"Socket\", null, \"Channel closed\"]), this._channelOpen = !1, this._trigger(\"channelClose\", clone(this._socketSession)), this._inRoom && this._user && this._user.sid && (this.leaveRoom(!1), this._trigger(\"sessionDisconnect\", this._user.sid, this.getPeerInfo()))), this._socket = null;\n  }, Skylink.prototype.sendMessage = function (message, targetPeerId) {\n    var listOfPeers = Object.keys(this._peerInformations),\n        isPrivate = !1;\n    if (Array.isArray(targetPeerId) ? (listOfPeers = targetPeerId, isPrivate = !0) : targetPeerId && \"string\" == typeof targetPeerId && (listOfPeers = [targetPeerId], isPrivate = !0), !this._inRoom || !this._socket || !this._user) return void log.error(\"Unable to send message as User is not in Room. ->\", message);\n\n    for (var i = 0; i < listOfPeers.length; i++) {\n      var peerId = listOfPeers[i];\n      this._peerInformations[peerId] ? \"MCU\" === peerId ? (listOfPeers.splice(i, 1), i--) : isPrivate && (log.debug([peerId, \"Socket\", null, \"Sending private message to Peer\"]), this._sendChannelMessage({\n        cid: this._key,\n        data: message,\n        mid: this._user.sid,\n        rid: this._room.id,\n        target: peerId,\n        type: this._SIG_MESSAGE_TYPE.PRIVATE_MESSAGE\n      })) : (log.error([peerId, \"Socket\", null, \"Dropping of sending message to Peer as Peer session does not exists\"]), listOfPeers.splice(i, 1), i--);\n    }\n\n    0 === listOfPeers.length && log.warn(\"Currently there are no Peers to send message to (unless the message is queued and there are Peer connected by then).\"), isPrivate ? this._trigger(\"incomingMessage\", {\n      content: message,\n      isPrivate: isPrivate,\n      targetPeerId: targetPeerId || null,\n      listOfPeers: listOfPeers,\n      isDataChannel: !1,\n      senderPeerId: this._user.sid\n    }, this._user.sid, this.getPeerInfo(), !0) : (log.debug([null, \"Socket\", null, \"Broadcasting message to Peers\"]), this._sendChannelMessage({\n      cid: this._key,\n      data: message,\n      mid: this._user.sid,\n      rid: this._room.id,\n      type: this._SIG_MESSAGE_TYPE.PUBLIC_MESSAGE\n    }));\n  }, Skylink.prototype.startRecording = function (callback) {\n    var self = this;\n\n    if (!self._hasMCU) {\n      var noMCUError = \"Unable to start recording as MCU is not connected\";\n      return log.error(noMCUError), self._handleRecordingStats(\"error-no-mcu-start\", null, null, noMCUError), void (\"function\" == typeof callback && callback(new Error(noMCUError), null));\n    }\n\n    if (self._currentRecordingId) {\n      var hasRecordingSessionError = \"Unable to start recording as there is an existing recording in-progress\";\n      return log.error(hasRecordingSessionError), self._handleRecordingStats(\"error-start-when-active\", self._currentRecordingId, null, hasRecordingSessionError), void (\"function\" == typeof callback && callback(new Error(hasRecordingSessionError), null));\n    }\n\n    \"function\" == typeof callback && self.once(\"recordingState\", function (state, recordingId) {\n      callback(null, recordingId);\n    }, function (state) {\n      return state === self.RECORDING_STATE.START;\n    }), self._sendChannelMessage({\n      type: self._SIG_MESSAGE_TYPE.START_RECORDING,\n      rid: self._room.id,\n      target: \"MCU\"\n    }), self._handleRecordingStats(\"request-start\"), log.debug([\"MCU\", \"Recording\", null, \"Starting recording\"]);\n  }, Skylink.prototype.stopRecording = function (callback, callbackSuccessWhenLink) {\n    var self = this;\n\n    if (!self._hasMCU) {\n      var noMCUError = \"Unable to stop recording as MCU is not connected\";\n      return log.error(noMCUError), self._handleRecordingStats(\"error-no-mcu-stop\", null, null, noMCUError), void (\"function\" == typeof callback && callback(new Error(noMCUError), null));\n    }\n\n    if (!self._currentRecordingId) {\n      var noRecordingSessionError = \"Unable to stop recording as there is no recording in-progress\";\n      return log.error(noRecordingSessionError), self._handleRecordingStats(\"error-stop-when-inactive\", null, null, noRecordingSessionError), void (\"function\" == typeof callback && callback(new Error(noRecordingSessionError), null));\n    }\n\n    if (self._recordingStartInterval) {\n      var recordingSecsRequiredError = \"Unable to stop recording as 4 seconds has not been recorded yet\";\n      return log.error(recordingSecsRequiredError), self._handleRecordingStats(\"error-min-stop\", self._currentRecordingId, null, recordingSecsRequiredError), void (\"function\" == typeof callback && callback(new Error(recordingSecsRequiredError), null));\n    }\n\n    if (\"function\" == typeof callback) {\n      var expectedRecordingId = self._currentRecordingId;\n      self.once(\"recordingState\", function (state, recordingId, link, error) {\n        if (callbackSuccessWhenLink) return error ? void callback(error, null) : void callback(null, {\n          link: link,\n          recordingId: recordingId\n        });\n        callback(null, recordingId);\n      }, function (state, recordingId) {\n        if (expectedRecordingId === recordingId) return callbackSuccessWhenLink ? [self.RECORDING_STATE.LINK, self.RECORDING_STATE.ERROR].indexOf(state) > -1 : state === self.RECORDING_STATE.STOP;\n      });\n    }\n\n    self._sendChannelMessage({\n      type: self._SIG_MESSAGE_TYPE.STOP_RECORDING,\n      rid: self._room.id,\n      target: \"MCU\"\n    }), self._handleRecordingStats(\"request-stop\", self._currentRecordingId), log.debug([\"MCU\", \"Recording\", null, \"Stopping recording\"]);\n  }, Skylink.prototype.getRecordings = function () {\n    return clone(this._recordings);\n  }, Skylink.prototype._processSigMessage = function (message, session) {\n    var origin = message.mid;\n    if (origin && origin !== this._user.sid || (origin = \"Server\"), log.debug([origin, \"Socket\", message.type, \"Received from peer ->\"], clone(message)), message.mid === this._user.sid && message.type !== this._SIG_MESSAGE_TYPE.REDIRECT && message.type !== this._SIG_MESSAGE_TYPE.IN_ROOM) return void log.debug([origin, \"Socket\", message.type, \"Ignoring message ->\"], clone(message));\n\n    switch (message.type) {\n      case this._SIG_MESSAGE_TYPE.PUBLIC_MESSAGE:\n        this._publicMessageHandler(message);\n\n        break;\n\n      case this._SIG_MESSAGE_TYPE.PRIVATE_MESSAGE:\n        this._privateMessageHandler(message);\n\n        break;\n\n      case this._SIG_MESSAGE_TYPE.IN_ROOM:\n        this._inRoomHandler(message);\n\n        break;\n\n      case this._SIG_MESSAGE_TYPE.ENTER:\n        this._enterHandler(message);\n\n        break;\n\n      case this._SIG_MESSAGE_TYPE.WELCOME:\n        this._welcomeHandler(message);\n\n        break;\n\n      case this._SIG_MESSAGE_TYPE.RESTART:\n        this._restartHandler(message);\n\n        break;\n\n      case this._SIG_MESSAGE_TYPE.OFFER:\n        this._offerHandler(message);\n\n        break;\n\n      case this._SIG_MESSAGE_TYPE.ANSWER:\n        this._answerHandler(message);\n\n        break;\n\n      case this._SIG_MESSAGE_TYPE.CANDIDATE:\n        this._candidateHandler(message);\n\n        break;\n\n      case this._SIG_MESSAGE_TYPE.BYE:\n        this._byeHandler(message);\n\n        break;\n\n      case this._SIG_MESSAGE_TYPE.REDIRECT:\n        this._redirectHandler(message);\n\n        break;\n\n      case this._SIG_MESSAGE_TYPE.UPDATE_USER:\n        this._updateUserEventHandler(message);\n\n        break;\n\n      case this._SIG_MESSAGE_TYPE.MUTE_VIDEO:\n        this._muteVideoEventHandler(message);\n\n        break;\n\n      case this._SIG_MESSAGE_TYPE.MUTE_AUDIO:\n        this._muteAudioEventHandler(message);\n\n        break;\n\n      case this._SIG_MESSAGE_TYPE.STREAM:\n        this._streamEventHandler(message);\n\n        break;\n\n      case this._SIG_MESSAGE_TYPE.ROOM_LOCK:\n        this._roomLockEventHandler(message);\n\n        break;\n\n      case this._SIG_MESSAGE_TYPE.PEER_LIST:\n        this._peerListEventHandler(message);\n\n        break;\n\n      case this._SIG_MESSAGE_TYPE.INTRODUCE_ERROR:\n        this._introduceErrorEventHandler(message);\n\n        break;\n\n      case this._SIG_MESSAGE_TYPE.APPROACH:\n        this._approachEventHandler(message);\n\n        break;\n\n      case this._SIG_MESSAGE_TYPE.RECORDING:\n        this._recordingEventHandler(message);\n\n        break;\n\n      case this._SIG_MESSAGE_TYPE.END_OF_CANDIDATES:\n        this._endOfCandidatesHandler(message);\n\n        break;\n\n      default:\n        log.error([message.mid, \"Socket\", message.type, \"Unsupported message ->\"], clone(message));\n    }\n  }, Skylink.prototype._peerListEventHandler = function (message) {\n    var self = this;\n    self._peerList = message.result, log.log([\"Server\", null, message.type, \"Received list of peers\"], self._peerList), self._trigger(\"getPeersStateChange\", self.GET_PEERS_STATE.RECEIVED, self._user.sid, self._peerList);\n  }, Skylink.prototype._endOfCandidatesHandler = function (message) {\n    var self = this,\n        targetMid = message.mid;\n    self._peerConnections[targetMid] && self._peerConnections[targetMid].signalingState !== self.PEER_CONNECTION_STATE.CLOSED && (self._peerEndOfCandidatesCounter[targetMid].expectedLen = message.noOfExpectedCandidates || 0, self._handleIceGatheringStats(\"complete\", targetMid, !0), self._signalingEndOfCandidates(targetMid));\n  }, Skylink.prototype._introduceErrorEventHandler = function (message) {\n    var self = this;\n    log.log([\"Server\", null, message.type, \"Introduce failed. Reason: \" + message.reason]), self._handleSessionStats(message), self._trigger(\"introduceStateChange\", self.INTRODUCE_STATE.ERROR, self._user.sid, message.sendingPeerId, message.receivingPeerId, message.reason);\n  }, Skylink.prototype._approachEventHandler = function (message) {\n    var self = this;\n    log.log([\"Server\", null, message.type, \"Approaching peer\"], message.target), self._handleSessionStats(message), self._trigger(\"handshakeProgress\", self.HANDSHAKE_PROGRESS.ENTER, self._user.sid);\n    var enterMsg = {\n      type: self._SIG_MESSAGE_TYPE.ENTER,\n      mid: self._user.sid,\n      rid: self._room.id,\n      agent: AdapterJS.webrtcDetectedBrowser,\n      version: (AdapterJS.webrtcDetectedVersion || 0).toString(),\n      os: window.navigator.platform,\n      userInfo: self._getUserInfo(),\n      receiveOnly: self.getPeerInfo().config.receiveOnly,\n      target: message.target,\n      weight: self._peerPriorityWeight,\n      temasysPluginVersion: AdapterJS.WebRTCPlugin.plugin ? AdapterJS.WebRTCPlugin.plugin.VERSION : null,\n      enableIceTrickle: self._initOptions.enableIceTrickle,\n      enableDataChannel: self._initOptions.enableDataChannel,\n      enableIceRestart: self._enableIceRestart,\n      SMProtocolVersion: self.SM_PROTOCOL_VERSION,\n      DTProtocolVersion: self.DT_PROTOCOL_VERSION\n    };\n    self._publishOnly && (enterMsg.publishOnly = {\n      type: self._streams.screenshare && self._streams.screenshare.stream ? \"screenshare\" : \"video\"\n    }), self._parentId && (enterMsg.parentId = self._parentId), self._sendChannelMessage(enterMsg), self._handleSessionStats(enterMsg);\n  }, Skylink.prototype._redirectHandler = function (message) {\n    if (log.log([\"Server\", null, message.type, \"System action warning:\"], {\n      message: message.info,\n      reason: message.reason,\n      action: message.action\n    }), this._handleSessionStats(message), message.action === this.SYSTEM_ACTION.REJECT) for (var key in this._peerConnections) {\n      this._peerConnections.hasOwnProperty(key) && this._removePeer(key);\n    }\n    \"toClose\" === message.reason && (message.reason = \"toclose\"), this._trigger(\"systemAction\", message.action, message.info, message.reason);\n  }, Skylink.prototype._updateUserEventHandler = function (message) {\n    var targetMid = message.mid;\n\n    if (log.log([targetMid, null, message.type, \"Peer updated userData:\"], message.userData), this._peerInformations[targetMid]) {\n      if (this._peerMessagesStamps[targetMid] && \"number\" == typeof message.stamp) {\n        if (message.stamp < this._peerMessagesStamps[targetMid].userData) return void log.warn([targetMid, null, message.type, \"Dropping outdated status ->\"], message);\n        this._peerMessagesStamps[targetMid].userData = message.stamp;\n      }\n\n      this._peerInformations[targetMid].userData = message.userData || {}, this._trigger(\"peerUpdated\", targetMid, this.getPeerInfo(targetMid), !1);\n    } else log.log([targetMid, null, message.type, \"Peer does not have any user information\"]);\n  }, Skylink.prototype._roomLockEventHandler = function (message) {\n    var targetMid = message.mid;\n    log.log([targetMid, message.type, \"Room lock status:\"], message.lock), this._trigger(\"roomLock\", message.lock, targetMid, this.getPeerInfo(targetMid), !1);\n  }, Skylink.prototype._muteAudioEventHandler = function (message) {\n    var targetMid = message.mid;\n\n    if (log.log([targetMid, null, message.type, \"Peer's audio muted:\"], message.muted), this._peerInformations[targetMid]) {\n      if (this._peerMessagesStamps[targetMid] && \"number\" == typeof message.stamp) {\n        if (message.stamp < this._peerMessagesStamps[targetMid].audioMuted) return void log.warn([targetMid, null, message.type, \"Dropping outdated status ->\"], message);\n        this._peerMessagesStamps[targetMid].audioMuted = message.stamp;\n      }\n\n      this._peerInformations[targetMid].mediaStatus.audioMuted = message.muted, this._trigger(\"streamMuted\", targetMid, this.getPeerInfo(targetMid), !1, this._peerInformations[targetMid].settings.video && this._peerInformations[targetMid].settings.video.screenshare), this._trigger(\"peerUpdated\", targetMid, this.getPeerInfo(targetMid), !1);\n    } else log.log([targetMid, message.type, \"Peer does not have any user information\"]);\n  }, Skylink.prototype._muteVideoEventHandler = function (message) {\n    var targetMid = message.mid;\n\n    if (log.log([targetMid, null, message.type, \"Peer's video muted:\"], message.muted), this._peerInformations[targetMid]) {\n      if (this._peerMessagesStamps[targetMid] && \"number\" == typeof message.stamp) {\n        if (message.stamp < this._peerMessagesStamps[targetMid].videoMuted) return void log.warn([targetMid, null, message.type, \"Dropping outdated status ->\"], message);\n        this._peerMessagesStamps[targetMid].videoMuted = message.stamp;\n      }\n\n      this._peerInformations[targetMid].mediaStatus.videoMuted = message.muted, this._trigger(\"streamMuted\", targetMid, this.getPeerInfo(targetMid), !1, this._peerInformations[targetMid].settings.video && this._peerInformations[targetMid].settings.video.screenshare), this._trigger(\"peerUpdated\", targetMid, this.getPeerInfo(targetMid), !1);\n    } else log.log([targetMid, null, message.type, \"Peer does not have any user information\"]);\n  }, Skylink.prototype._streamEventHandler = function (message) {\n    var targetMid = message.mid;\n    log.log([targetMid, null, message.type, \"Peer's stream status:\"], message.status), this._peerInformations[targetMid] && message.streamId ? (this._streamsSession[targetMid] = this._streamsSession[targetMid] || {}, \"ended\" === message.status && (message.settings && \"object\" == typeof message.settings && void 0 === this._streamsSession[targetMid][message.streamId] && (this._streamsSession[targetMid][message.streamId] = {\n      audio: message.settings.audio,\n      video: message.settings.video\n    }), this._handleEndedStreams(targetMid, message.streamId))) : log.log([targetMid, null, message.type, \"Peer does not have any user information\"]);\n  }, Skylink.prototype._byeHandler = function (message) {\n    var targetMid = message.mid;\n    (this._user || {}).sid !== targetMid ? (log.log([targetMid, null, message.type, \"Peer has left the room\"]), this._removePeer(targetMid)) : log.log([targetMid, null, message.type, \"Self has left the room\"]);\n  }, Skylink.prototype._privateMessageHandler = function (message) {\n    var targetMid = message.mid;\n    log.log([targetMid, null, message.type, \"Received private message from peer:\"], message.data), this._trigger(\"incomingMessage\", {\n      content: message.data,\n      isPrivate: !0,\n      targetPeerId: message.target,\n      isDataChannel: !1,\n      senderPeerId: targetMid\n    }, targetMid, this.getPeerInfo(targetMid), !1);\n  }, Skylink.prototype._publicMessageHandler = function (message) {\n    var targetMid = message.mid;\n    log.log([targetMid, null, message.type, \"Received public message from peer:\"], message.data), this._trigger(\"incomingMessage\", {\n      content: message.data,\n      isPrivate: !1,\n      targetPeerId: null,\n      isDataChannel: !1,\n      senderPeerId: targetMid\n    }, targetMid, this.getPeerInfo(targetMid), !1);\n  }, Skylink.prototype._recordingEventHandler = function (message) {\n    var self = this;\n    if (log.debug([\"MCU\", \"Recording\", null, \"Received recording message ->\"], message), \"on\" === message.action) self._handleRecordingStats(\"start\", message.recordingId), self._recordings[message.recordingId] || (log.debug([\"MCU\", \"Recording\", message.recordingId, \"Started recording\"]), self._currentRecordingId = message.recordingId, self._recordings[message.recordingId] = {\n      active: !0,\n      state: self.RECORDING_STATE.START,\n      startedDateTime: new Date().toISOString(),\n      endedDateTime: null,\n      mixingDateTime: null,\n      links: null,\n      error: null\n    }, self._recordingStartInterval = setTimeout(function () {\n      log.log([\"MCU\", \"Recording\", message.recordingId, \"4 seconds has been recorded. Recording can be stopped now\"]), self._recordingStartInterval = null;\n    }, 4e3), self._trigger(\"recordingState\", self.RECORDING_STATE.START, message.recordingId, null, null));else if (\"off\" === message.action) {\n      if (self._handleRecordingStats(\"stop\", message.recordingId), !self._recordings[message.recordingId]) return void log.error([\"MCU\", \"Recording\", message.recordingId, 'Received request of \"off\" but the session is empty']);\n      self._currentRecordingId = null, self._recordingStartInterval && (clearTimeout(self._recordingStartInterval), log.warn([\"MCU\", \"Recording\", message.recordingId, \"Recording stopped abruptly before 4 seconds\"]), self._recordingStartInterval = null), log.debug([\"MCU\", \"Recording\", message.recordingId, \"Stopped recording\"]), self._recordings[message.recordingId].active = !1, self._recordings[message.recordingId].state = self.RECORDING_STATE.STOP, self._recordings[message.recordingId].endedDateTime = new Date().toISOString(), self._trigger(\"recordingState\", self.RECORDING_STATE.STOP, message.recordingId, null, null);\n    } else if (\"url\" === message.action) {\n      var links = {};\n      if (Array.isArray(message.urls)) for (var i = 0; i < message.urls.length; i++) {\n        links[messages.urls[i].id || \"\"] = messages.urls[i].url || \"\";\n      } else \"string\" == typeof message.url && (links.mixin = message.url);\n      if (self._handleRecordingStats(\"mixin\", message.recordingId, links), !self._recordings[message.recordingId]) return void log.error([\"MCU\", \"Recording\", message.recordingId, \"Received URL but the session is empty\"]);\n      self._recordings[message.recordingId].links = links, self._recordings[message.recordingId].state = self.RECORDING_STATE.LINK, self._recordings[message.recordingId].mixingDateTime = new Date().toISOString(), self._trigger(\"recordingState\", self.RECORDING_STATE.LINK, message.recordingId, links, null);\n    } else {\n      var recordingError = new Error(message.error || \"Unknown error\");\n      if (self._handleRecordingStats(\"error\", message.recordingId, null, recordingError.message), !self._recordings[message.recordingId]) return void log.error([\"MCU\", \"Recording\", message.recordingId, \"Received error but the session is empty ->\"], recordingError);\n      log.error([\"MCU\", \"Recording\", message.recordingId, \"Recording failure ->\"], recordingError), self._recordings[message.recordingId].state = self.RECORDING_STATE.ERROR, self._recordings[message.recordingId].error = recordingError, self._recordings[message.recordingId].active && (log.debug([\"MCU\", \"Recording\", message.recordingId, \"Stopped recording abruptly\"]), self._recordings[message.recordingId].active = !1), self._trigger(\"recordingState\", self.RECORDING_STATE.ERROR, message.recordingId, null, recordingError);\n    }\n  }, Skylink.prototype._inRoomHandler = function (message) {\n    var self = this;\n    log.log([\"Server\", null, message.type, \"User is now in the room and functionalities are now available. Config received:\"], message.pc_config), self._room.connection.peerConfig = self._setIceServers((message.pc_config || {}).iceServers || []), self._inRoom = !0, self._user.sid = message.sid, self._peerPriorityWeight = message.tieBreaker + (self._initOptions.priorityWeightScheme === self.PRIORITY_WEIGHT_SCHEME.AUTO ? 0 : self._initOptions.priorityWeightScheme === self.PRIORITY_WEIGHT_SCHEME.ENFORCE_OFFERER ? 2e15 : -2e15), self._handleSessionStats(message), self._trigger(\"peerJoined\", self._user.sid, self.getPeerInfo(), !0), self._trigger(\"handshakeProgress\", self.HANDSHAKE_PROGRESS.ENTER, self._user.sid);\n    var streamId = null;\n    self._streams.screenshare && self._streams.screenshare.stream ? (streamId = self._streams.screenshare.stream.id || self._streams.screenshare.stream.label, self._trigger(\"incomingStream\", self._user.sid, self._streams.screenshare.stream, !0, self.getPeerInfo(), !0, streamId)) : self._streams.userMedia && self._streams.userMedia.stream && (streamId = self._streams.userMedia.stream.id || self._streams.userMedia.stream.label, self._trigger(\"incomingStream\", self._user.sid, self._streams.userMedia.stream, !0, self.getPeerInfo(), !1, streamId));\n    var enterMsg = {\n      type: self._SIG_MESSAGE_TYPE.ENTER,\n      mid: self._user.sid,\n      rid: self._room.id,\n      agent: AdapterJS.webrtcDetectedBrowser,\n      version: (AdapterJS.webrtcDetectedVersion || 0).toString(),\n      os: window.navigator.platform,\n      userInfo: self._getUserInfo(),\n      receiveOnly: self.getPeerInfo().config.receiveOnly,\n      weight: self._peerPriorityWeight,\n      temasysPluginVersion: AdapterJS.WebRTCPlugin.plugin ? AdapterJS.WebRTCPlugin.plugin.VERSION : null,\n      enableIceTrickle: self._initOptions.enableIceTrickle,\n      enableDataChannel: self._initOptions.enableDataChannel,\n      enableIceRestart: self._enableIceRestart,\n      SMProtocolVersion: self.SM_PROTOCOL_VERSION,\n      DTProtocolVersion: self.DT_PROTOCOL_VERSION\n    };\n    self._publishOnly && (enterMsg.publishOnly = {\n      type: self._streams.screenshare && self._streams.screenshare.stream ? \"screenshare\" : \"video\"\n    }), self._parentId && (enterMsg.parentId = self._parentId), self._sendChannelMessage(enterMsg), self._handleSessionStats(enterMsg);\n  }, Skylink.prototype._enterHandler = function (message) {\n    var self = this,\n        targetMid = message.mid,\n        isNewPeer = !1,\n        userInfo = message.userInfo || {};\n    if (userInfo.settings = userInfo.settings || {}, userInfo.mediaStatus = userInfo.mediaStatus || {}, userInfo.config = {\n      enableIceTrickle: \"boolean\" != typeof message.enableIceTrickle || message.enableIceTrickle,\n      enableIceRestart: \"boolean\" == typeof message.enableIceRestart && message.enableIceRestart,\n      enableDataChannel: \"boolean\" != typeof message.enableDataChannel || message.enableDataChannel,\n      priorityWeight: \"number\" == typeof message.weight ? message.weight : 0,\n      receiveOnly: !0 === message.receiveOnly,\n      publishOnly: !!message.publishOnly\n    }, userInfo.parentId = message.parentId || null, userInfo.agent = {\n      name: \"string\" == typeof message.agent && message.agent ? message.agent : \"other\",\n      version: function () {\n        if (!message.version || \"string\" != typeof message.version) return 0;\n\n        if (message.version.indexOf(\".\") > -1) {\n          var parts = message.version.split(\".\");\n\n          if (parts.length > 2) {\n            var majorVer = parts[0] || \"0\";\n            return parts.splice(0, 1), parseFloat(majorVer + \".\" + parts.join(\"0\"), 10);\n          }\n\n          return parseFloat(message.version || \"0\", 10);\n        }\n\n        return parseInt(message.version || \"0\", 10);\n      }(),\n      os: \"string\" == typeof message.os && message.os ? message.os : \"\",\n      pluginVersion: \"string\" == typeof message.temasysPluginVersion && message.temasysPluginVersion ? message.temasysPluginVersion : null,\n      SMProtocolVersion: message.SMProtocolVersion && \"string\" == typeof message.SMProtocolVersion ? message.SMProtocolVersion : \"0.1.1\",\n      DTProtocolVersion: message.DTProtocolVersion && \"string\" == typeof message.DTProtocolVersion ? message.DTProtocolVersion : self._hasMCU || \"MCU\" === targetMid ? \"0.1.2\" : \"0.1.0\"\n    }, log.log([targetMid, \"RTCPeerConnection\", null, 'Peer \"enter\" received ->'], message), self._handleNegotiationStats(\"enter\", targetMid, message, !0), \"MCU\" !== targetMid && (self._parentId && self._parentId === targetMid || self._hasMCU && self._publishOnly || message.parentId && self._user && self._user.sid && message.parentId === self._user.sid)) return void log.warn([targetMid, \"RTCPeerConnection\", null, 'Discarding \"enter\" for parentId or publishOnly case ->'], message);\n\n    var processPeerFn = function processPeerFn(cert) {\n      if (!self._peerInformations[targetMid]) {\n        isNewPeer = !0, self._peerInformations[targetMid] = userInfo;\n        var hasScreenshare = userInfo.settings.video && \"object\" == typeof userInfo.settings.video && !!userInfo.settings.video.screenshare;\n        self._addPeer(targetMid, cert || null, {\n          agent: userInfo.agent.name,\n          version: userInfo.agent.version,\n          os: userInfo.agent.os\n        }, message.receiveOnly, hasScreenshare), \"MCU\" === targetMid ? (log.info([targetMid, \"RTCPeerConnection\", null, \"MCU feature has been enabled\"]), self._hasMCU = !0, self._trigger(\"serverPeerJoined\", targetMid, self.SERVER_PEER_TYPE.MCU)) : self._trigger(\"peerJoined\", targetMid, self.getPeerInfo(targetMid), !1), self._trigger(\"handshakeProgress\", self.HANDSHAKE_PROGRESS.ENTER, targetMid);\n      }\n\n      self._peerMessagesStamps[targetMid] = self._peerMessagesStamps[targetMid] || {\n        userData: 0,\n        audioMuted: 0,\n        videoMuted: 0\n      };\n      var welcomeMsg = {\n        type: self._SIG_MESSAGE_TYPE.WELCOME,\n        mid: self._user.sid,\n        rid: self._room.id,\n        enableIceTrickle: self._initOptions.enableIceTrickle,\n        enableDataChannel: self._initOptions.enableDataChannel,\n        enableIceRestart: self._enableIceRestart,\n        agent: AdapterJS.webrtcDetectedBrowser,\n        version: (AdapterJS.webrtcDetectedVersion || 0).toString(),\n        receiveOnly: self.getPeerInfo().config.receiveOnly,\n        os: window.navigator.platform,\n        userInfo: self._getUserInfo(targetMid),\n        target: targetMid,\n        weight: self._peerPriorityWeight,\n        temasysPluginVersion: AdapterJS.WebRTCPlugin.plugin ? AdapterJS.WebRTCPlugin.plugin.VERSION : null,\n        SMProtocolVersion: self.SM_PROTOCOL_VERSION,\n        DTProtocolVersion: self.DT_PROTOCOL_VERSION\n      };\n      self._publishOnly && (welcomeMsg.publishOnly = {\n        type: self._streams.screenshare && self._streams.screenshare.stream ? \"screenshare\" : \"video\"\n      }), self._parentId && (welcomeMsg.parentId = self._parentId), self._sendChannelMessage(welcomeMsg), self._handleNegotiationStats(\"welcome\", targetMid, welcomeMsg, !1), isNewPeer && self._trigger(\"handshakeProgress\", self.HANDSHAKE_PROGRESS.WELCOME, targetMid);\n    };\n\n    if (self._peerConnectionConfig.certificate !== self.PEER_CERTIFICATE.AUTO && \"function\" == typeof RTCPeerConnection.generateCertificate) {\n      var certOptions = {};\n      certOptions = self._peerConnectionConfig.certificate === self.PEER_CERTIFICATE.ECDSA ? {\n        name: \"ECDSA\",\n        namedCurve: \"P-256\"\n      } : {\n        name: \"RSASSA-PKCS1-v1_5\",\n        modulusLength: 2048,\n        publicExponent: new Uint8Array([1, 0, 1]),\n        hash: \"SHA-256\"\n      }, RTCPeerConnection.generateCertificate(certOptions).then(function (cert) {\n        processPeerFn(cert);\n      }, function () {\n        processPeerFn();\n      });\n    } else processPeerFn();\n  }, Skylink.prototype._restartHandler = function (message) {\n    var self = this,\n        targetMid = message.mid,\n        userInfo = message.userInfo || {};\n    if (userInfo.settings = userInfo.settings || {}, userInfo.mediaStatus = userInfo.mediaStatus || {}, userInfo.config = {\n      enableIceTrickle: \"boolean\" != typeof message.enableIceTrickle || message.enableIceTrickle,\n      enableIceRestart: \"boolean\" == typeof message.enableIceRestart && message.enableIceRestart,\n      enableDataChannel: \"boolean\" != typeof message.enableDataChannel || message.enableDataChannel,\n      priorityWeight: \"number\" == typeof message.weight ? message.weight : 0,\n      receiveOnly: !0 === message.receiveOnly,\n      publishOnly: !!message.publishOnly\n    }, userInfo.parentId = message.parentId || null, userInfo.agent = {\n      name: \"string\" == typeof message.agent && message.agent ? message.agent : \"other\",\n      version: function () {\n        if (!message.version || \"string\" != typeof message.version) return 0;\n\n        if (message.version.indexOf(\".\") > -1) {\n          var parts = message.version.split(\".\");\n\n          if (parts.length > 2) {\n            var majorVer = parts[0] || \"0\";\n            return parts.splice(0, 1), parseFloat(majorVer + \".\" + parts.join(\"0\"), 10);\n          }\n\n          return parseFloat(message.version || \"0\", 10);\n        }\n\n        return parseInt(message.version || \"0\", 10);\n      }(),\n      os: \"string\" == typeof message.os && message.os ? message.os : \"\",\n      pluginVersion: \"string\" == typeof message.temasysPluginVersion && message.temasysPluginVersion ? message.temasysPluginVersion : null,\n      SMProtocolVersion: message.SMProtocolVersion && \"string\" == typeof message.SMProtocolVersion ? message.SMProtocolVersion : \"0.1.1\",\n      DTProtocolVersion: message.DTProtocolVersion && \"string\" == typeof message.DTProtocolVersion ? message.DTProtocolVersion : self._hasMCU || \"MCU\" === targetMid ? \"0.1.2\" : \"0.1.0\"\n    }, log.log([targetMid, \"RTCPeerConnection\", null, 'Peer \"restart\" received ->'], message), self._handleNegotiationStats(\"restart\", targetMid, message, !0), !self._peerInformations[targetMid]) return void log.error([targetMid, \"RTCPeerConnection\", null, \"Peer does not have an existing session. Ignoring restart process.\"]);\n    if (\"MCU\" !== targetMid && (self._parentId && self._parentId === targetMid || self._hasMCU && self._publishOnly || message.parentId && self._user && self._user.sid && message.parentId === self._user.sid)) return void log.warn([targetMid, \"RTCPeerConnection\", null, 'Discarding \"restart\" for parentId or publishOnly case ->'], message);\n    if (self._hasMCU && !self._initOptions.mcuUseRenegoRestart) return log.warn([targetMid, \"RTCPeerConnection\", null, \"Dropping restart request as MCU does not support re-negotiation. Restart workaround is to re-join Room for Peer.\"]), void self._trigger(\"peerRestart\", targetMid, self.getPeerInfo(targetMid), !1, !1);\n\n    if (self._peerInformations[targetMid] = userInfo, self._peerMessagesStamps[targetMid] = self._peerMessagesStamps[targetMid] || {\n      userData: 0,\n      audioMuted: 0,\n      videoMuted: 0\n    }, self._peerEndOfCandidatesCounter[targetMid] = self._peerEndOfCandidatesCounter[targetMid] || {}, self._peerEndOfCandidatesCounter[targetMid].len = 0, self._peerPriorityWeight > message.weight) {\n      if (log.debug([targetMid, \"RTCPeerConnection\", null, \"Re-negotiating new offer/answer.\"]), self._peerMessagesStamps[targetMid].hasRestart) return void log.warn([targetMid, \"RTCPeerConnection\", null, 'Discarding extra \"restart\" received.']);\n      self._peerMessagesStamps[targetMid].hasRestart = !0, self._doOffer(targetMid, !0 === message.doIceRestart, {\n        agent: userInfo.agent.name,\n        version: userInfo.agent.version,\n        os: userInfo.agent.os\n      }, !0);\n    } else {\n      log.debug([targetMid, \"RTCPeerConnection\", null, \"Waiting for peer to start re-negotiation.\"]);\n      var restartMsg = {\n        type: self._SIG_MESSAGE_TYPE.RESTART,\n        mid: self._user.sid,\n        rid: self._room.id,\n        agent: AdapterJS.webrtcDetectedBrowser,\n        version: (AdapterJS.webrtcDetectedVersion || 0).toString(),\n        os: window.navigator.platform,\n        userInfo: self._getUserInfo(targetMid),\n        target: targetMid,\n        weight: self._peerPriorityWeight,\n        enableIceTrickle: self._initOptions.enableIceTrickle,\n        enableDataChannel: self._initOptions.enableDataChannel,\n        enableIceRestart: self._enableIceRestart,\n        doIceRestart: !0 === message.doIceRestart,\n        receiveOnly: self.getPeerInfo().config.receiveOnly,\n        isRestartResend: !0,\n        temasysPluginVersion: AdapterJS.WebRTCPlugin.plugin ? AdapterJS.WebRTCPlugin.plugin.VERSION : null,\n        SMProtocolVersion: self.SM_PROTOCOL_VERSION,\n        DTProtocolVersion: self.DT_PROTOCOL_VERSION\n      };\n      self._publishOnly && (restartMsg.publishOnly = {\n        type: self._streams.screenshare && self._streams.screenshare.stream ? \"screenshare\" : \"video\"\n      }), self._parentId && (restartMsg.parentId = self._parentId), self._sendChannelMessage(restartMsg), self._handleNegotiationStats(\"restart\", targetMid, restartMsg, !1);\n    }\n\n    self._trigger(\"peerRestart\", targetMid, self.getPeerInfo(targetMid), !1, !0 === message.doIceRestart);\n  }, Skylink.prototype._welcomeHandler = function (message) {\n    var self = this,\n        targetMid = message.mid,\n        isNewPeer = !1,\n        userInfo = message.userInfo || {};\n    if (userInfo.settings = userInfo.settings || {}, userInfo.mediaStatus = userInfo.mediaStatus || {}, userInfo.config = {\n      enableIceTrickle: \"boolean\" != typeof message.enableIceTrickle || message.enableIceTrickle,\n      enableIceRestart: \"boolean\" == typeof message.enableIceRestart && message.enableIceRestart,\n      enableDataChannel: \"boolean\" != typeof message.enableDataChannel || message.enableDataChannel,\n      priorityWeight: \"number\" == typeof message.weight ? message.weight : 0,\n      receiveOnly: !0 === message.receiveOnly,\n      publishOnly: !!message.publishOnly\n    }, userInfo.parentId = message.parentId || null, userInfo.agent = {\n      name: \"string\" == typeof message.agent && message.agent ? message.agent : \"other\",\n      version: function () {\n        if (!message.version || \"string\" != typeof message.version) return 0;\n\n        if (message.version.indexOf(\".\") > -1) {\n          var parts = message.version.split(\".\");\n\n          if (parts.length > 2) {\n            var majorVer = parts[0] || \"0\";\n            return parts.splice(0, 1), parseFloat(majorVer + \".\" + parts.join(\"0\"), 10);\n          }\n\n          return parseFloat(message.version || \"0\", 10);\n        }\n\n        return parseInt(message.version || \"0\", 10);\n      }(),\n      os: \"string\" == typeof message.os && message.os ? message.os : \"\",\n      pluginVersion: \"string\" == typeof message.temasysPluginVersion && message.temasysPluginVersion ? message.temasysPluginVersion : null,\n      SMProtocolVersion: message.SMProtocolVersion && \"string\" == typeof message.SMProtocolVersion ? message.SMProtocolVersion : \"0.1.1\",\n      DTProtocolVersion: message.DTProtocolVersion && \"string\" == typeof message.DTProtocolVersion ? message.DTProtocolVersion : self._hasMCU || \"MCU\" === targetMid ? \"0.1.2\" : \"0.1.0\"\n    }, log.log([targetMid, \"RTCPeerConnection\", null, 'Peer \"welcome\" received ->'], message), self._handleNegotiationStats(\"welcome\", targetMid, message, !0), \"MCU\" !== targetMid && (self._parentId && self._parentId === targetMid || self._hasMCU && self._publishOnly || message.parentId && self._user && self._user.sid && message.parentId === self._user.sid)) return void log.warn([targetMid, \"RTCPeerConnection\", null, 'Discarding \"welcome\" for parentId or publishOnly case ->'], message);\n\n    var processPeerFn = function processPeerFn(cert) {\n      if (!self._peerInformations[targetMid]) {\n        isNewPeer = !0, self._peerInformations[targetMid] = userInfo;\n        var hasScreenshare = userInfo.settings.video && \"object\" == typeof userInfo.settings.video && !!userInfo.settings.video.screenshare;\n        self._addPeer(targetMid, cert || null, {\n          agent: userInfo.agent.name,\n          version: userInfo.agent.version,\n          os: userInfo.agent.os\n        }, message.receiveOnly, hasScreenshare), \"MCU\" === targetMid ? (log.info([targetMid, \"RTCPeerConnection\", null, \"MCU feature has been enabled\"]), self._hasMCU = !0, self._trigger(\"serverPeerJoined\", targetMid, self.SERVER_PEER_TYPE.MCU)) : self._trigger(\"peerJoined\", targetMid, self.getPeerInfo(targetMid), !1), self._trigger(\"handshakeProgress\", self.HANDSHAKE_PROGRESS.ENTER, targetMid), self._trigger(\"handshakeProgress\", self.HANDSHAKE_PROGRESS.WELCOME, targetMid);\n      }\n\n      if (self._peerMessagesStamps[targetMid] = self._peerMessagesStamps[targetMid] || {\n        userData: 0,\n        audioMuted: 0,\n        videoMuted: 0,\n        hasWelcome: !1\n      }, self._hasMCU || self._peerPriorityWeight > message.weight) {\n        if (self._peerMessagesStamps[targetMid].hasWelcome) return void log.warn([targetMid, \"RTCPeerConnection\", null, 'Discarding extra \"welcome\" received.']);\n        log.debug([targetMid, \"RTCPeerConnection\", null, \"Starting negotiation\"]), self._peerMessagesStamps[targetMid].hasWelcome = !0, self._doOffer(targetMid, !1, {\n          agent: userInfo.agent.name,\n          version: userInfo.agent.version,\n          os: userInfo.agent.os\n        }, !0);\n      } else {\n        log.debug([targetMid, \"RTCPeerConnection\", null, \"Waiting for peer to start negotiation.\"]);\n        var welcomeMsg = {\n          type: self._SIG_MESSAGE_TYPE.WELCOME,\n          mid: self._user.sid,\n          rid: self._room.id,\n          enableIceTrickle: self._initOptions.enableIceTrickle,\n          enableDataChannel: self._initOptions.enableDataChannel,\n          enableIceRestart: self._enableIceRestart,\n          receiveOnly: self.getPeerInfo().config.receiveOnly,\n          agent: AdapterJS.webrtcDetectedBrowser,\n          version: (AdapterJS.webrtcDetectedVersion || 0).toString(),\n          os: window.navigator.platform,\n          userInfo: self._getUserInfo(targetMid),\n          target: targetMid,\n          weight: self._peerPriorityWeight,\n          temasysPluginVersion: AdapterJS.WebRTCPlugin.plugin ? AdapterJS.WebRTCPlugin.plugin.VERSION : null,\n          SMProtocolVersion: self.SM_PROTOCOL_VERSION,\n          DTProtocolVersion: self.DT_PROTOCOL_VERSION\n        };\n        self._publishOnly && (welcomeMsg.publishOnly = {\n          type: self._streams.screenshare && self._streams.screenshare.stream ? \"screenshare\" : \"video\"\n        }), self._parentId && (welcomeMsg.parentId = self._parentId), self._sendChannelMessage(welcomeMsg), self._handleNegotiationStats(\"welcome\", targetMid, welcomeMsg, !1);\n      }\n    };\n\n    if (self._peerConnectionConfig.certificate !== self.PEER_CERTIFICATE.AUTO && \"function\" == typeof RTCPeerConnection.generateCertificate) {\n      var certOptions = {};\n      certOptions = self._peerConnectionConfig.certificate === self.PEER_CERTIFICATE.ECDSA ? {\n        name: \"ECDSA\",\n        namedCurve: \"P-256\"\n      } : {\n        name: \"RSASSA-PKCS1-v1_5\",\n        modulusLength: 2048,\n        publicExponent: new Uint8Array([1, 0, 1]),\n        hash: \"SHA-256\"\n      }, RTCPeerConnection.generateCertificate(certOptions).then(function (cert) {\n        processPeerFn(cert);\n      }, function () {\n        processPeerFn();\n      });\n    } else processPeerFn();\n  }, Skylink.prototype._offerHandler = function (message) {\n    var self = this,\n        targetMid = message.mid,\n        pc = self._peerConnections[targetMid];\n    log.log([targetMid, null, message.type, \"Received offer from peer. Session description:\"], clone(message));\n    var offer = {\n      type: \"offer\",\n      sdp: self._hasMCU ? message.sdp.replace(/\\r\\n/g, \"\\n\").split(\"\\n\").join(\"\\r\\n\") : message.sdp\n    };\n    if (self._handleNegotiationStats(\"offer\", targetMid, offer, !0), !pc) return log.error([targetMid, null, message.type, \"Peer connection object not found. Unable to setRemoteDescription for offer\"]), void self._handleNegotiationStats(\"dropped_offer\", targetMid, offer, !0, \"Peer connection does not exists\");\n\n    if (message.userInfo && \"object\" == typeof message.userInfo) {\n      var userInfo = message.userInfo || {};\n      self._peerInformations[targetMid].settings = userInfo.settings || {}, self._peerInformations[targetMid].mediaStatus = userInfo.mediaStatus || {}, self._peerInformations[targetMid].userData = userInfo.userData;\n    }\n\n    if (log.log([targetMid, \"RTCSessionDescription\", message.type, \"Session description object created\"], offer), offer.sdp = self._removeSDPFilteredCandidates(targetMid, offer), offer.sdp = self._setSDPCodec(targetMid, offer), offer.sdp = self._setSDPBitrate(targetMid, offer), offer.sdp = self._setSDPCodecParams(targetMid, offer), offer.sdp = self._removeSDPCodecs(targetMid, offer), offer.sdp = self._removeSDPREMBPackets(targetMid, offer), offer.sdp = self._handleSDPConnectionSettings(targetMid, offer, \"remote\"), offer.sdp = self._removeSDPUnknownAptRtx(targetMid, offer), log.log([targetMid, \"RTCSessionDescription\", message.type, \"Updated remote offer ->\"], offer.sdp), pc.signalingState !== self.PEER_CONNECTION_STATE.STABLE) return log.warn([targetMid, null, message.type, 'Peer connection state is not in \"stable\" state for re-negotiation. Dropping message.'], {\n      signalingState: pc.signalingState,\n      isRestart: !!message.resend\n    }), void self._handleNegotiationStats(\"dropped_offer\", targetMid, offer, !0, 'Peer connection state is \"' + pc.signalingState + '\"');\n    if (pc.processingRemoteSDP) return log.warn([targetMid, \"RTCSessionDescription\", \"offer\", \"Dropping of setting local offer as there is another sessionDescription being processed ->\"], offer), void self._handleNegotiationStats(\"dropped_offer\", targetMid, offer, !0, \"Peer connection is currently processing an existing sdp\");\n    pc.processingRemoteSDP = !0, message.userInfo && self._trigger(\"peerUpdated\", targetMid, self.getPeerInfo(targetMid), !1), self._parseSDPMediaStreamIDs(targetMid, offer);\n\n    var onSuccessCbFn = function onSuccessCbFn() {\n      log.debug([targetMid, \"RTCSessionDescription\", message.type, \"Remote description set\"]), pc.setOffer = \"remote\", pc.processingRemoteSDP = !1, self._handleNegotiationStats(\"set_offer\", targetMid, offer, !0), self._trigger(\"handshakeProgress\", self.HANDSHAKE_PROGRESS.OFFER, targetMid), self._addIceCandidateFromQueue(targetMid), self._doAnswer(targetMid);\n    },\n        onErrorCbFn = function onErrorCbFn(error) {\n      pc.processingRemoteSDP = !1, self._handleNegotiationStats(\"error_set_offer\", targetMid, offer, !0, error), self._trigger(\"handshakeProgress\", self.HANDSHAKE_PROGRESS.ERROR, targetMid, error), log.error([targetMid, null, message.type, \"Failed setting remote description:\"], {\n        error: error,\n        state: pc.signalingState,\n        offer: offer\n      });\n    };\n\n    pc.setRemoteDescription(new RTCSessionDescription(offer), onSuccessCbFn, onErrorCbFn);\n  }, Skylink.prototype._candidateHandler = function (message) {\n    var targetMid = message.mid;\n    if (!message.candidate && !message.id) return void log.warn([targetMid, \"RTCIceCandidate\", null, \"Received invalid ICE candidate message ->\"], message);\n    var canId = \"can-\" + new Date().getTime(),\n        candidateType = message.candidate.split(\" \")[7] || \"\",\n        candidate = new RTCIceCandidate({\n      sdpMLineIndex: message.label,\n      candidate: message.candidate,\n      sdpMid: message.id\n    });\n    if (log.debug([targetMid, \"RTCIceCandidate\", canId + \":\" + candidateType, \"Received ICE candidate ->\"], candidate), this._handleIceCandidateStats(\"received\", targetMid, canId, candidate), this._peerEndOfCandidatesCounter[targetMid] = this._peerEndOfCandidatesCounter[targetMid] || {}, this._peerEndOfCandidatesCounter[targetMid].len = this._peerEndOfCandidatesCounter[targetMid].len || 0, this._peerEndOfCandidatesCounter[targetMid].hasSet = !1, this._peerEndOfCandidatesCounter[targetMid].len++, this._trigger(\"candidateProcessingState\", this.CANDIDATE_PROCESSING_STATE.RECEIVED, targetMid, canId, candidateType, {\n      candidate: candidate.candidate,\n      sdpMid: candidate.sdpMid,\n      sdpMLineIndex: candidate.sdpMLineIndex\n    }, null), !this._peerConnections[targetMid] || this._peerConnections[targetMid].signalingState === this.PEER_CONNECTION_STATE.CLOSED) return log.warn([targetMid, \"RTCIceCandidate\", canId + \":\" + candidateType, \"Dropping ICE candidate as Peer connection does not exists or is closed\"]), this._handleIceCandidateStats(\"process_failed\", targetMid, canId, candidate, \"Peer connection does not exist\"), this._trigger(\"candidateProcessingState\", this.CANDIDATE_PROCESSING_STATE.DROPPED, targetMid, canId, candidateType, {\n      candidate: candidate.candidate,\n      sdpMid: candidate.sdpMid,\n      sdpMLineIndex: candidate.sdpMLineIndex\n    }, new Error(\"Failed processing ICE candidate as Peer connection does not exists or is closed.\")), void this._signalingEndOfCandidates(targetMid);\n\n    if (this._initOptions.filterCandidatesType[candidateType]) {\n      if (!this._hasMCU || !this._initOptions.forceTURN) return log.warn([targetMid, \"RTCIceCandidate\", canId + \":\" + candidateType, \"Dropping received ICE candidate as it matches ICE candidate filtering flag ->\"], candidate), this._handleIceCandidateStats(\"dropped\", targetMid, canId, candidate), this._trigger(\"candidateProcessingState\", this.CANDIDATE_PROCESSING_STATE.DROPPED, targetMid, canId, candidateType, {\n        candidate: candidate.candidate,\n        sdpMid: candidate.sdpMid,\n        sdpMLineIndex: candidate.sdpMLineIndex\n      }, new Error(\"Dropping of processing ICE candidate as it matches ICE candidate filtering flag.\")), void this._signalingEndOfCandidates(targetMid);\n      log.warn([targetMid, \"RTCIceCandidate\", canId + \":\" + candidateType, \"Not dropping received ICE candidate as TURN connections are enforced as MCU is present (and act as a TURN itself) so filtering of ICE candidate flags are not honoured ->\"], candidate);\n    }\n\n    this._peerConnections[targetMid].remoteDescription && this._peerConnections[targetMid].remoteDescription.sdp && this._peerConnections[targetMid].localDescription && this._peerConnections[targetMid].localDescription.sdp ? this._addIceCandidate(targetMid, canId, candidate) : this._addIceCandidateToQueue(targetMid, canId, candidate), this._signalingEndOfCandidates(targetMid), this._gatheredCandidates[targetMid] || (this._gatheredCandidates[targetMid] = {\n      sending: {\n        host: [],\n        srflx: [],\n        relay: []\n      },\n      receiving: {\n        host: [],\n        srflx: [],\n        relay: []\n      }\n    }), this._gatheredCandidates[targetMid].receiving[candidateType].push({\n      sdpMid: candidate.sdpMid,\n      sdpMLineIndex: candidate.sdpMLineIndex,\n      candidate: candidate.candidate\n    });\n  }, Skylink.prototype._answerHandler = function (message) {\n    var self = this,\n        targetMid = message.mid,\n        pc = self._peerConnections[targetMid];\n    log.log([targetMid, null, message.type, \"Received answer from peer. Session description:\"], clone(message));\n    var answer = {\n      type: \"answer\",\n      sdp: self._hasMCU ? message.sdp.replace(/\\r\\n/g, \"\\n\").split(\"\\n\").join(\"\\r\\n\") : message.sdp\n    };\n    if (self._handleNegotiationStats(\"answer\", targetMid, answer, !0), !pc) return log.error([targetMid, null, message.type, \"Peer connection object not found. Unable to setRemoteDescription for answer\"]), void self._handleNegotiationStats(\"dropped_answer\", targetMid, answer, !0, \"Peer connection does not exist\");\n\n    if (message.userInfo && \"object\" == typeof message.userInfo) {\n      var userInfo = message.userInfo || {};\n      self._peerInformations[targetMid].settings = userInfo.settings || {}, self._peerInformations[targetMid].mediaStatus = userInfo.mediaStatus || {}, self._peerInformations[targetMid].userData = userInfo.userData;\n    }\n\n    if (log.log([targetMid, \"RTCSessionDescription\", message.type, \"Session description object created\"], answer), answer.sdp = self._removeSDPFilteredCandidates(targetMid, answer), answer.sdp = self._setSDPCodec(targetMid, answer), answer.sdp = self._setSDPBitrate(targetMid, answer), answer.sdp = self._setSDPCodecParams(targetMid, answer), answer.sdp = self._removeSDPCodecs(targetMid, answer), answer.sdp = self._removeSDPREMBPackets(targetMid, answer), answer.sdp = self._handleSDPConnectionSettings(targetMid, answer, \"remote\"), answer.sdp = self._removeSDPUnknownAptRtx(targetMid, answer), answer.sdp = self._setSCTPport(targetMid, answer), log.log([targetMid, \"RTCSessionDescription\", message.type, \"Updated remote answer ->\"], answer.sdp), pc.signalingState !== self.PEER_CONNECTION_STATE.HAVE_LOCAL_OFFER) return log.warn([targetMid, null, message.type, 'Peer connection state is not in \"have-local-offer\" state for re-negotiation. Dropping message.'], {\n      signalingState: pc.signalingState,\n      isRestart: !!message.restart\n    }), void self._handleNegotiationStats(\"dropped_answer\", targetMid, answer, !0, 'Peer connection state is \"' + pc.signalingState + '\"');\n    if (pc.processingRemoteSDP) return log.warn([targetMid, \"RTCSessionDescription\", \"answer\", \"Dropping of setting local answer as there is another sessionDescription being processed ->\"], answer), void self._handleNegotiationStats(\"dropped_answer\", targetMid, answer, !0, \"Peer connection is currently processing an existing sdp\");\n    pc.processingRemoteSDP = !0, message.userInfo && self._trigger(\"peerUpdated\", targetMid, self.getPeerInfo(targetMid), !1), self._parseSDPMediaStreamIDs(targetMid, answer);\n\n    var onSuccessCbFn = function onSuccessCbFn() {\n      log.debug([targetMid, null, message.type, \"Remote description set\"]), pc.setAnswer = \"remote\", pc.processingRemoteSDP = !1, self._handleNegotiationStats(\"set_answer\", targetMid, answer, !0), self._trigger(\"handshakeProgress\", self.HANDSHAKE_PROGRESS.ANSWER, targetMid), self._addIceCandidateFromQueue(targetMid), self._peerMessagesStamps[targetMid] && (self._peerMessagesStamps[targetMid].hasRestart = !1), self._dataChannels[targetMid] && (-1 === pc.remoteDescription.sdp.indexOf(\"m=application\") || pc.remoteDescription.sdp.indexOf(\"m=application 0\") > 0) && (log.warn([targetMid, \"RTCPeerConnection\", null, \"Closing all datachannels as they were rejected.\"]), self._closeDataChannel(targetMid));\n    },\n        onErrorCbFn = function onErrorCbFn(error) {\n      self._handleNegotiationStats(\"error_set_answer\", targetMid, answer, !0, error), self._trigger(\"handshakeProgress\", self.HANDSHAKE_PROGRESS.ERROR, targetMid, error), pc.processingRemoteSDP = !1, log.error([targetMid, null, message.type, \"Failed setting remote description:\"], {\n        error: error,\n        state: pc.signalingState,\n        answer: answer\n      });\n    };\n\n    pc.setRemoteDescription(new RTCSessionDescription(answer), onSuccessCbFn, onErrorCbFn);\n  }, Skylink.prototype._isLowerThanVersion = function (agentVer, requiredVer) {\n    for (var partsA = (agentVer || \"\").split(\".\"), partsB = (requiredVer || \"\").split(\".\"), i = 0; i < partsB.length; i++) {\n      if ((partsA[i] || \"0\") < (partsB[i] || \"0\")) return !0;\n    }\n\n    return !1;\n  }, Skylink.prototype.getUserMedia = function (options, callback) {\n    var self = this;\n    if (\"function\" == typeof options) callback = options, options = {\n      audio: !0,\n      video: !0\n    };else if (\"object\" != typeof options || null === options) {\n      if (void 0 !== options) {\n        var invalidOptionsError = \"Please provide a valid options\";\n        return log.error(invalidOptionsError, options), void (\"function\" == typeof callback && callback(new Error(invalidOptionsError), null));\n      }\n\n      options = {\n        audio: !0,\n        video: !0\n      };\n    } else if (!options.audio && !options.video) {\n      var noConstraintOptionsSelectedError = \"Please select audio or video\";\n      return log.error(noConstraintOptionsSelectedError, options), void (\"function\" == typeof callback && callback(new Error(noConstraintOptionsSelectedError), null));\n    }\n\n    self._throttle(function (runFn) {\n      if (runFn) {\n        if (\"function\" == typeof callback) {\n          var mediaAccessSuccessFn = function mediaAccessSuccessFn(stream) {\n            self.off(\"mediaAccessError\", mediaAccessErrorFn), callback(null, stream);\n          },\n              mediaAccessErrorFn = function mediaAccessErrorFn(error) {\n            self.off(\"mediaAccessSuccess\", mediaAccessSuccessFn), callback(error, null);\n          };\n\n          self.once(\"mediaAccessSuccess\", mediaAccessSuccessFn, function (stream, isScreensharing) {\n            return !isScreensharing;\n          }), self.once(\"mediaAccessError\", mediaAccessErrorFn, function (error, isScreensharing) {\n            return !isScreensharing;\n          });\n        }\n\n        var settings = self._parseStreamSettings(options),\n            onSuccessCbFn = function onSuccessCbFn(stream) {\n          settings.mutedSettings.shouldAudioMuted && (self._streamsMutedSettings.audioMuted = !0), settings.mutedSettings.shouldVideoMuted && (self._streamsMutedSettings.videoMuted = !0), self._onStreamAccessSuccess(stream, settings, !1, !1);\n        },\n            onErrorCbFn = function onErrorCbFn(error) {\n          self._onStreamAccessError(error, settings, !1, !1);\n        };\n\n        try {\n          if (\"function\" != typeof (AdapterJS || {}).webRTCReady) return onErrorCbFn(new Error(\"Failed to call getUserMedia() as AdapterJS is not yet loaded!\"));\n          AdapterJS.webRTCReady(function () {\n            navigator.getUserMedia(settings.getUserMediaSettings, onSuccessCbFn, onErrorCbFn);\n          });\n        } catch (error) {\n          onErrorCbFn(error);\n        }\n      } else if (self._initOptions.throttlingShouldThrowError) {\n        var throttleLimitError = \"Unable to run as throttle interval has not reached (\" + self._initOptions.throttleIntervals.getUserMedia + \"ms).\";\n        log.error(throttleLimitError), \"function\" == typeof callback && callback(new Error(throttleLimitError), null);\n      }\n    }, \"getUserMedia\", self._initOptions.throttleIntervals.getUserMedia);\n  }, Skylink.prototype.sendStream = function (options, callback) {\n    var self = this,\n        restartFn = function restartFn(stream) {\n      self._inRoom ? (self._streams.screenshare || (self._trigger(\"incomingStream\", self._user.sid, stream, !0, self.getPeerInfo(), !1, stream.id || stream.label), self._trigger(\"peerUpdated\", self._user.sid, self.getPeerInfo(), !0)), Object.keys(self._peerConnections).length > 0 || self._hasMCU ? self._refreshPeerConnection(Object.keys(self._peerConnections), !1, {}, function (err, success) {\n        if (err) return log.error(\"Failed refreshing connections for sendStream() ->\", err), void (\"function\" == typeof callback && callback(new Error(\"Failed refreshing connections.\"), null));\n        \"function\" == typeof callback && callback(null, stream);\n      }) : \"function\" == typeof callback && callback(null, stream)) : \"function\" == typeof callback && callback(null, stream);\n    };\n\n    if (!(\"object\" == typeof options && null !== options || AdapterJS && AdapterJS.WebRTCPlugin && AdapterJS.WebRTCPlugin.plugin && [\"function\", \"object\"].indexOf(typeof options) > -1)) {\n      var invalidOptionsError = \"Provided stream settings is invalid\";\n      return log.error(invalidOptionsError, options), void (\"function\" == typeof callback && callback(new Error(invalidOptionsError), null));\n    }\n\n    if (self._inRoom || log.warn(\"There are no peers to send stream to as not in room!\"), \"edge\" === AdapterJS.webrtcDetectedBrowser) {\n      var edgeNotSupportError = \"Edge browser currently does not support renegotiation.\";\n      return log.error(edgeNotSupportError, options), void (\"function\" == typeof callback && callback(new Error(edgeNotSupportError), null));\n    }\n\n    if (\"function\" == typeof options.getAudioTracks || \"function\" == typeof options.getVideoTracks) {\n      var checkActiveTracksFn = function checkActiveTracksFn(tracks) {\n        for (var t = 0; t < tracks.length; t++) {\n          if (!(tracks[t].ended || \"string\" == typeof tracks[t].readyState && \"live\" !== tracks[t].readyState)) return !0;\n        }\n\n        return !1;\n      };\n\n      if (!checkActiveTracksFn(options.getAudioTracks()) && !checkActiveTracksFn(options.getVideoTracks())) {\n        var invalidStreamError = \"Provided stream object does not have audio or video tracks.\";\n        return log.error(invalidStreamError, options), void (\"function\" == typeof callback && callback(new Error(invalidStreamError), null));\n      }\n\n      self._onStreamAccessSuccess(options, {\n        settings: {\n          audio: !0,\n          video: !0\n        },\n        getUserMediaSettings: {\n          audio: !0,\n          video: !0\n        }\n      }, !1, !1), restartFn(options);\n    } else self.getUserMedia(options, function (err, stream) {\n      if (err) return void (\"function\" == typeof callback && callback(err, null));\n      restartFn(stream);\n    });\n  }, Skylink.prototype.stopStream = function () {\n    this._streams.userMedia && this._stopStreams({\n      userMedia: !0\n    });\n  }, Skylink.prototype.muteStream = function (options) {\n    var self = this;\n    if (\"object\" != typeof options) return void log.error(\"Provided settings is not an object\");\n    if (!(self._streams.userMedia && self._streams.userMedia.stream || self._streams.screenshare && self._streams.screenshare.stream)) return void log.warn(\"No streams are available to mute / unmute!\");\n    var audioMuted = \"boolean\" != typeof options.audioMuted || options.audioMuted,\n        videoMuted = \"boolean\" != typeof options.videoMuted || options.videoMuted,\n        hasToggledAudio = !1,\n        hasToggledVideo = !1;\n\n    if (self._streamsMutedSettings.audioMuted !== audioMuted && (self._streamsMutedSettings.audioMuted = audioMuted, hasToggledAudio = !0), self._streamsMutedSettings.videoMuted !== videoMuted && (self._streamsMutedSettings.videoMuted = videoMuted, hasToggledVideo = !0), hasToggledVideo || hasToggledAudio) {\n      var streamTracksAvailability = self._muteStreams();\n\n      hasToggledVideo && self._inRoom && self._sendChannelMessage({\n        type: self._SIG_MESSAGE_TYPE.MUTE_VIDEO,\n        mid: self._user.sid,\n        rid: self._room.id,\n        muted: self._streamsMutedSettings.videoMuted,\n        stamp: new Date().getTime()\n      }), hasToggledAudio && self._inRoom && setTimeout(function () {\n        self._sendChannelMessage({\n          type: self._SIG_MESSAGE_TYPE.MUTE_AUDIO,\n          mid: self._user.sid,\n          rid: self._room.id,\n          muted: self._streamsMutedSettings.audioMuted,\n          stamp: new Date().getTime()\n        });\n      }, hasToggledVideo ? 1050 : 0), (streamTracksAvailability.hasVideo && hasToggledVideo || streamTracksAvailability.hasAudio && hasToggledAudio) && (self._trigger(\"localMediaMuted\", {\n        audioMuted: !streamTracksAvailability.hasAudio || self._streamsMutedSettings.audioMuted,\n        videoMuted: !streamTracksAvailability.hasVideo || self._streamsMutedSettings.videoMuted\n      }), self._inRoom && (self._trigger(\"streamMuted\", self._user.sid, self.getPeerInfo(), !0, self._streams.screenshare && self._streams.screenshare.stream), self._trigger(\"peerUpdated\", self._user.sid, self.getPeerInfo(), !0)));\n    }\n  }, Skylink.prototype.enableAudio = function () {\n    this.muteStream({\n      audioMuted: !1,\n      videoMuted: this._streamsMutedSettings.videoMuted\n    });\n  }, Skylink.prototype.disableAudio = function () {\n    this.muteStream({\n      audioMuted: !0,\n      videoMuted: this._streamsMutedSettings.videoMuted\n    });\n  }, Skylink.prototype.enableVideo = function () {\n    this.muteStream({\n      videoMuted: !1,\n      audioMuted: this._streamsMutedSettings.audioMuted\n    });\n  }, Skylink.prototype.disableVideo = function () {\n    this.muteStream({\n      videoMuted: !0,\n      audioMuted: this._streamsMutedSettings.audioMuted\n    });\n  }, Skylink.prototype.shareScreen = function (enableAudio, mediaSource, callback) {\n    var self = this,\n        enableAudioSettings = !1,\n        useMediaSource = [self.MEDIA_SOURCE.SCREEN],\n        useMediaSourceId = null,\n        checkIfSourceExistsFn = function checkIfSourceExistsFn(val) {\n      for (var prop in self.MEDIA_SOURCE) {\n        if (self.MEDIA_SOURCE.hasOwnProperty(prop) && self.MEDIA_SOURCE[prop] === val) return !0;\n      }\n\n      return !1;\n    };\n\n    if (enableAudio && \"string\" == typeof enableAudio || enableAudio && \"object\" == typeof enableAudio && enableAudio.sourceId && enableAudio.mediaSource) checkIfSourceExistsFn(\"object\" == typeof enableAudio ? enableAudio.mediaSource : enableAudio) && (useMediaSource = [\"object\" == typeof enableAudio ? enableAudio.mediaSource : enableAudio]), useMediaSourceId = \"object\" == typeof enableAudio ? enableAudio.sourceId : null;else if (Array.isArray(enableAudio)) {\n      for (var enableAudioArr = [], i = 0; i < enableAudio.length; i++) {\n        checkIfSourceExistsFn(enableAudio[i]) && enableAudioArr.push(enableAudio[i]);\n      }\n\n      enableAudioArr.length > 0 && (useMediaSource = enableAudioArr);\n    } else enableAudio && \"object\" == typeof enableAudio ? enableAudio.sourceId && enableAudio.mediaSource || (enableAudioSettings = {\n      usedtx: \"boolean\" == typeof enableAudio.usedtx ? enableAudio.usedtx : null,\n      useinbandfec: \"boolean\" == typeof enableAudio.useinbandfec ? enableAudio.useinbandfec : null,\n      stereo: !0 === enableAudio.stereo,\n      echoCancellation: !1 !== enableAudio.echoCancellation,\n      deviceId: enableAudio.deviceId\n    }) : !0 === enableAudio ? enableAudioSettings = !0 === enableAudio && {\n      usedtx: null,\n      useinbandfec: null,\n      stereo: !1,\n      echoCancellation: !0,\n      deviceId: null\n    } : \"function\" == typeof enableAudio && (callback = enableAudio, enableAudio = !1);\n    if (mediaSource && \"string\" == typeof mediaSource || mediaSource && \"object\" == typeof mediaSource && mediaSource.sourceId && mediaSource.mediaSource) checkIfSourceExistsFn(\"object\" == typeof mediaSource ? mediaSource.mediaSource : mediaSource) && (useMediaSource = [\"object\" == typeof mediaSource ? mediaSource.mediaSource : mediaSource]), useMediaSourceId = \"object\" == typeof mediaSource ? mediaSource.sourceId : null;else if (Array.isArray(mediaSource)) {\n      for (var mediaSourceArr = [], i = 0; i < mediaSource.length; i++) {\n        checkIfSourceExistsFn(mediaSource[i]) && mediaSourceArr.push(mediaSource[i]);\n      }\n\n      mediaSourceArr.length > 0 && (useMediaSource = mediaSourceArr);\n    } else \"function\" == typeof mediaSource && (callback = mediaSource);\n    useMediaSource.indexOf(\"audio\") > -1 && -1 === useMediaSource.indexOf(\"tab\") && (useMediaSource.splice(useMediaSource.indexOf(\"audio\"), 1), 0 === useMediaSource.length && (useMediaSource = [self.MEDIA_SOURCE.SCREEN])), self._throttle(function (runFn) {\n      if (runFn) {\n        var settings = {\n          settings: {\n            audio: enableAudioSettings,\n            video: {\n              screenshare: !0,\n              exactConstraints: !1\n            }\n          },\n          getUserMediaSettings: {\n            audio: !1,\n            video: {\n              mediaSource: useMediaSource\n            }\n          }\n        };\n        \"plugin\" === AdapterJS.webrtcDetectedType && useMediaSourceId && (settings.getUserMediaSettings.video.optional = [{\n          screenId: useMediaSourceId\n        }]);\n\n        var mediaAccessSuccessFn = function mediaAccessSuccessFn(stream) {\n          self.off(\"mediaAccessError\", mediaAccessErrorFn), self._inRoom ? (self._trigger(\"incomingStream\", self._user.sid, stream, !0, self.getPeerInfo(), !0, stream.id || stream.label), self._trigger(\"peerUpdated\", self._user.sid, self.getPeerInfo(), !0), Object.keys(self._peerConnections).length > 0 || self._hasMCU ? self._refreshPeerConnection(Object.keys(self._peerConnections), !1, {}, function (err, success) {\n            if (err) return log.error(\"Failed refreshing connections for shareScreen() ->\", err), void (\"function\" == typeof callback && callback(new Error(\"Failed refreshing connections.\"), null));\n            \"function\" == typeof callback && callback(null, stream);\n          }) : \"function\" == typeof callback && callback(null, stream)) : \"function\" == typeof callback && callback(null, stream);\n        },\n            mediaAccessErrorFn = function mediaAccessErrorFn(error) {\n          self.off(\"mediaAccessSuccess\", mediaAccessSuccessFn), \"function\" == typeof callback && callback(error, null);\n        };\n\n        self.once(\"mediaAccessSuccess\", mediaAccessSuccessFn, function (stream, isScreensharing) {\n          return isScreensharing;\n        }), self.once(\"mediaAccessError\", mediaAccessErrorFn, function (error, isScreensharing) {\n          return isScreensharing;\n        });\n        var getUserMediaAudioSettings = !!enableAudioSettings && {\n          echoCancellation: enableAudioSettings.echoCancellation\n        };\n\n        try {\n          var hasDefaultAudioTrack = !1;\n          enableAudioSettings && (\"firefox\" === AdapterJS.webrtcDetectedBrowser ? (hasDefaultAudioTrack = !0, settings.getUserMediaSettings.audio = getUserMediaAudioSettings) : useMediaSource.indexOf(\"audio\") > -1 && useMediaSource.indexOf(\"tab\") > -1 && (hasDefaultAudioTrack = !0, settings.getUserMediaSettings.audio = {}));\n\n          var onSuccessCbFn = function onSuccessCbFn(stream) {\n            if (hasDefaultAudioTrack || !enableAudioSettings) return void self._onStreamAccessSuccess(stream, settings, !0, !1);\n            settings.getUserMediaSettings.audio = getUserMediaAudioSettings;\n\n            var onAudioSuccessCbFn = function onAudioSuccessCbFn(audioStream) {\n              try {\n                audioStream.addTrack(stream.getVideoTracks()[0]), self.once(\"mediaAccessSuccess\", function () {\n                  self._streams.screenshare.streamClone = stream;\n                }, function (stream, isScreensharing) {\n                  return isScreensharing;\n                }), self._onStreamAccessSuccess(audioStream, settings, !0, !1);\n              } catch (error) {\n                log.error(\"Failed retrieving audio stream for screensharing stream\", error), self._onStreamAccessSuccess(stream, settings, !0, !1);\n              }\n            },\n                onAudioErrorCbFn = function onAudioErrorCbFn(error) {\n              log.error(\"Failed retrieving audio stream for screensharing stream\", error), self._onStreamAccessSuccess(stream, settings, !0, !1);\n            };\n\n            navigator.getUserMedia({\n              audio: getUserMediaAudioSettings\n            }, onAudioSuccessCbFn, onAudioErrorCbFn);\n          },\n              onErrorCbFn = function onErrorCbFn(error) {\n            self._onStreamAccessError(error, settings, !0, !1);\n          };\n\n          if (\"function\" != typeof (AdapterJS || {}).webRTCReady) return onErrorCbFn(new Error(\"Failed to call getUserMedia() as AdapterJS is not yet loaded!\"));\n          AdapterJS.webRTCReady(function () {\n            navigator.getUserMedia(settings.getUserMediaSettings, onSuccessCbFn, onErrorCbFn);\n          });\n        } catch (error) {\n          self._onStreamAccessError(error, settings, !0, !1);\n        }\n      } else if (self._initOptions.throttlingShouldThrowError) {\n        var throttleLimitError = \"Unable to run as throttle interval has not reached (\" + self._initOptions.throttleIntervals.shareScreen + \"ms).\";\n        log.error(throttleLimitError), \"function\" == typeof callback && callback(new Error(throttleLimitError), null);\n      }\n    }, \"shareScreen\", self._initOptions.throttleIntervals.shareScreen);\n  }, Skylink.prototype.stopScreen = function () {\n    this._streams.screenshare && (this._stopStreams({\n      screenshare: !0\n    }), this._inRoom && (this._streams.userMedia && this._streams.userMedia.stream && (this._trigger(\"incomingStream\", this._user.sid, this._streams.userMedia.stream, !0, this.getPeerInfo(), !1, this._streams.userMedia.stream.id || this._streams.userMedia.stream.label), this._trigger(\"peerUpdated\", this._user.sid, this.getPeerInfo(), !0)), this._refreshPeerConnection(Object.keys(this._peerConnections), {}, !1)));\n  }, Skylink.prototype.getStreamSources = function (callback) {\n    var outputSources = {\n      audio: {\n        input: [],\n        output: []\n      },\n      video: {\n        input: []\n      }\n    };\n    if (\"function\" != typeof callback) return log.error(\"Please provide the callback.\");\n\n    var sourcesListFn = function sourcesListFn(sources) {\n      sources.forEach(function (sourceItem) {\n        var item = {\n          deviceId: sourceItem.deviceId || sourceItem.sourceId || \"default\",\n          label: sourceItem.label,\n          groupId: sourceItem.groupId || null\n        };\n        item.label = item.label || \"Source for \" + item.deviceId, [\"audio\", \"audioinput\"].indexOf(sourceItem.kind) > -1 ? outputSources.audio.input.push(item) : [\"video\", \"videoinput\"].indexOf(sourceItem.kind) > -1 ? outputSources.video.input.push(item) : \"audiooutput\" === sourceItem.kind && outputSources.audio.output.push(item);\n      }), callback(outputSources);\n    };\n\n    navigator.mediaDevices && \"function\" == typeof navigator.mediaDevices.enumerateDevices ? navigator.mediaDevices.enumerateDevices().then(sourcesListFn) : window.MediaStreamTrack && \"function\" == typeof MediaStreamTrack.getSources ? MediaStreamTrack.getSources(sourcesListFn) : sourcesListFn(\"function\" == typeof navigator.getUserMedia ? [{\n      deviceId: \"default\",\n      kind: \"audioinput\",\n      label: \"Default Audio Track\"\n    }, {\n      deviceId: \"default\",\n      kind: \"videoinput\",\n      label: \"Default Video Track\"\n    }] : []);\n  }, Skylink.prototype.getScreenSources = function (callback) {\n    var outputSources = {\n      mediaSource: [],\n      mediaSourceInput: []\n    };\n    return \"function\" != typeof callback ? log.error(\"Please provide the callback.\") : navigator.userAgent.toLowerCase().indexOf(\"android\") > -1 ? (\"chrome\" === AdapterJS.webrtcDetectedBrowser && AdapterJS.webrtcDetectedVersion >= 59 && (outputSources.mediaSource = [\"screen\"]), void callback(outputSources)) : \"plugin\" === AdapterJS.webrtcDetectedType ? void AdapterJS.webRTCReady(function () {\n      if (AdapterJS.WebRTCPlugin.plugin && AdapterJS.WebRTCPlugin.plugin.isScreensharingAvailable && AdapterJS.WebRTCPlugin.plugin.HasScreensharingFeature && (outputSources.mediaSource = [\"window\", \"screen\"], \"function\" == typeof AdapterJS.WebRTCPlugin.plugin.getScreensharingSources)) return void AdapterJS.WebRTCPlugin.plugin.getScreensharingSources(function (sources) {\n        sources.forEach(sources, function (sourceItem) {\n          var item = {\n            sourceId: sourceItem.id || sourceItem.sourceId || \"default\",\n            label: sourceItem.label,\n            mediaSource: sourceItem.kind || \"screen\"\n          };\n          item.label = item.label || \"Source for \" + item.sourceId, outputSources.mediaSourceInput.push(item);\n        }), callback(outputSources);\n      });\n      callback(outputSources);\n    }) : ((\"chrome\" === AdapterJS.webrtcDetectedBrowser && AdapterJS.webrtcDetectedVersion >= 34 || \"firefox\" === AdapterJS.webrtcDetectedBrowser && AdapterJS.webrtcDetectedVersion >= 38 || \"opera\" === AdapterJS.webrtcDetectedBrowser && AdapterJS.webrtcDetectedVersion >= 21) && (\"opera\" !== AdapterJS.webrtcDetectedBrowser || AdapterJS.extensionInfo && AdapterJS.extensionInfo.opera && AdapterJS.extensionInfo.opera.extensionId || log.warn(\"Please ensure that your application allows Opera screensharing!\"), outputSources.mediaSource = [\"window\", \"screen\"], \"chrome\" === AdapterJS.webrtcDetectedBrowser && AdapterJS.webrtcDetectedVersion >= 52 || \"opera\" === AdapterJS.webrtcDetectedBrowser && AdapterJS.webrtcDetectedVersion >= 39 ? outputSources.mediaSource.push(\"tab\", \"audio\") : \"firefox\" === AdapterJS.webrtcDetectedBrowser && outputSources.mediaSource.push(\"browser\", \"camera\", \"application\")), void callback(outputSources));\n  }, Skylink.prototype._muteStreams = function () {\n    var self = this,\n        hasVideo = !1,\n        hasAudio = !1,\n        muteFn = function muteFn(stream) {\n      for (var audioTracks = stream.getAudioTracks(), videoTracks = stream.getVideoTracks(), a = 0; a < audioTracks.length; a++) {\n        audioTracks[a].enabled = !self._streamsMutedSettings.audioMuted, hasAudio = !0;\n      }\n\n      for (var v = 0; v < videoTracks.length; v++) {\n        videoTracks[v].enabled = !self._streamsMutedSettings.videoMuted, hasVideo = !0;\n      }\n    };\n\n    if (self._streams.userMedia && self._streams.userMedia.stream && muteFn(self._streams.userMedia.stream), self._streams.screenshare && self._streams.screenshare.stream && muteFn(self._streams.screenshare.stream), self._streams.screenshare && self._streams.screenshare.streamClone && muteFn(self._streams.screenshare.streamClone), \"edge\" === AdapterJS.webrtcDetectedBrowser) for (var peerId in self._peerConnections) {\n      if (self._peerConnections.hasOwnProperty(peerId) && self._peerConnections[peerId]) for (var localStreams = self._peerConnections[peerId].getLocalStreams(), s = 0; s < localStreams.length; s++) {\n        muteFn(localStreams[s]);\n      }\n    }\n    return log.debug(\"Updated Streams muted status ->\", self._streamsMutedSettings), {\n      hasVideo: hasVideo,\n      hasAudio: hasAudio\n    };\n  }, Skylink.prototype._stopStreams = function (options) {\n    var self = this,\n        stopFn = function stopFn(stream) {\n      var streamId = stream.id || stream.label;\n      log.debug([null, \"MediaStream\", streamId, \"Stopping Stream ->\"], stream);\n\n      try {\n        for (var audioTracks = stream.getAudioTracks(), videoTracks = stream.getVideoTracks(), a = 0; a < audioTracks.length; a++) {\n          audioTracks[a].stop();\n        }\n\n        for (var v = 0; v < videoTracks.length; v++) {\n          videoTracks[v].stop();\n        }\n      } catch (error) {\n        stream.stop();\n      }\n\n      self._streamsStoppedCbs[streamId] && (self._streamsStoppedCbs[streamId](), delete self._streamsStoppedCbs[streamId]);\n    },\n        stopUserMedia = !1,\n        stopScreenshare = !1,\n        hasStoppedMedia = !1;\n\n    \"object\" == typeof options && (stopUserMedia = !0 === options.userMedia, stopScreenshare = !0 === options.screenshare), stopUserMedia && self._streams.userMedia && (self._streams.userMedia.stream && stopFn(self._streams.userMedia.stream), self._streams.userMedia = null, hasStoppedMedia = !0), stopScreenshare && self._streams.screenshare && (self._streams.screenshare.streamClone && stopFn(self._streams.screenshare.streamClone), self._streams.screenshare.stream && stopFn(self._streams.screenshare.stream), self._streams.screenshare = null, hasStoppedMedia = !0), self._inRoom && hasStoppedMedia && self._trigger(\"peerUpdated\", self._user.sid, self.getPeerInfo(), !0), log.log(\"Stopping Streams with settings ->\", options);\n  }, Skylink.prototype._parseStreamSettings = function (options) {\n    var settings = {\n      settings: {\n        audio: !1,\n        video: !1\n      },\n      mutedSettings: {\n        shouldAudioMuted: !1,\n        shouldVideoMuted: !1\n      },\n      getUserMediaSettings: {\n        audio: !1,\n        video: !1\n      }\n    };\n    return options.audio && (settings.settings.audio = {\n      stereo: !1,\n      exactConstraints: !!options.useExactConstraints,\n      echoCancellation: !0\n    }, settings.getUserMediaSettings.audio = {\n      echoCancellation: !0\n    }, \"object\" == typeof options.audio && (\"boolean\" == typeof options.audio.stereo && (settings.settings.audio.stereo = options.audio.stereo), \"boolean\" == typeof options.audio.useinbandfec && (settings.settings.audio.useinbandfec = options.audio.useinbandfec), \"boolean\" == typeof options.audio.usedtx && (settings.settings.audio.usedtx = options.audio.usedtx), \"number\" == typeof options.audio.maxplaybackrate && options.audio.maxplaybackrate >= 8e3 && options.audio.maxplaybackrate <= 48e3 && (settings.settings.audio.maxplaybackrate = options.audio.maxplaybackrate), \"boolean\" == typeof options.audio.mute && (settings.mutedSettings.shouldAudioMuted = options.audio.mute), \"edge\" !== AdapterJS.webrtcDetectedBrowser && (\"boolean\" == typeof options.audio.echoCancellation && (settings.settings.audio.echoCancellation = options.audio.echoCancellation, settings.getUserMediaSettings.audio.echoCancellation = options.audio.echoCancellation), Array.isArray(options.audio.optional) && (settings.settings.audio.optional = clone(options.audio.optional), settings.getUserMediaSettings.audio.optional = clone(options.audio.optional)), options.audio.deviceId && \"string\" == typeof options.audio.deviceId && \"firefox\" !== AdapterJS.webrtcDetectedBrowser && (settings.settings.audio.deviceId = options.audio.deviceId, settings.getUserMediaSettings.audio.deviceId = options.useExactConstraints ? {\n      exact: options.audio.deviceId\n    } : {\n      ideal: options.audio.deviceId\n    }))), \"edge\" === AdapterJS.webrtcDetectedBrowser && (settings.getUserMediaSettings.audio = !0)), options.video && (settings.settings.video = {\n      resolution: clone(this.VIDEO_RESOLUTION.VGA),\n      screenshare: !1,\n      exactConstraints: !!options.useExactConstraints\n    }, settings.getUserMediaSettings.video = {}, \"object\" == typeof options.video ? (\"boolean\" == typeof options.video.mute && (settings.mutedSettings.shouldVideoMuted = options.video.mute), Array.isArray(options.video.optional) && (settings.settings.video.optional = clone(options.video.optional), settings.getUserMediaSettings.video.optional = clone(options.video.optional)), options.video.deviceId && \"string\" == typeof options.video.deviceId && (settings.settings.video.deviceId = options.video.deviceId, settings.getUserMediaSettings.video.deviceId = options.useExactConstraints ? {\n      exact: options.video.deviceId\n    } : {\n      ideal: options.video.deviceId\n    }), options.video.resolution && \"object\" == typeof options.video.resolution && ((options.video.resolution.width && \"object\" == typeof options.video.resolution.width || \"number\" == typeof options.video.resolution.width) && (settings.settings.video.resolution.width = options.video.resolution.width), (options.video.resolution.height && \"object\" == typeof options.video.resolution.height || \"number\" == typeof options.video.resolution.height) && (settings.settings.video.resolution.height = options.video.resolution.height)), settings.getUserMediaSettings.video.width = \"object\" == typeof settings.settings.video.resolution.width ? settings.settings.video.resolution.width : options.useExactConstraints ? {\n      exact: settings.settings.video.resolution.width\n    } : {\n      max: settings.settings.video.resolution.width\n    }, settings.getUserMediaSettings.video.height = \"object\" == typeof settings.settings.video.resolution.height ? settings.settings.video.resolution.height : options.useExactConstraints ? {\n      exact: settings.settings.video.resolution.height\n    } : {\n      max: settings.settings.video.resolution.height\n    }, (options.video.frameRate && \"object\" == typeof options.video.frameRate || \"number\" == typeof options.video.frameRate && \"plugin\" !== AdapterJS.webrtcDetectedType) && (settings.settings.video.frameRate = options.video.frameRate, settings.getUserMediaSettings.video.frameRate = \"object\" == typeof settings.settings.video.frameRate ? settings.settings.video.frameRate : options.useExactConstraints ? {\n      exact: settings.settings.video.frameRate\n    } : {\n      max: settings.settings.video.frameRate\n    }), options.video.facingMode && [\"string\", \"object\"].indexOf(typeof options.video.facingMode) > -1 && \"plugin\" === AdapterJS.webrtcDetectedType && (settings.settings.video.facingMode = options.video.facingMode, settings.getUserMediaSettings.video.facingMode = \"object\" == typeof settings.settings.video.facingMode ? settings.settings.video.facingMode : options.useExactConstraints ? {\n      exact: settings.settings.video.facingMode\n    } : {\n      max: settings.settings.video.facingMode\n    })) : settings.getUserMediaSettings.video = {\n      width: options.useExactConstraints ? {\n        exact: settings.settings.video.resolution.width\n      } : {\n        max: settings.settings.video.resolution.width\n      },\n      height: options.useExactConstraints ? {\n        exact: settings.settings.video.resolution.height\n      } : {\n        max: settings.settings.video.resolution.height\n      }\n    }, \"edge\" === AdapterJS.webrtcDetectedBrowser && (settings.settings.video = {\n      screenshare: !1,\n      exactConstraints: !!options.useExactConstraints\n    }, settings.getUserMediaSettings.video = !0)), settings;\n  }, Skylink.prototype._parseStreamTracksInfo = function (streamKey, callback) {\n    var self = this,\n        stream = self._streams[streamKey].stream;\n    if (!stream) return log.warn(\"Unable to parse stream tracks information as the stream is not defined\"), callback();\n    self._streams[streamKey].tracks = {\n      audio: null,\n      video: null\n    };\n    var audioTracks = stream.getAudioTracks(),\n        videoTracks = stream.getVideoTracks();\n    if (audioTracks.length > 0 && (self._streams[streamKey].tracks.audio = {\n      id: audioTracks[0].id || \"\",\n      label: audioTracks[0].label || \"audio_track_0\"\n    }), 0 === videoTracks.length) return callback();\n    self._streams[streamKey].tracks.video = {\n      id: videoTracks[0].id || \"\",\n      label: videoTracks[0].label || \"video_track_0\",\n      width: null,\n      height: null\n    };\n    var videoElement = document.createElement(\"video\");\n    videoElement.autoplay = !0, videoElement.muted = !0, videoElement.volume = 0;\n\n    var onVideoLoaded = function onVideoLoaded() {\n      self._streams[streamKey] && (self._streams[streamKey].tracks.video.width = videoElement.videoWidth, self._streams[streamKey].tracks.video.height = videoElement.videoHeight, videoElement.src = \"\", videoElement.srcObject = null, callback());\n    };\n\n    \"plugin\" === AdapterJS.webrtcDetectedType ? setTimeout(onVideoLoaded, 1500) : videoElement.addEventListener(\"loadeddata\", onVideoLoaded), AdapterJS.attachMediaStream(videoElement, stream);\n  }, Skylink.prototype._onStreamAccessSuccess = function (stream, settings, isScreenSharing, isAudioFallback) {\n    var self = this,\n        streamId = stream.id || stream.label,\n        streamHasEnded = !1;\n\n    if (log.log([null, \"MediaStream\", streamId, \"Has access to stream ->\"], stream), !isScreenSharing && self._streams.userMedia ? self._stopStreams({\n      userMedia: !0,\n      screenshare: !1\n    }) : isScreenSharing && self._streams.screenshare && self._stopStreams({\n      userMedia: !1,\n      screenshare: !0\n    }), self._streamsStoppedCbs[streamId] = function () {\n      log.log([null, \"MediaStream\", streamId, \"Stream has ended\"]), streamHasEnded = !0, self._trigger(\"mediaAccessStopped\", !!isScreenSharing, !!isAudioFallback, streamId), self._inRoom && (log.debug([null, \"MediaStream\", streamId, \"Sending Stream ended status to Peers\"]), self._sendChannelMessage({\n        type: self._SIG_MESSAGE_TYPE.STREAM,\n        mid: self._user.sid,\n        rid: self._room.id,\n        cid: self._key,\n        streamId: streamId,\n        settings: settings.settings,\n        status: \"ended\"\n      }), self._trigger(\"streamEnded\", self._user.sid, self.getPeerInfo(), !0, !!isScreenSharing, streamId), isScreenSharing && self._streams.screenshare && self._streams.screenshare.stream && (self._streams.screenshare.stream.id || self._streams.screenshare.stream.label) === streamId ? self._streams.screenshare = null : !isScreenSharing && self._streams.userMedia && self._streams.userMedia.stream && (self._streams.userMedia.stream.id || self._streams.userMedia.stream.label) === streamId && (self._streams.userMedia = null));\n    }, [\"chrome\", \"opera\"].indexOf(AdapterJS.webrtcDetectedBrowser) > -1 ? (stream.oninactive = function () {\n      self._streamsStoppedCbs[streamId] && (self._streamsStoppedCbs[streamId](), delete self._streamsStoppedCbs[streamId]);\n    }, isScreenSharing && stream.getVideoTracks().length > 0 && (stream.getVideoTracks()[0].onended = function () {\n      setTimeout(function () {\n        !streamHasEnded && self._inRoom && self.stopScreen();\n      }, 350);\n    })) : \"firefox\" === AdapterJS.webrtcDetectedBrowser ? stream.endedInterval = setInterval(function () {\n      void 0 === stream.recordedTime && (stream.recordedTime = 0), stream.recordedTime === stream.currentTime ? (clearInterval(stream.endedInterval), self._streamsStoppedCbs[streamId] && (self._streamsStoppedCbs[streamId](), delete self._streamsStoppedCbs[streamId])) : stream.recordedTime = stream.currentTime;\n    }, 1e3) : stream.onended = function () {\n      self._streamsStoppedCbs[streamId] && (self._streamsStoppedCbs[streamId](), delete self._streamsStoppedCbs[streamId]);\n    }, settings.settings.audio && 0 === stream.getAudioTracks().length || settings.settings.video && 0 === stream.getVideoTracks().length) {\n      var tracksNotSameError = \"Expected audio tracks length with \" + (settings.settings.audio ? \"1\" : \"0\") + \" and video tracks length with \" + (settings.settings.video ? \"1\" : \"0\") + \" but received audio tracks length with \" + stream.getAudioTracks().length + \" and video tracks length with \" + stream.getVideoTracks().length;\n      log.warn([null, \"MediaStream\", streamId, tracksNotSameError]);\n      var requireAudio = !!settings.settings.audio,\n          requireVideo = !!settings.settings.video;\n      settings.settings.audio && 0 === stream.getAudioTracks().length && (settings.settings.audio = !1), settings.settings.video && 0 === stream.getVideoTracks().length && (settings.settings.video = !1), self._trigger(\"mediaAccessFallback\", {\n        error: new Error(tracksNotSameError),\n        diff: {\n          video: {\n            expected: requireVideo ? 1 : 0,\n            received: stream.getVideoTracks().length\n          },\n          audio: {\n            expected: requireAudio ? 1 : 0,\n            received: stream.getAudioTracks().length\n          }\n        }\n      }, self.MEDIA_ACCESS_FALLBACK_STATE.FALLBACKED, !!isScreenSharing, !!isAudioFallback, streamId);\n    }\n\n    self._streams[isScreenSharing ? \"screenshare\" : \"userMedia\"] = {\n      id: streamId,\n      stream: stream,\n      settings: settings.settings,\n      constraints: settings.getUserMediaSettings\n    }, self._muteStreams(), self._parseStreamTracksInfo(isScreenSharing ? \"screenshare\" : \"userMedia\", function () {\n      self._trigger(\"mediaAccessSuccess\", stream, !!isScreenSharing, !!isAudioFallback, streamId);\n    });\n  }, Skylink.prototype._onStreamAccessError = function (error, settings, isScreenSharing) {\n    var self = this;\n\n    if (!isScreenSharing && settings.settings.audio && settings.settings.video && self._initOptions.audioFallback) {\n      log.debug(\"Fallbacking to retrieve audio only Stream\"), self._trigger(\"mediaAccessFallback\", {\n        error: error,\n        diff: null\n      }, self.MEDIA_ACCESS_FALLBACK_STATE.FALLBACKING, !1, !0);\n\n      var onAudioSuccessCbFn = function onAudioSuccessCbFn(stream) {\n        self._onStreamAccessSuccess(stream, settings, !1, !0);\n      },\n          onAudioErrorCbFn = function onAudioErrorCbFn(error) {\n        log.error(\"Failed fallbacking to retrieve audio only Stream ->\", error), self._trigger(\"mediaAccessError\", error, !1, !0), self._trigger(\"mediaAccessFallback\", {\n          error: error,\n          diff: null\n        }, self.MEDIA_ACCESS_FALLBACK_STATE.ERROR, !1, !0);\n      };\n\n      return void navigator.getUserMedia({\n        audio: !0\n      }, onAudioSuccessCbFn, onAudioErrorCbFn);\n    }\n\n    log.error(\"Failed retrieving \" + (isScreenSharing ? \"screensharing\" : \"camera\") + \" Stream ->\", error), self._trigger(\"mediaAccessError\", error, !!isScreenSharing, !1);\n  }, Skylink.prototype._onRemoteStreamAdded = function (targetMid, stream, isScreenSharing) {\n    var self = this,\n        streamId = self._peerConnections[targetMid] && self._peerConnections[targetMid].remoteStreamId || stream.id || stream.label;\n    if (!self._peerInformations[targetMid]) return void log.warn([targetMid, \"MediaStream\", streamId, \"Received remote stream when peer is not connected. Ignoring stream ->\"], stream);\n    log.log([targetMid, \"MediaStream\", streamId, \"Received remote stream ->\"], stream), isScreenSharing && log.log([targetMid, \"MediaStream\", streamId, \"Peer is having a screensharing session with user\"]), self._trigger(\"incomingStream\", targetMid, stream, !1, self.getPeerInfo(targetMid), isScreenSharing, streamId), self._trigger(\"peerUpdated\", targetMid, self.getPeerInfo(targetMid), !1);\n  }, Skylink.prototype._addLocalMediaStreams = function (peerId) {\n    var self = this;\n\n    try {\n      log.log([peerId, null, null, \"Adding local stream\"]);\n      var pc = self._peerConnections[peerId];\n\n      if (pc) {\n        var offerToReceiveAudio = !(!self._sdpSettings.connection.audio && \"MCU\" !== peerId) && self._getSDPCommonSupports(peerId, pc.remoteDescription).video,\n            offerToReceiveVideo = !(!self._sdpSettings.connection.video && \"MCU\" !== peerId) && self._getSDPCommonSupports(peerId, pc.remoteDescription).audio;\n\n        if (pc.signalingState !== self.PEER_CONNECTION_STATE.CLOSED) {\n          var updateStreamFn = function updateStreamFn(updatedStream) {\n            if (!updatedStream || !pc.localStreamId || updatedStream.id !== pc.localStreamId) {\n              if (\"edge\" !== AdapterJS.webrtcDetectedBrowser || self._initOptions.useEdgeWebRTC && window.msRTCPeerConnection ? pc.getLocalStreams().forEach(function (stream) {\n                pc.removeStream(stream);\n              }) : pc.getSenders().forEach(function (sender) {\n                pc.removeTrack(sender);\n              }), !offerToReceiveAudio && !offerToReceiveVideo) return;\n              updatedStream && (\"edge\" !== AdapterJS.webrtcDetectedBrowser || self._initOptions.useEdgeWebRTC && window.msRTCPeerConnection ? pc.addStream(updatedStream) : updatedStream.getTracks().forEach(function (track) {\n                \"audio\" === track.kind && !offerToReceiveAudio || \"video\" === track.kind && !offerToReceiveVideo || pc.addTrack(track, updatedStream);\n              }), pc.localStreamId = updatedStream.id || updatedStream.label, pc.localStream = updatedStream);\n            }\n          };\n\n          self._streams.screenshare && self._streams.screenshare.stream ? (log.debug([peerId, \"MediaStream\", null, \"Sending screen\"], self._streams.screenshare.stream), updateStreamFn(self._streams.screenshare.stream)) : self._streams.userMedia && self._streams.userMedia.stream ? (log.debug([peerId, \"MediaStream\", null, \"Sending stream\"], self._streams.userMedia.stream), updateStreamFn(self._streams.userMedia.stream)) : (log.warn([peerId, \"MediaStream\", null, \"No media to send. Will be only receiving\"]), updateStreamFn(null));\n        } else log.warn([peerId, \"MediaStream\", null, \"Not adding any stream as signalingState is closed\"]);\n      } else log.warn([peerId, \"MediaStream\", self._mediaStream, \"Not adding stream as peerconnection object does not exists\"]);\n    } catch (error) {\n      (error.message || \"\").indexOf(\"already added\") > -1 ? log.warn([peerId, null, null, \"Not re-adding stream as LocalMediaStream is already added\"], error) : log.error([peerId, null, null, \"Failed adding local stream\"], error);\n    }\n  }, Skylink.prototype._handleEndedStreams = function (peerId, checkStreamId) {\n    var self = this;\n    self._streamsSession[peerId] = self._streamsSession[peerId] || {};\n\n    var renderEndedFn = function renderEndedFn(streamId) {\n      if (self._streamsSession[peerId][streamId]) {\n        var peerInfo = clone(self.getPeerInfo(peerId));\n        peerInfo.settings.audio = clone(self._streamsSession[peerId][streamId].audio), peerInfo.settings.video = clone(self._streamsSession[peerId][streamId].video);\n        var hasScreenshare = peerInfo.settings.video && \"object\" == typeof peerInfo.settings.video && !!peerInfo.settings.video.screenshare;\n        self._streamsSession[peerId][streamId] = !1, self._trigger(\"streamEnded\", peerId, peerInfo, !1, hasScreenshare, streamId);\n      }\n    };\n\n    if (checkStreamId) renderEndedFn(checkStreamId);else if (self._peerConnections[peerId]) for (var streamId in self._streamsSession[peerId]) {\n      self._streamsSession[peerId].hasOwnProperty(streamId) && self._streamsSession[peerId][streamId] && renderEndedFn(streamId);\n    }\n  }, Skylink.prototype._setSDPCodecParams = function (targetMid, sessionDescription) {\n    var self = this,\n        parseFn = function parseFn(type, codecName, samplingRate, settings) {\n      var mLine = sessionDescription.sdp.match(new RegExp(\"m=\" + type + \" .*\\r\\n\", \"gi\"));\n\n      if (Array.isArray(mLine) && mLine.length > 0) {\n        var codecsList = sessionDescription.sdp.match(new RegExp(\"a=rtpmap:.* \" + codecName + \"/\" + (samplingRate ? samplingRate + (\"audio\" === type ? \"[/]*.*\" : \".*\") : \".*\") + \"\\r\\n\", \"gi\"));\n        if (Array.isArray(codecsList) && codecsList.length > 0) for (var i = 0; i < codecsList.length; i++) {\n          var payload = (codecsList[i].split(\"a=rtpmap:\")[1] || \"\").split(\" \")[0];\n\n          if (payload) {\n            var fmtpLine = sessionDescription.sdp.match(new RegExp(\"a=fmtp:\" + payload + \" .*\\r\\n\", \"gi\")),\n                updatedFmtpLine = \"a=fmtp:\" + payload + \" \",\n                addedKeys = [];\n\n            if (Array.isArray(fmtpLine) && fmtpLine.length > 0) {\n              for (var fmtpParts = (fmtpLine[0].split(\"a=fmtp:\" + payload + \" \")[1] || \"\").replace(/ /g, \"\").replace(/\\r\\n/g, \"\").split(\";\"), j = 0; j < fmtpParts.length; j++) {\n                if (fmtpParts[j]) {\n                  var keyAndValue = fmtpParts[j].split(\"=\");\n                  settings.hasOwnProperty(keyAndValue[0]) ? updatedFmtpLine += \"boolean\" == typeof settings[keyAndValue[0]] ? settings[keyAndValue[0]] ? keyAndValue[0] + \"=1;\" : \"\" : keyAndValue[0] + \"=\" + settings[keyAndValue[0]] + \";\" : updatedFmtpLine += fmtpParts[j] + \";\", addedKeys.push(keyAndValue[0]);\n                }\n              }\n\n              sessionDescription.sdp = sessionDescription.sdp.replace(fmtpLine[0], \"\");\n            }\n\n            for (var key in settings) {\n              settings.hasOwnProperty(key) && -1 === addedKeys.indexOf(key) && (updatedFmtpLine += \"boolean\" == typeof settings[key] ? settings[key] ? key + \"=1;\" : \"\" : key + \"=\" + settings[key] + \";\", addedKeys.push(key));\n            }\n\n            updatedFmtpLine !== \"a=fmtp:\" + payload + \" \" && (sessionDescription.sdp = sessionDescription.sdp.replace(codecsList[i], codecsList[i] + updatedFmtpLine + \"\\r\\n\"));\n          }\n        }\n      }\n    };\n\n    return parseFn(\"audio\", self.AUDIO_CODEC.OPUS, 48e3, function () {\n      var opusOptions = {},\n          audioSettings = self._streams.screenshare ? self._streams.screenshare.settings.audio : self._streams.userMedia ? self._streams.userMedia.settings.audio : {};\n      return audioSettings = audioSettings && \"object\" == typeof audioSettings ? audioSettings : {}, \"boolean\" == typeof self._initOptions.codecParams.audio.opus.stereo ? opusOptions.stereo = self._initOptions.codecParams.audio.opus.stereo : \"boolean\" == typeof audioSettings.stereo && (opusOptions.stereo = audioSettings.stereo), \"boolean\" == typeof self._initOptions.codecParams.audio.opus[\"sprop-stereo\"] ? opusOptions[\"sprop-stereo\"] = self._initOptions.codecParams.audio.opus[\"sprop-stereo\"] : \"boolean\" == typeof audioSettings.stereo && (opusOptions[\"sprop-stereo\"] = audioSettings.stereo), \"boolean\" == typeof self._initOptions.codecParams.audio.opus.usedtx ? opusOptions.usedtx = self._initOptions.codecParams.audio.opus.usedtx : \"boolean\" == typeof audioSettings.usedtx && (opusOptions.usedtx = audioSettings.usedtx), \"boolean\" == typeof self._initOptions.codecParams.audio.opus.useinbandfec ? opusOptions.useinbandfec = self._initOptions.codecParams.audio.opus.useinbandfec : \"boolean\" == typeof audioSettings.useinbandfec && (opusOptions.useinbandfec = audioSettings.useinbandfec), \"number\" == typeof self._initOptions.codecParams.audio.opus.maxplaybackrate ? opusOptions.maxplaybackrate = self._initOptions.codecParams.audio.opus.maxplaybackrate : \"number\" == typeof audioSettings.maxplaybackrate && (opusOptions.maxplaybackrate = audioSettings.maxplaybackrate), \"number\" == typeof self._initOptions.codecParams.audio.opus.minptime ? opusOptions.minptime = self._initOptions.codecParams.audio.opus.minptime : \"number\" == typeof audioSettings.minptime && (opusOptions.minptime = audioSettings.minptime), opusOptions;\n    }()), parseFn(\"video\", self.VIDEO_CODEC.VP8, null, function () {\n      var vp8Options = {};\n      return \"number\" == typeof self._initOptions.codecParams.video.vp8.maxFr && (vp8Options[\"max-fr\"] = self._initOptions.codecParams.video.vp8.maxFr), \"number\" == typeof self._initOptions.codecParams.video.vp8.maxFs && (vp8Options[\"max-fs\"] = self._initOptions.codecParams.video.vp8.maxFs), vp8Options;\n    }()), parseFn(\"video\", self.VIDEO_CODEC.VP9, null, function () {\n      var vp9Options = {};\n      return \"number\" == typeof self._initOptions.codecParams.video.vp9.maxFr && (vp9Options[\"max-fr\"] = self._initOptions.codecParams.video.vp9.maxFr), \"number\" == typeof self._initOptions.codecParams.video.vp9.maxFs && (vp9Options[\"max-fs\"] = self._initOptions.codecParams.video.vp9.maxFs), vp9Options;\n    }()), parseFn(\"video\", self.VIDEO_CODEC.H264, null, function () {\n      var h264Options = {};\n      return \"string\" == typeof self._initOptions.codecParams.video.h264.levelAsymmetryAllowed && (h264Options[\"profile-level-id\"] = self._initOptions.codecParams.video.h264.profileLevelId), \"boolean\" == typeof self._initOptions.codecParams.video.h264.levelAsymmetryAllowed && (h264Options[\"level-asymmetry-allowed\"] = self._initOptions.codecParams.video.h264.levelAsymmetryAllowed), \"boolean\" == typeof self._initOptions.codecParams.video.h264.packetizationMode && (h264Options[\"packetization-mode\"] = self._initOptions.codecParams.video.h264.packetizationMode), h264Options;\n    }()), sessionDescription.sdp;\n  }, Skylink.prototype._setSDPBitrate = function (targetMid, sessionDescription) {\n    var sdpLines = sessionDescription.sdp.split(\"\\r\\n\"),\n        parseFn = function parseFn(type, bw) {\n      var mLineType = type,\n          mLineIndex = -1,\n          cLineIndex = -1;\n      \"data\" === type && (mLineType = \"application\");\n\n      for (var i = 0; i < sdpLines.length; i++) {\n        if (0 === sdpLines[i].indexOf(\"m=\" + mLineType)) mLineIndex = i;else if (mLineIndex > 0) {\n          if (0 === sdpLines[i].indexOf(\"m=\")) break;\n          0 === sdpLines[i].indexOf(\"c=\") ? cLineIndex = i : 0 !== sdpLines[i].indexOf(\"b=AS:\") && 0 !== sdpLines[i].indexOf(\"b:TIAS:\") || (sdpLines.splice(i, 1), i--);\n        }\n      }\n\n      return \"number\" == typeof bw && bw > 0 ? -1 === cLineIndex ? void log.error([targetMid, \"RTCSessionDesription\", sessionDescription.type, 'Failed setting \"' + type + '\" bandwidth as c-line is missing.']) : (log.info([targetMid, \"RTCSessionDesription\", sessionDescription.type, 'Limiting maximum sending \"' + type + '\" bandwidth ->'], bw), void sdpLines.splice(cLineIndex + 1, 0, \"firefox\" === window.webrtcDetectedBrowser ? \"b=TIAS:\" + (1e3 * bw * (window.webrtcDetectedVersion > 52 && window.webrtcDetectedVersion < 55 ? 1e3 : 1)).toFixed(0) : \"b=AS:\" + bw)) : void log.warn([targetMid, \"RTCSessionDesription\", sessionDescription.type, 'Not limiting \"' + type + '\" bandwidth']);\n    },\n        bASAudioBw = this._streamsBandwidthSettings.bAS.audio,\n        bASVideoBw = this._streamsBandwidthSettings.bAS.video,\n        bASDataBw = this._streamsBandwidthSettings.bAS.data,\n        googleXMinBw = this._streamsBandwidthSettings.googleX.min,\n        googleXMaxBw = this._streamsBandwidthSettings.googleX.max;\n\n    if (this._peerCustomConfigs[targetMid] && (this._peerCustomConfigs[targetMid].bandwidth && \"object\" == typeof this._peerCustomConfigs[targetMid].bandwidth && (\"number\" == typeof this._peerCustomConfigs[targetMid].bandwidth.audio && (bASAudioBw = this._peerCustomConfigs[targetMid].bandwidth.audio), \"number\" == typeof this._peerCustomConfigs[targetMid].bandwidth.video && (bASVideoBw = this._peerCustomConfigs[targetMid].bandwidth.video), \"number\" == typeof this._peerCustomConfigs[targetMid].bandwidth.data && (bASDataBw = this._peerCustomConfigs[targetMid].bandwidth.data)), this._peerCustomConfigs[targetMid].googleXBandwidth && \"object\" == typeof this._peerCustomConfigs[targetMid].googleXBandwidth && (\"number\" == typeof this._peerCustomConfigs[targetMid].googleXBandwidth.min && (googleXMinBw = this._peerCustomConfigs[targetMid].googleXBandwidth.min), \"number\" == typeof this._peerCustomConfigs[targetMid].googleXBandwidth.max && (googleXMaxBw = this._peerCustomConfigs[targetMid].googleXBandwidth.max))), parseFn(\"audio\", bASAudioBw), parseFn(\"video\", bASVideoBw), parseFn(\"data\", bASDataBw), \"number\" == typeof googleXMinBw || \"number\" == typeof googleXMaxBw) {\n      for (var codec = null, codecRtpMapLineIndex = -1, codecFmtpLineIndex = -1, j = 0; j < sdpLines.length; j++) {\n        if (0 === sdpLines[j].indexOf(\"m=video\")) codec = sdpLines[j].split(\" \")[3];else if (codec) {\n          if (0 === sdpLines[j].indexOf(\"m=\")) break;\n          if (0 === sdpLines[j].indexOf(\"a=rtpmap:\" + codec + \" \")) codecRtpMapLineIndex = j;else if (0 === sdpLines[j].indexOf(\"a=fmtp:\" + codec + \" \")) {\n            sdpLines[j] = sdpLines[j].replace(/x-google-(min|max)-bitrate=[0-9]*[;]*/gi, \"\"), codecFmtpLineIndex = j;\n            break;\n          }\n        }\n      }\n\n      if (codecRtpMapLineIndex > -1) {\n        var xGoogleParams = \"\";\n        \"number\" == typeof googleXMinBw && (xGoogleParams += \"x-google-min-bitrate=\" + googleXMinBw + \";\"), \"number\" == typeof googleXMaxBw && (xGoogleParams += \"x-google-max-bitrate=\" + googleXMaxBw + \";\"), log.info([targetMid, \"RTCSessionDesription\", sessionDescription.type, \"Limiting x-google-bitrate ->\"], xGoogleParams), codecFmtpLineIndex > -1 ? sdpLines[codecFmtpLineIndex] += (sdpLines[codecFmtpLineIndex].split(\" \")[1] ? \";\" : \"\") + xGoogleParams : sdpLines.splice(codecRtpMapLineIndex + 1, 0, \"a=fmtp:\" + codec + \" \" + xGoogleParams);\n      }\n    }\n\n    return sdpLines.join(\"\\r\\n\");\n  }, Skylink.prototype._setSDPCodec = function (targetMid, sessionDescription, overrideSettings) {\n    var self = this,\n        parseFn = function parseFn(type, codecSettings) {\n      var codec = \"object\" == typeof codecSettings ? codecSettings.codec : codecSettings,\n          samplingRate = \"object\" == typeof codecSettings ? codecSettings.samplingRate : null,\n          channels = \"object\" == typeof codecSettings ? codecSettings.channels : null;\n      if (codec === self[\"audio\" === type ? \"AUDIO_CODEC\" : \"VIDEO_CODEC\"].AUTO) return void log.warn([targetMid, \"RTCSessionDesription\", sessionDescription.type, 'Not preferring any codec for \"' + type + '\" streaming. Using browser selection.']);\n      var mLine = sessionDescription.sdp.match(new RegExp(\"m=\" + type + \" .*\\r\\n\", \"gi\"));\n      if (!(Array.isArray(mLine) && mLine.length > 0)) return void log.error([targetMid, \"RTCSessionDesription\", sessionDescription.type, 'Not preferring any codec for \"' + type + '\" streaming as m= line is not found.']);\n\n      var setLineFn = function setLineFn(codecsList, isSROk, isChnlsOk) {\n        if (Array.isArray(codecsList) && codecsList.length > 0) {\n          isSROk || (samplingRate = null), isChnlsOk || (channels = null), log.info([targetMid, \"RTCSessionDesription\", sessionDescription.type, 'Preferring \"' + codec + '\" (samplingRate: ' + (samplingRate || \"n/a\") + \", channels: \" + (channels || \"n/a\") + ') for \"' + type + '\" streaming.']);\n          var line = mLine[0],\n              lineParts = line.replace(\"\\r\\n\", \"\").split(\" \");\n          line = lineParts[0] + \" \" + lineParts[1] + \" \" + lineParts[2] + \" \", lineParts.splice(0, 3);\n\n          for (var i = 0; i < codecsList.length; i++) {\n            var parts = (codecsList[i].split(\"a=rtpmap:\")[1] || \"\").split(\" \");\n            parts.length < 2 || (line += parts[0] + \" \");\n          }\n\n          for (var j = 0; j < lineParts.length; j++) {\n            line.indexOf(\" \" + lineParts[j]) > 0 ? (lineParts.splice(j, 1), j--) : sessionDescription.sdp.match(new RegExp(\"a=rtpmap:\" + lineParts[j] + \" \" + codec + \"/.*\\r\\n\", \"gi\")) && (line += lineParts[j] + \" \", lineParts.splice(j, 1), j--);\n          }\n\n          return line += lineParts.join(\" \") + \"\\r\\n\", sessionDescription.sdp = sessionDescription.sdp.replace(mLine[0], line), !0;\n        }\n      };\n\n      if (samplingRate) {\n        if (\"audio\" === type && channels && setLineFn(sessionDescription.sdp.match(new RegExp(\"a=rtpmap:.* \" + codec + \"/\" + samplingRate + (1 === channels ? \"[/1]*\" : \"/\" + channels) + \"\\r\\n\", \"gi\")), !0, !0)) return;\n        if (setLineFn(sessionDescription.sdp.match(new RegExp(\"a=rtpmap:.* \" + codec + \"/\" + samplingRate + \"[/]*.*\\r\\n\", \"gi\")), !0)) return;\n      }\n\n      \"audio\" === type && channels && setLineFn(sessionDescription.sdp.match(new RegExp(\"a=rtpmap:.* \" + codec + \"/.*/\" + channels + \"\\r\\n\", \"gi\")), !1, !0) || setLineFn(sessionDescription.sdp.match(new RegExp(\"a=rtpmap:.* \" + codec + \"/.*\\r\\n\", \"gi\")));\n    };\n\n    return parseFn(\"audio\", overrideSettings ? overrideSettings.audio : self._initOptions.audioCodec), parseFn(\"video\", overrideSettings ? overrideSettings.video : self._initOptions.videoCodec), sessionDescription.sdp;\n  }, Skylink.prototype._removeSDPFirefoxH264Pref = function (targetMid, sessionDescription) {\n    return log.info([targetMid, \"RTCSessionDesription\", sessionDescription.type, \"Removing Firefox experimental H264 flag to ensure interopability reliability\"]), sessionDescription.sdp.replace(/a=fmtp:0 profile-level-id=0x42e00c;packetization-mode=1\\r\\n/g, \"\");\n  }, Skylink.prototype._removeSDPUnknownAptRtx = function (targetMid, sessionDescription) {\n    for (var mediaLines = (sessionDescription.sdp.split(\"\\r\\n\"), sessionDescription.sdp.split(\"m=\")), formatRtx = function formatRtx(str) {\n      return (str.match(/a=rtpmap:.*\\ rtx\\/.*\\r\\n/gi) || []).forEach(function (line) {\n        var payload = (line.split(\"a=rtpmap:\")[1] || \"\").split(\" \")[0] || \"\",\n            fmtpLine = (str.match(new RegExp(\"a=fmtp:\" + payload + \" .*\\r\\n\", \"gi\")) || [])[0];\n        if (!fmtpLine) return void (str = str.replace(new RegExp(line, \"g\"), \"\"));\n        var codecPayload = (fmtpLine.split(\" apt=\")[1] || \"\").replace(/\\r\\n/gi, \"\");\n        str.match(new RegExp(\"a=rtpmap:\" + codecPayload + \" .*\\r\\n\", \"gi\")) || (str = str.replace(new RegExp(line, \"g\"), \"\"), str = str.replace(new RegExp(fmtpLine, \"g\"), \"\"));\n      }), str;\n    }, formatFmtpRtcpFb = function formatFmtpRtcpFb(str) {\n      return (str.match(/a=(fmtp|rtcp-fb):.*\\ rtx\\/.*\\r\\n/gi) || []).forEach(function (line) {\n        var payload = (line.split(\"a=\" + (line.indexOf(\"rtcp\") > 0 ? \"rtcp-fb\" : \"fmtp\"))[1] || \"\").split(\" \")[0] || \"\";\n        str.match(new RegExp(\"a=rtpmap:\" + payload + \" .*\\r\\n\", \"gi\")) || (str = str.replace(new RegExp(line, \"g\"), \"\"));\n      }), str;\n    }, m = 0; m < mediaLines.length; m++) {\n      mediaLines[m] = formatRtx(mediaLines[m]), mediaLines[m] = formatFmtpRtcpFb(mediaLines[m]);\n    }\n\n    return mediaLines.join(\"m=\");\n  }, Skylink.prototype._removeSDPCodecs = function (targetMid, sessionDescription) {\n    var audioSettings = this.getPeerInfo().settings.audio,\n        parseFn = function parseFn(type, codec) {\n      var payloadList = sessionDescription.sdp.match(new RegExp(\"a=rtpmap:(\\\\d*)\\\\ \" + codec + \".*\", \"gi\"));\n      if (!(Array.isArray(payloadList) && payloadList.length > 0)) return void log.warn([targetMid, \"RTCSessionDesription\", sessionDescription.type, 'Not removing \"' + codec + '\" as it does not exists.']);\n\n      for (var i = 0; i < payloadList.length; i++) {\n        var payload = payloadList[i].split(\" \")[0].split(\":\")[1];\n        log.info([targetMid, \"RTCSessionDesription\", sessionDescription.type, 'Removing \"' + codec + '\" payload ->'], payload), sessionDescription.sdp = sessionDescription.sdp.replace(new RegExp(\"a=rtpmap:\" + payload + \"\\\\ .*\\\\r\\\\n\", \"g\"), \"\"), sessionDescription.sdp = sessionDescription.sdp.replace(new RegExp(\"a=fmtp:\" + payload + \"\\\\ .*\\\\r\\\\n\", \"g\"), \"\"), sessionDescription.sdp = sessionDescription.sdp.replace(new RegExp(\"a=rtpmap:\\\\d+ rtx\\\\/\\\\d+\\\\r\\\\na=fmtp:\\\\d+ apt=\" + payload + \"\\\\r\\\\n\", \"g\"), \"\");\n\n        for (var sdpLines = sessionDescription.sdp.split(\"\\r\\n\"), j = 0; j < sdpLines.length; j++) {\n          if (0 === sdpLines[j].indexOf(\"m=\" + type)) {\n            var parts = sdpLines[j].split(\" \");\n            parts.indexOf(payload) >= 3 && parts.splice(parts.indexOf(payload), 1), sdpLines[j] = parts.join(\" \");\n            break;\n          }\n        }\n\n        sessionDescription.sdp = sdpLines.join(\"\\r\\n\");\n      }\n    };\n\n    return this._initOptions.disableVideoFecCodecs && (this._hasMCU ? log.warn([targetMid, \"RTCSessionDesription\", sessionDescription.type, 'Not removing \"ulpfec\" or \"red\" codecs as connected to MCU to prevent connectivity issues.']) : (parseFn(\"video\", \"red\"), parseFn(\"video\", \"ulpfec\"))), this._initOptions.disableComfortNoiseCodec && audioSettings && \"object\" == typeof audioSettings && audioSettings.stereo && parseFn(\"audio\", \"CN\"), \"edge\" === window.webrtcDetectedBrowser && \"edge\" !== (((this._peerInformations[targetMid] || {}).agent || {}).name || \"unknown\").name && (sessionDescription.sdp = sessionDescription.sdp.replace(/a=rtcp-fb:.*\\ x-message\\ .*\\r\\n/gi, \"\")), sessionDescription.sdp;\n  }, Skylink.prototype._removeSDPREMBPackets = function (targetMid, sessionDescription) {\n    return this._initOptions.disableREMB ? (log.info([targetMid, \"RTCSessionDesription\", sessionDescription.type, \"Removing REMB packets.\"]), sessionDescription.sdp.replace(/a=rtcp-fb:\\d+ goog-remb\\r\\n/g, \"\")) : sessionDescription.sdp;\n  }, Skylink.prototype._getSDPSelectedCodec = function (targetMid, sessionDescription, type, beSilentOnLogs) {\n    var codecInfo = {\n      name: null,\n      implementation: null,\n      clockRate: null,\n      channels: null,\n      payloadType: null,\n      params: null\n    };\n    return sessionDescription && sessionDescription.sdp ? (sessionDescription.sdp.split(\"m=\").forEach(function (mediaItem, index) {\n      if (0 !== index && 0 === mediaItem.indexOf(type + \" \")) {\n        var codecs = (mediaItem.split(\"\\r\\n\")[0] || \"\").split(\" \");\n        codecs.splice(0, 3);\n\n        for (var i = 0; i < codecs.length; i++) {\n          var match = mediaItem.match(new RegExp(\"a=rtpmap:\" + codecs[i] + \".*\\r\\n\", \"gi\"));\n\n          if (match) {\n            var parts = ((match[0] || \"\").replace(/\\r\\n/g, \"\").split(\" \")[1] || \"\").split(\"/\");\n\n            if (!([\"red\", \"ulpfec\", \"telephone-event\", \"cn\", \"rtx\"].indexOf(parts[0].toLowerCase()) > -1)) {\n              codecInfo.name = parts[0], codecInfo.clockRate = parseInt(parts[1], 10) || 0, codecInfo.channels = parseInt(parts[2] || \"1\", 10) || 1, codecInfo.payloadType = parseInt(codecs[i], 10), codecInfo.params = \"\";\n              (mediaItem.match(new RegExp(\"a=fmtp:\" + codecs[i] + \".*\\r\\n\", \"gi\")) || []).forEach(function (paramItem) {\n                codecInfo.params += paramItem.replace(new RegExp(\"a=fmtp:\" + codecs[i], \"gi\"), \"\").replace(/\\ /g, \"\").replace(/\\r\\n/g, \"\");\n              });\n              break;\n            }\n          }\n        }\n      }\n    }), beSilentOnLogs || log.debug([targetMid, \"RTCSessionDesription\", sessionDescription.type, 'Parsing session description \"' + type + '\" codecs ->'], codecInfo), codecInfo) : codecInfo;\n  }, Skylink.prototype._removeSDPFilteredCandidates = function (targetMid, sessionDescription) {\n    return \"MCU\" === targetMid && sessionDescription.type === this.HANDSHAKE_PROGRESS.ANSWER && \"firefox\" === window.webrtcDetectedBrowser && (sessionDescription.sdp = sessionDescription.sdp.replace(/ generation 0/g, \"\"), sessionDescription.sdp = sessionDescription.sdp.replace(/ udp /g, \" UDP \")), this._initOptions.forceTURN && this._hasMCU ? (log.warn([targetMid, \"RTCSessionDesription\", sessionDescription.type, \"Not filtering ICE candidates as TURN connections are enforced as MCU is present (and act as a TURN itself) so filtering of ICE candidate flags are not honoured\"]), sessionDescription.sdp) : (this._initOptions.filterCandidatesType.host && (log.info([targetMid, \"RTCSessionDesription\", sessionDescription.type, 'Removing \"host\" ICE candidates.']), sessionDescription.sdp = sessionDescription.sdp.replace(/a=candidate:.*host.*\\r\\n/g, \"\")), this._initOptions.filterCandidatesType.srflx && (log.info([targetMid, \"RTCSessionDesription\", sessionDescription.type, 'Removing \"srflx\" ICE candidates.']), sessionDescription.sdp = sessionDescription.sdp.replace(/a=candidate:.*srflx.*\\r\\n/g, \"\")), this._initOptions.filterCandidatesType.relay && (log.info([targetMid, \"RTCSessionDesription\", sessionDescription.type, 'Removing \"relay\" ICE candidates.']), sessionDescription.sdp = sessionDescription.sdp.replace(/a=candidate:.*relay.*\\r\\n/g, \"\")), sessionDescription.sdp);\n  }, Skylink.prototype._getCodecsSupport = function (callback) {\n    var self = this;\n    if (self._currentCodecSupport) return void callback(null);\n    if (self._currentCodecSupport = {\n      audio: {},\n      video: {}\n    }, \"AppleWebKit\" === AdapterJS.webrtcDetectedType) return self._currentCodecSupport.audio = {\n      opus: [\"48000/2\"]\n    }, self._currentCodecSupport.video = {\n      h264: [\"48000\"]\n    }, callback(null);\n\n    try {\n      if (\"edge\" === window.webrtcDetectedBrowser) {\n        for (var codecs = RTCRtpSender.getCapabilities().codecs, i = 0; i < codecs.length; i++) {\n          if ([\"audio\", \"video\"].indexOf(codecs[i].kind) > -1 && codecs[i].name) {\n            var codec = codecs[i].name.toLowerCase();\n            self._currentCodecSupport[codecs[i].kind][codec] = codecs[i].clockRate + (codecs[i].numChannels > 1 ? \"/\" + codecs[i].numChannels : \"\");\n          }\n        }\n\n        callback(null);\n      } else {\n        var pc = new RTCPeerConnection(null),\n            offerConstraints = \"plugin\" !== AdapterJS.webrtcDetectedType ? {\n          offerToReceiveAudio: !0,\n          offerToReceiveVideo: !0\n        } : {\n          mandatory: {\n            OfferToReceiveVideo: !0,\n            OfferToReceiveAudio: !0\n          }\n        };\n\n        try {\n          var channel = pc.createDataChannel(\"test\");\n          self._binaryChunkType = channel.binaryType || self._binaryChunkType, self._binaryChunkType = self._binaryChunkType.toLowerCase().indexOf(\"array\") > -1 ? self.DATA_TRANSFER_DATA_TYPE.ARRAY_BUFFER : self._binaryChunkType;\n\n          for (var prop in self.DATA_TRANSFER_DATA_TYPE) {\n            if (self.DATA_TRANSFER_DATA_TYPE.hasOwnProperty(prop) && self._binaryChunkType.toLowerCase() === self.DATA_TRANSFER_DATA_TYPE[prop].toLowerCase()) {\n              self._binaryChunkType = self.DATA_TRANSFER_DATA_TYPE[prop];\n              break;\n            }\n          }\n        } catch (e) {}\n\n        pc.createOffer(function (offer) {\n          self._currentCodecSupport = self._getSDPCodecsSupport(null, offer), callback(null);\n        }, function (error) {\n          callback(error);\n        }, offerConstraints);\n      }\n    } catch (error) {\n      callback(error);\n    }\n  }, Skylink.prototype._handleSDPConnectionSettings = function (targetMid, sessionDescription, direction) {\n    var self = this;\n    if (!self._sdpSessions[targetMid]) return sessionDescription.sdp;\n    var sessionDescriptionStr = sessionDescription.sdp;\n    \"remote\" !== direction || self.getPeerInfo(targetMid).config.enableIceTrickle || (sessionDescriptionStr = sessionDescriptionStr.replace(/a=end-of-candidates\\r\\n/g, \"\"));\n    var sdpLines = sessionDescriptionStr.split(\"\\r\\n\"),\n        peerAgent = ((self._peerInformations[targetMid] || {}).agent || {}).name || \"\",\n        mediaType = (self._peerInformations[targetMid], \"\"),\n        bundleLineIndex = -1,\n        bundleLineMids = [],\n        mLineIndex = -1,\n        settings = clone(self._sdpSettings);\n\n    if (\"MCU\" === targetMid && (settings.connection.audio = !0, settings.connection.video = !0, settings.connection.data = !0), self._hasMCU) {\n      var peerStreamSettings = clone(self.getPeerInfo(targetMid)).settings || {};\n      settings.direction.audio.receive = \"MCU\" !== targetMid && !!peerStreamSettings.audio, settings.direction.audio.send = \"MCU\" === targetMid, settings.direction.video.receive = \"MCU\" !== targetMid && !!peerStreamSettings.video, settings.direction.video.send = \"MCU\" === targetMid;\n    }\n\n    if (\"remote\" === direction) {\n      var offerCodecs = self._getSDPCommonSupports(targetMid, sessionDescription);\n\n      offerCodecs.audio || (settings.connection.audio = !1), offerCodecs.video || (settings.connection.video = !1);\n    }\n\n    self._sdpSessions[targetMid][direction].mLines = [], self._sdpSessions[targetMid][direction].bundleLine = \"\", self._sdpSessions[targetMid][direction].connection = {\n      audio: null,\n      video: null,\n      data: null\n    };\n\n    for (var i = 0; i < sdpLines.length; i++) {\n      if (0 === sdpLines[i].indexOf(\"a=group:BUNDLE\")) self._sdpSessions[targetMid][direction].bundleLine = sdpLines[i], bundleLineIndex = i;else if (0 === sdpLines[i].indexOf(\"m=\") && (mediaType = (sdpLines[i].split(\"m=\")[1] || \"\").split(\" \")[0] || \"\", mediaType = \"application\" === mediaType ? \"data\" : mediaType, mLineIndex++, self._sdpSessions[targetMid][direction].mLines[mLineIndex] = sdpLines[i], !settings.connection[mediaType])) {\n        if (log.log([targetMid, \"RTCSessionDesription\", sessionDescription.type, \"Removing rejected m=\" + mediaType + \" line ->\"], sdpLines[i]), self._peerConnectionConfig.bundlePolicy === self.BUNDLE_POLICY.MAX_BUNDLE && bundleLineIndex > -1 && 0 === mLineIndex && (\"remote\" === direction ? sessionDescription.type === this.HANDSHAKE_PROGRESS.OFFER : sessionDescription.type === this.HANDSHAKE_PROGRESS.ANSWER)) {\n          log.warn([targetMid, \"RTCSessionDesription\", sessionDescription.type, \"Not removing rejected m=\" + mediaType + \" line ->\"], sdpLines[i]), settings.connection[mediaType] = !0, [\"audio\", \"video\"].indexOf(mediaType) > -1 && (settings.direction[mediaType].send = !1, settings.direction[mediaType].receive = !1);\n          continue;\n        }\n\n        if (\"edge\" === window.webrtcDetectedBrowser) {\n          sdpLines.splice(i, 1), i--;\n          continue;\n        }\n\n        if (\"remote\" === direction || sessionDescription.type === this.HANDSHAKE_PROGRESS.ANSWER) {\n          var parts = sdpLines[i].split(\" \");\n          parts[1] = 0, sdpLines[i] = parts.join(\" \");\n          continue;\n        }\n      }\n      if (\"remote\" !== direction || 0 !== sdpLines[i].indexOf(\"a=candidate:\") || self.getPeerInfo(targetMid).config.enableIceTrickle || sdpLines[i + 1] && (0 === sdpLines[i + 1].indexOf(\"a=candidate:\") || 0 === sdpLines[i + 1].indexOf(\"a=end-of-candidates\")) || (log.info([targetMid, \"RTCSessionDesription\", sessionDescription.type, \"Appending end-of-candidates signal for non-trickle ICE connection.\"]), sdpLines.splice(i + 1, 0, \"a=end-of-candidates\"), i++), mediaType) if (settings.connection[mediaType]) {\n        if (0 === sdpLines[i].indexOf(\"a=mid:\")) bundleLineMids.push(sdpLines[i].split(\"a=mid:\")[1] || \"\");else if (mediaType && [\"a=sendrecv\", \"a=sendonly\", \"a=recvonly\"].indexOf(sdpLines[i]) > -1) {\n          if (-1 === [\"audio\", \"video\"].indexOf(mediaType)) {\n            self._sdpSessions[targetMid][direction].connection.data = sdpLines[i];\n            continue;\n          }\n\n          if (\"local\" === direction) settings.direction[mediaType].send && !settings.direction[mediaType].receive ? sdpLines[i] = sdpLines[i].indexOf(\"send\") > -1 ? \"a=sendonly\" : \"a=inactive\" : !settings.direction[mediaType].send && settings.direction[mediaType].receive ? sdpLines[i] = sdpLines[i].indexOf(\"recv\") > -1 ? \"a=recvonly\" : \"a=inactive\" : settings.direction[mediaType].send || settings.direction[mediaType].receive || (sdpLines[i] = \"a=inactive\"), self._hasMCU || \"firefox\" === window.webrtcDetectedBrowser || \"firefox\" !== peerAgent || sessionDescription.type !== self.HANDSHAKE_PROGRESS.OFFER || \"a=recvonly\" !== sdpLines[i] || (log.warn([targetMid, \"RTCSessionDesription\", sessionDescription.type, \"Overriding any original settings to receive only to send and receive to resolve chrome BUNDLE errors.\"]), sdpLines[i] = \"a=sendrecv\", settings.direction[mediaType].send = !0, settings.direction[mediaType].receive = !0);else if (sessionDescription.type === self.HANDSHAKE_PROGRESS.ANSWER) {\n            var localOfferRes = self._sdpSessions[targetMid].local.connection[mediaType];\n            \"a=sendonly\" === localOfferRes ? sdpLines[i] = -1 === [\"a=inactive\", \"a=recvonly\"].indexOf(sdpLines[i]) ? \"a=sendonly\" === sdpLines[i] ? \"a=inactive\" : \"a=recvonly\" : sdpLines[i] : \"a=recvonly\" === localOfferRes ? sdpLines[i] = -1 === [\"a=inactive\", \"a=sendonly\"].indexOf(sdpLines[i]) ? \"a=recvonly\" === sdpLines[i] ? \"a=inactive\" : \"a=sendonly\" : sdpLines[i] : \"a=inactive\" === localOfferRes && (sdpLines[i] = \"a=inactive\");\n          }\n          self._sdpSessions[targetMid][direction].connection[mediaType] = sdpLines[i];\n        }\n      } else sdpLines.splice(i, 1), i--;\n      (sdpLines[i] || \"\").replace(/\\n|\\r|\\s|\\ /gi, \"\") || (sdpLines.splice(i, 1), i--);\n    }\n\n    return bundleLineIndex > -1 && (self._peerConnectionConfig.bundlePolicy === self.BUNDLE_POLICY.MAX_BUNDLE ? sdpLines[bundleLineIndex] = \"a=group:BUNDLE \" + bundleLineMids.join(\" \") : self._peerConnectionConfig.bundlePolicy === self.BUNDLE_POLICY.NONE && sdpLines.splice(bundleLineIndex, 1)), \"edge\" !== window.webrtcDetectedBrowser && (sdpLines[sdpLines.length - 1].replace(/\\n|\\r|\\s/gi, \"\") ? sdpLines.push(\"\") : sdpLines[sdpLines.length - 1] = \"\"), log.info([targetMid, \"RTCSessionDesription\", sessionDescription.type, \"Handling connection lines and direction ->\"], settings), sdpLines.join(\"\\r\\n\");\n  }, Skylink.prototype._getSDPFingerprint = function (targetMid, sessionDescription, beSilentOnLogs) {\n    var fingerprint = {\n      fingerprint: null,\n      fingerprintAlgorithm: null,\n      derBase64: null\n    };\n    if (!sessionDescription || !sessionDescription.sdp) return fingerprint;\n\n    for (var sdpLines = sessionDescription.sdp.split(\"\\r\\n\"), i = 0; i < sdpLines.length; i++) {\n      if (0 === sdpLines[i].indexOf(\"a=fingerprint\")) {\n        var parts = sdpLines[i].replace(\"a=fingerprint:\", \"\").split(\" \");\n        fingerprint.fingerprint = parts[1], fingerprint.fingerprintAlgorithm = parts[0];\n        break;\n      }\n    }\n\n    return beSilentOnLogs || log.debug([targetMid, \"RTCSessionDesription\", sessionDescription.type, \"Parsing session description fingerprint ->\"], fingerprint), fingerprint;\n  }, Skylink.prototype._renderSDPOutput = function (targetMid, sessionDescription) {\n    var self = this,\n        localStream = null,\n        localStreamId = null;\n\n    if (sessionDescription && sessionDescription.sdp) {\n      if (!self._peerConnections[targetMid]) return sessionDescription.sdp;\n      self._peerConnections[targetMid].localStream && (localStream = self._peerConnections[targetMid].localStream, localStreamId = self._peerConnections[targetMid].localStreamId || self._peerConnections[targetMid].localStream.id);\n      var sdpLines = (self._initOptions.enableIceTrickle ? sessionDescription.sdp : sessionDescription.sdp.replace(/a=end-of-candidates\\r\\n/g, \"\")).split(\"\\r\\n\");\n      self._peerInformations[targetMid];\n      if (localStream) for (var mediaType = \"\", i = 0; i < sdpLines.length; i++) {\n        if (0 === sdpLines[i].indexOf(\"m=\")) mediaType = (sdpLines[i].split(\"m=\")[1] || \"\").split(\" \")[0] || \"\", mediaType = -1 === [\"audio\", \"video\"].indexOf(mediaType) ? \"\" : mediaType;else if (mediaType) if (0 === sdpLines[i].indexOf(\"a=msid:\")) {\n          var msidParts = sdpLines[i].split(\" \");\n          msidParts[0] = \"a=msid:\" + localStreamId, sdpLines[i] = msidParts.join(\" \");\n        } else if (0 === sdpLines[i].indexOf(\"a=ssrc:\")) {\n          var ssrcParts = null;\n\n          if (sdpLines[i].indexOf(\" msid:\") > 0 ? ssrcParts = sdpLines[i].split(\" msid:\") : sdpLines[i].indexOf(\" mslabel:\") > 0 && (ssrcParts = sdpLines[i].split(\" mslabel:\")), ssrcParts) {\n            var ssrcMsidParts = (ssrcParts[1] || \"\").split(\" \");\n            ssrcMsidParts[0] = localStreamId, ssrcParts[1] = ssrcMsidParts.join(\" \"), sdpLines[i].indexOf(\" msid:\") > 0 ? sdpLines[i] = ssrcParts.join(\" msid:\") : sdpLines[i].indexOf(\" mslabel:\") > 0 && (sdpLines[i] = ssrcParts.join(\" mslabel:\"));\n          }\n        }\n      }\n\n      if (!self._initOptions.enableIceTrickle) {\n        log.info([targetMid, \"RTCSessionDesription\", sessionDescription.type, \"Appending end-of-candidates signal for non-trickle ICE connection.\"]);\n\n        for (var e = 0; e < sdpLines.length; e++) {\n          0 === sdpLines[e].indexOf(\"a=candidate:\") && (sdpLines[e + 1] && (0 === sdpLines[e + 1].indexOf(\"a=candidate:\") || 0 === sdpLines[e + 1].indexOf(\"a=end-of-candidates\")) || (sdpLines.splice(e + 1, 0, \"a=end-of-candidates\"), e++));\n        }\n      }\n\n      if (sessionDescription.type === this.HANDSHAKE_PROGRESS.ANSWER && this._sdpSessions[targetMid]) {\n        for (var mLineIndex = -1, j = 0; j < sdpLines.length; j++) {\n          if (0 === sdpLines[j].indexOf(\"a=group:BUNDLE\") && this._sdpSessions[targetMid].remote.bundleLine && this._peerConnectionConfig.bundlePolicy === this.BUNDLE_POLICY.MAX_BUNDLE) sdpLines[j] = this._sdpSessions[targetMid].remote.bundleLine;else if (0 === sdpLines[j].indexOf(\"m=\")) {\n            mLineIndex++;\n            var compareA = sdpLines[j].split(\" \"),\n                compareB = (this._sdpSessions[targetMid].remote.mLines[mLineIndex] || \"\").split(\" \");\n            compareA[0] && compareB[0] && compareA[0] !== compareB[0] && (compareB[1] = 0, log.info([targetMid, \"RTCSessionDesription\", sessionDescription.type, \"Appending middle rejected m= line ->\"], compareB.join(\" \")), sdpLines.splice(j, 0, compareB.join(\" \")), j++, mLineIndex++);\n          }\n        }\n\n        for (; this._sdpSessions[targetMid].remote.mLines[mLineIndex + 1];) {\n          mLineIndex++;\n          var appendIndex = sdpLines.length;\n          sdpLines[appendIndex - 1].replace(/\\s/gi, \"\") || (appendIndex -= 1);\n          var parts = (this._sdpSessions[targetMid].remote.mLines[mLineIndex] || \"\").split(\" \");\n          parts[1] = 0, log.info([targetMid, \"RTCSessionDesription\", sessionDescription.type, \"Appending later rejected m= line ->\"], parts.join(\" \")), sdpLines.splice(appendIndex, 0, parts.join(\" \"));\n        }\n      }\n\n      return \"edge\" !== window.webrtcDetectedBrowser || sessionDescription.type !== this.HANDSHAKE_PROGRESS.OFFER || sdpLines[sdpLines.length - 1].replace(/\\s/gi, \"\") || (log.info([targetMid, \"RTCSessionDesription\", sessionDescription.type, \"Removing last empty space for Edge browsers\"]), sdpLines.splice(sdpLines.length - 1, 1)), log.info([targetMid, \"RTCSessionDescription\", sessionDescription.type, \"Formatted output ->\"], sdpLines.join(\"\\r\\n\")), sdpLines.join(\"\\r\\n\");\n    }\n  }, Skylink.prototype._parseSDPMediaStreamIDs = function (targetMid, sessionDescription) {\n    if (this._peerConnections[targetMid]) {\n      if (!sessionDescription || !sessionDescription.sdp) return void (this._peerConnections[targetMid].remoteStreamId = null);\n\n      for (var sdpLines = sessionDescription.sdp.split(\"\\r\\n\"), currentStreamId = null, i = 0; i < sdpLines.length; i++) {\n        if (0 === sdpLines[i].indexOf(\"a=msid:\")) {\n          currentStreamId = (sdpLines[i].split(\"a=msid:\")[1] || \"\").split(\" \")[0];\n          break;\n        }\n\n        if (0 === sdpLines[i].indexOf(\"a=ssrc:\") && sdpLines[i].indexOf(\" msid:\") > 0) {\n          currentStreamId = (sdpLines[i].split(\" msid:\")[1] || \"\").split(\" \")[0];\n          break;\n        }\n      }\n\n      currentStreamId ? currentStreamId !== this._peerConnections[targetMid].remoteStreamId ? (log.info([targetMid, \"RTCSessionDesription\", sessionDescription.type, \"New remote stream is sent ->\"], currentStreamId), this._peerConnections[targetMid].remoteStreamId = currentStreamId) : log.info([targetMid, \"RTCSessionDesription\", sessionDescription.type, \"Same remote stream is sent ->\"], currentStreamId) : (log.info([targetMid, \"RTCSessionDesription\", sessionDescription.type, \"No remote stream is sent.\"]), this._peerConnections[targetMid].remoteStreamId = null);\n    }\n  }, Skylink.prototype._getSDPICECandidates = function (targetMid, sessionDescription, beSilentOnLogs) {\n    var candidates = {\n      host: [],\n      srflx: [],\n      relay: []\n    };\n    return sessionDescription && sessionDescription.sdp ? (sessionDescription.sdp.split(\"m=\").forEach(function (mediaItem, index) {\n      if (0 !== index) {\n        var sdpMid = ((mediaItem.match(/a=mid:.*\\r\\n/gi) || [])[0] || \"\").replace(/a=mid:/gi, \"\").replace(/\\r\\n/, \"\"),\n            sdpMLineIndex = index - 1;\n        (mediaItem.match(/a=candidate:.*\\r\\n/gi) || []).forEach(function (item) {\n          var canType = (item.split(\" \")[7] || \"host\").replace(/\\r\\n/g, \"\");\n          candidates[canType] = candidates[canType] || [], candidates[canType].push(new RTCIceCandidate({\n            sdpMid: sdpMid,\n            sdpMLineIndex: sdpMLineIndex,\n            candidate: (item.split(\"a=\")[1] || \"\").replace(/\\r\\n/g, \"\")\n          }));\n        });\n      }\n    }), beSilentOnLogs || log.debug([targetMid, \"RTCSessionDesription\", sessionDescription.type, \"Parsing session description ICE candidates ->\"], candidates), candidates) : candidates;\n  }, Skylink.prototype._getSDPMediaSSRC = function (targetMid, sessionDescription, beSilentOnLogs) {\n    var ssrcs = {\n      audio: 0,\n      video: 0\n    };\n    return sessionDescription && sessionDescription.sdp ? (sessionDescription.sdp.split(\"m=\").forEach(function (mediaItem, index) {\n      if (0 !== index) {\n        var mediaType = mediaItem.split(\" \")[0] || \"\",\n            ssrcLine = (mediaItem.match(/a=ssrc:.*\\r\\n/) || [])[0];\n        \"number\" == typeof ssrcs[mediaType] && ssrcLine && (ssrcs[mediaType] = parseInt((ssrcLine.split(\"a=ssrc:\")[1] || \"\").split(\" \")[0], 10) || 0);\n      }\n    }), beSilentOnLogs || log.debug([targetMid, \"RTCSessionDesription\", sessionDescription.type, \"Parsing session description media SSRCs ->\"], ssrcs), ssrcs) : ssrcs;\n  }, Skylink.prototype._getSDPCodecsSupport = function (targetMid, sessionDescription) {\n    var codecs = {\n      audio: {},\n      video: {}\n    };\n    if (!sessionDescription || !sessionDescription.sdp) return codecs;\n\n    for (var sdpLines = sessionDescription.sdp.split(\"\\r\\n\"), mediaType = \"\", i = 0; i < sdpLines.length; i++) {\n      if (0 !== sdpLines[i].indexOf(\"m=\")) {\n        if (0 === sdpLines[i].indexOf(\"a=rtpmap:\")) {\n          var parts = (sdpLines[i].split(\" \")[1] || \"\").split(\"/\"),\n              codec = (parts[0] || \"\").toLowerCase(),\n              info = parts[1] + (parts[2] ? \"/\" + parts[2] : \"\");\n          if ([\"ulpfec\", \"red\", \"telephone-event\", \"cn\", \"rtx\"].indexOf(codec) > -1) continue;\n          codecs[mediaType][codec] = codecs[mediaType][codec] || [], -1 === codecs[mediaType][codec].indexOf(info) && codecs[mediaType][codec].push(info);\n        }\n      } else mediaType = (sdpLines[i].split(\"m=\")[1] || \"\").split(\" \")[0];\n    }\n\n    return log.info([targetMid || null, \"RTCSessionDescription\", sessionDescription.type, \"Parsed codecs support ->\"], codecs), codecs;\n  }, Skylink.prototype._getSDPCommonSupports = function (targetMid, sessionDescription) {\n    var self = this,\n        offer = {\n      audio: !1,\n      video: !1\n    };\n\n    if (!targetMid || !sessionDescription || !sessionDescription.sdp) {\n      if (offer.video = !(!self._currentCodecSupport.video.h264 && !self._currentCodecSupport.video.vp8), offer.audio = !!self._currentCodecSupport.audio.opus, targetMid) {\n        var peerAgent = ((self._peerInformations[targetMid] || {}).agent || {}).name || \"\";\n        AdapterJS.webrtcDetectedBrowser === peerAgent && (offer.video = Object.keys(self._currentCodecSupport.video).length > 0, offer.audio = Object.keys(self._currentCodecSupport.audio).length > 0);\n      }\n\n      return offer;\n    }\n\n    var remoteCodecs = self._getSDPCodecsSupport(targetMid, sessionDescription),\n        localCodecs = self._currentCodecSupport;\n\n    for (var ac in localCodecs.audio) {\n      if (localCodecs.audio.hasOwnProperty(ac) && localCodecs.audio[ac] && remoteCodecs.audio[ac]) {\n        offer.audio = !0;\n        break;\n      }\n    }\n\n    for (var vc in localCodecs.video) {\n      if (localCodecs.video.hasOwnProperty(vc) && localCodecs.video[vc] && remoteCodecs.video[vc]) {\n        offer.video = !0;\n        break;\n      }\n    }\n\n    return offer;\n  }, Skylink.prototype._setSCTPport = function (targetMid, sessionDescription) {\n    var self = this;\n\n    if (\"firefox\" === AdapterJS.webrtcDetectedBrowser && AdapterJS.webrtcDetectedVersion >= 63 && !0 === self._hasMCU) {\n      for (var sdpLines = sessionDescription.sdp.split(\"\\r\\n\"), mLineType = \"application\", mLineIndex = -1, sdpType = sessionDescription.type, i = 0; i < sdpLines.length; i++) {\n        if (0 === sdpLines[i].indexOf(\"m=\" + mLineType)) mLineIndex = i;else if (mLineIndex > 0) {\n          if (0 === sdpLines[i].indexOf(\"m=\")) break;\n\n          if (\"offer\" === sdpType) {\n            self._mline = sdpLines[mLineIndex];\n            break;\n          }\n\n          if (\"answer\" === sdpType) {\n            sdpLines[mLineIndex] = self._mline, sdpLines.splice(mLineIndex + 1, 0, \"a=sctp-port:5000\");\n            break;\n          }\n        }\n      }\n\n      return sdpLines.join(\"\\r\\n\");\n    }\n\n    return sessionDescription.sdp;\n  }, \"undefined\" != typeof exports ? module.exports = {\n    Skylink: Skylink,\n    SkylinkLogs: SkylinkLogs\n  } : globals ? (globals.Skylink = Skylink, globals.SkylinkLogs = SkylinkLogs) : window && (window.Skylink = Skylink, window.SkylinkLogs = SkylinkLogs);\n}(this);","map":null,"metadata":{},"sourceType":"script"}